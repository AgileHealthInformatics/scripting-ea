**Tito Castillo**

**August 2025**

© 2025 Agile Health Informatics Ltd

All rights reserved.

No part of this publication may be reproduced, stored in a retrieval
system, or transmitted in any form or by any means, electronic,
mechanical, photocopying, recording or otherwise, without the prior
written permission of the copyright owner, except in the case of brief
quotations used in reviews, academic citation, or other fair use under
applicable copyright law.

First published in 2025 by Agile Health Informatics Ltd., London, United
Kingdom

ISBN: 9798262358793 (Paperback)

Printed in the United Kingdom by Kindle Direct Publishing (KDP)

# **Contents**

[Chapter 1: Why Script EA?
[1](#chapter-1-why-script-ea)](#chapter-1-why-script-ea)

[Benefits of Automation in Modelling
[1](#benefits-of-automation-in-modelling)](#benefits-of-automation-in-modelling)

[Typical Use Cases [1](#typical-use-cases)](#typical-use-cases)

[When Not to Script [2](#when-not-to-script)](#when-not-to-script)

[Why Scripting Matters for Governance
[2](#why-scripting-matters-for-governance)](#why-scripting-matters-for-governance)

[Your First “Hello EA” Script
[3](#your-first-hello-ea-script)](#your-first-hello-ea-script)

[Safe Practice: The Dry Run Principle
[4](#safe-practice-the-dry-run-principle)](#safe-practice-the-dry-run-principle)

[A Different Way of Modelling
[4](#a-different-way-of-modelling)](#a-different-way-of-modelling)

[Preparing for the Examples
[4](#preparing-for-the-examples)](#preparing-for-the-examples)

[Looking Ahead [5](#looking-ahead)](#looking-ahead)

[Chapter 2: Automation Landscape
[6](#chapter-2-automation-landscape)](#chapter-2-automation-landscape)

[Built-In Script Engine
[6](#built-in-script-engine)](#built-in-script-engine)

[Scripting options [6](#scripting-options)](#scripting-options)

[External Automation [7](#external-automation)](#external-automation)

[“Hello EA” Examples [7](#hello-ea-examples)](#hello-ea-examples)

[Comparing the Three [9](#comparing-the-three)](#comparing-the-three)

[The Role of COM [9](#the-role-of-com)](#the-role-of-com)

[Choosing the Right Tool
[10](#choosing-the-right-tool)](#choosing-the-right-tool)

[Safety in Each Layer
[10](#safety-in-each-layer)](#safety-in-each-layer)

[Shaping Automation Practice
[10](#shaping-automation-practice)](#shaping-automation-practice)

[Looking Ahead [11](#looking-ahead-1)](#looking-ahead-1)

[Chapter 3: Getting Started
[12](#chapter-3-getting-started)](#chapter-3-getting-started)

[The Importance of Backups
[12](#the-importance-of-backups)](#the-importance-of-backups)

[The Dry-Run Principle
[13](#the-dry-run-principle)](#the-dry-run-principle)

[Logging and Transparency
[13](#logging-and-transparency)](#logging-and-transparency)

[Understanding the Repository Structure
[13](#understanding-the-repository-structure)](#understanding-the-repository-structure)

[Update and Refresh [14](#update-and-refresh)](#update-and-refresh)

[Avoiding Dangerous Patterns
[15](#avoiding-dangerous-patterns)](#avoiding-dangerous-patterns)

[Testing on Small Sets
[15](#testing-on-small-sets)](#testing-on-small-sets)

[Cultural Safety [15](#cultural-safety)](#cultural-safety)

[Building the Right Habits
[16](#building-the-right-habits)](#building-the-right-habits)

[Chapter 4: API Essentials
[17](#chapter-4-api-essentials)](#chapter-4-api-essentials)

[Why Understand the API?
[17](#why-understand-the-api)](#why-understand-the-api)

[The Object Model [18](#the-object-model)](#the-object-model)

[Repository [19](#repository)](#repository)

[Packages [20](#packages)](#packages)

[Elements [21](#elements)](#elements)

[Connectors [22](#connectors)](#connectors)

[Attribute and Method: Details of Elements
[22](#attribute-and-method-details-of-elements)](#attribute-and-method-details-of-elements)

[Tagged Values [24](#tagged-values)](#tagged-values)

[SQL vs API [24](#sql-vs-api)](#sql-vs-api)

[Update and RefreshModelView
[26](#update-and-refreshmodelview)](#update-and-refreshmodelview)

[The 80/20 Principle in Practice
[26](#the-8020-principle-in-practice)](#the-8020-principle-in-practice)

[Learning Through Patterns
[26](#learning-through-patterns)](#learning-through-patterns)

[Common Pitfalls [26](#common-pitfalls)](#common-pitfalls)

[Looking Ahead [27](#looking-ahead-2)](#looking-ahead-2)

[Chapter 5: Inside EA with JScript
[28](#chapter-5-inside-ea-with-jscript)](#chapter-5-inside-ea-with-jscript)

[The Language Landscape
[28](#the-language-landscape)](#the-language-landscape)

[JavaScript or JScript?
[29](#javascript-or-jscript)](#javascript-or-jscript)

[The Constraints of JScript ES3
[29](#the-constraints-of-jscript-es3)](#the-constraints-of-jscript-es3)

[Scripting Tips [30](#scripting-tips)](#scripting-tips)

[A Progressive Learning Curve
[31](#a-progressive-learning-curve)](#a-progressive-learning-curve)

[Preparing for the Examples
[32](#preparing-for-the-examples-1)](#preparing-for-the-examples-1)

[Looking Ahead [38](#looking-ahead-3)](#looking-ahead-3)

[Chapter 6: External Automation
[39](#chapter-6-external-automation)](#chapter-6-external-automation)

[Why external automation?
[39](#why-external-automation)](#why-external-automation)

[How it works (at a glance)
[39](#how-it-works-at-a-glance)](#how-it-works-at-a-glance)

[Trade-offs [42](#trade-offs)](#trade-offs)

[Where this goes next
[43](#where-this-goes-next)](#where-this-goes-next)

[Chapter 7: Script Design Patterns
[44](#chapter-7-script-design-patterns)](#chapter-7-script-design-patterns)

[Why Patterns Matter [44](#why-patterns-matter)](#why-patterns-matter)

[Examples [46](#examples)](#examples)

[Pattern Handling [57](#pattern-handling)](#pattern-handling)

[Performance & Safety Notes
[59](#performance-safety-notes)](#performance-safety-notes)

[Bonus: Python “Curate → Apply” Pipeline
[60](#bonus-python-curate-apply-pipeline)](#bonus-python-curate-apply-pipeline)

[What to Use When (cheat-sheet)
[60](#what-to-use-when-cheat-sheet)](#what-to-use-when-cheat-sheet)

[Chapter 8: Object Details
[61](#chapter-8-object-details)](#chapter-8-object-details)

[Sparx EA Objects [61](#sparx-ea-objects)](#sparx-ea-objects)

[Summary [67](#summary)](#summary)

[Chapter 9: Imports & Exports
[68](#chapter-9-imports-exports)](#chapter-9-imports-exports)

[Why Imports Matter [68](#why-imports-matter)](#why-imports-matter)

[Why Exports Matter [69](#why-exports-matter)](#why-exports-matter)

[The Round-Trip Challenge
[69](#the-round-trip-challenge)](#the-round-trip-challenge)

[Common Pitfalls [69](#common-pitfalls-1)](#common-pitfalls-1)

[Choosing a Format [70](#choosing-a-format)](#choosing-a-format)

[GUIDs, Keys, and Identity
[70](#guids-keys-and-identity)](#guids-keys-and-identity)

[Curated Imports [71](#curated-imports)](#curated-imports)

[Safety in Exports [71](#safety-in-exports)](#safety-in-exports)

[Integrating Imports/Exports into Workflows
[71](#integrating-importsexports-into-workflows)](#integrating-importsexports-into-workflows)

[What you’ll use [72](#what-youll-use)](#what-youll-use)

[Managing GUIDs & Avoiding Duplicates
[80](#managing-guids-avoiding-duplicates)](#managing-guids-avoiding-duplicates)

[Scaling Up (Performance)
[80](#scaling-up-performance)](#scaling-up-performance)

[Safety Checklist [81](#safety-checklist)](#safety-checklist)

[What to use when [81](#what-to-use-when)](#what-to-use-when)

[Chapter 10: MDG-Aware Scripting
[82](#chapter-10-mdg-aware-scripting)](#chapter-10-mdg-aware-scripting)

[What Are MDGs? [82](#what-are-mdgs)](#what-are-mdgs)

[Why MDGs Matter for Scripting
[83](#why-mdgs-matter-for-scripting)](#why-mdgs-matter-for-scripting)

[Important Tips [83](#important-tips)](#important-tips)

[MDGs in External Automation
[85](#mdgs-in-external-automation)](#mdgs-in-external-automation)

[Safety and Governance
[85](#safety-and-governance)](#safety-and-governance)

[Examples [86](#examples-1)](#examples-1)

[Safety & governance notes
[94](#safety-governance-notes)](#safety-governance-notes)

[What to use when (cheat-sheet)
[94](#what-to-use-when-cheat-sheet-1)](#what-to-use-when-cheat-sheet-1)

[Chapter 11: Governance Scripts
[95](#chapter-11-governance-scripts)](#chapter-11-governance-scripts)

[Why Governance Matters
[95](#why-governance-matters)](#why-governance-matters)

[The Pain of Manual Governance
[96](#the-pain-of-manual-governance)](#the-pain-of-manual-governance)

[Governance and MDGs [98](#governance-and-mdgs)](#governance-and-mdgs)

[Examples [99](#examples-2)](#examples-2)

[Summary [104](#summary-1)](#summary-1)

[Chapter 12: Cookbook of Examples
[105](#chapter-12-cookbook-of-examples)](#chapter-12-cookbook-of-examples)

[The Value of Worked Examples
[105](#the-value-of-worked-examples)](#the-value-of-worked-examples)

[The Scope of the Cookbook
[105](#the-scope-of-the-cookbook)](#the-scope-of-the-cookbook)

[Why Not Just Copy from the Internet?
[106](#why-not-just-copy-from-the-internet)](#why-not-just-copy-from-the-internet)

[Safety First in a Cookbook
[106](#safety-first-in-a-cookbook)](#safety-first-in-a-cookbook)

[Adapting Recipes to Your Context
[107](#adapting-recipes-to-your-context)](#adapting-recipes-to-your-context)

[The Teaching Role of Recipes
[107](#the-teaching-role-of-recipes)](#the-teaching-role-of-recipes)

[Building a Shared Library
[107](#building-a-shared-library)](#building-a-shared-library)

[Cookbook Limitations
[107](#cookbook-limitations)](#cookbook-limitations)

[AI and Cookbook Expansion
[108](#ai-and-cookbook-expansion)](#ai-and-cookbook-expansion)

[Summary [116](#summary-2)](#summary-2)

[Chapter 13: Why AI Helps
[117](#chapter-13-why-ai-helps)](#chapter-13-why-ai-helps)

[Benefits [117](#benefits)](#benefits)

[Using AI Safely [119](#using-ai-safely)](#using-ai-safely)

[AI and Learning [120](#ai-and-learning)](#ai-and-learning)

[AI in Daily Workflow
[120](#ai-in-daily-workflow)](#ai-in-daily-workflow)

[Examples [121](#examples-3)](#examples-3)

[Using AI for Documentation
[122](#using-ai-for-documentation)](#using-ai-for-documentation)

[Best Practices for AI-Assisted Scripting
[123](#best-practices-for-ai-assisted-scripting)](#best-practices-for-ai-assisted-scripting)

[Summary [123](#summary-3)](#summary-3)

[Chapter 14: Prompt Engineering
[124](#chapter-14-prompt-engineering)](#chapter-14-prompt-engineering)

[Why Prompt Engineering Matters
[124](#why-prompt-engineering-matters)](#why-prompt-engineering-matters)

[Prompt Engineering as Team Practice
[127](#prompt-engineering-as-team-practice)](#prompt-engineering-as-team-practice)

[AI Literacy for Modellers
[127](#ai-literacy-for-modellers)](#ai-literacy-for-modellers)

[Prompt Template [127](#prompt-template)](#prompt-template)

[Examples [129](#examples-4)](#examples-4)

[Best Practices for Prompts
[133](#best-practices-for-prompts)](#best-practices-for-prompts)

[Summary [133](#summary-4)](#summary-4)

[Chapter 15: AI Refactoring Partner
[134](#chapter-15-ai-refactoring-partner)](#chapter-15-ai-refactoring-partner)

[Why Refactoring Matters in EA Scripting
[134](#why-refactoring-matters-in-ea-scripting)](#why-refactoring-matters-in-ea-scripting)

[The AI Advantage in Refactoring
[135](#the-ai-advantage-in-refactoring)](#the-ai-advantage-in-refactoring)

[Common Refactoring Needs
[135](#common-refactoring-needs)](#common-refactoring-needs)

[Risks of AI Refactoring
[136](#risks-of-ai-refactoring)](#risks-of-ai-refactoring)

[A Human–AI Workflow for Refactoring
[136](#a-humanai-workflow-for-refactoring)](#a-humanai-workflow-for-refactoring)

[AI for Documentation Retrofitting
[136](#ai-for-documentation-retrofitting)](#ai-for-documentation-retrofitting)

[Refactoring for Governance
[137](#refactoring-for-governance)](#refactoring-for-governance)

[Beyond EA: Refactoring Across Languages
[137](#beyond-ea-refactoring-across-languages)](#beyond-ea-refactoring-across-languages)

[The Cultural Impact of Refactoring with AI
[137](#the-cultural-impact-of-refactoring-with-ai)](#the-cultural-impact-of-refactoring-with-ai)

[Examples [138](#examples-5)](#examples-5)

[Summary [141](#summary-5)](#summary-5)

[Chapter 16: AI in Daily Workflow
[143](#chapter-16-ai-in-daily-workflow)](#chapter-16-ai-in-daily-workflow)

[From Occasional Help to Daily Companion
[143](#from-occasional-help-to-daily-companion)](#from-occasional-help-to-daily-companion)

[The Role of a Prompt Library
[144](#the-role-of-a-prompt-library)](#the-role-of-a-prompt-library)

[Automating Boilerplate
[144](#automating-boilerplate)](#automating-boilerplate)

[AI as a Debugging Partner
[144](#ai-as-a-debugging-partner)](#ai-as-a-debugging-partner)

[Integration with Version Control
[145](#integration-with-version-control)](#integration-with-version-control)

[Governance and Reporting
[145](#governance-and-reporting)](#governance-and-reporting)

[Risks of Daily AI Use
[145](#risks-of-daily-ai-use)](#risks-of-daily-ai-use)

[AI as a Team Enabler
[146](#ai-as-a-team-enabler)](#ai-as-a-team-enabler)

[Git + AI Workflow [148](#git-ai-workflow)](#git-ai-workflow)

[AI-Assisted Governance Check
[148](#ai-assisted-governance-check)](#ai-assisted-governance-check)

[Summary [149](#summary-6)](#summary-6)

[Chapter 17: Performance & Scaling
[150](#chapter-17-performance-scaling)](#chapter-17-performance-scaling)

[Why Performance Matters
[150](#why-performance-matters)](#why-performance-matters)

[Sources of Slowness [150](#sources-of-slowness)](#sources-of-slowness)

[Measure First [151](#measure-first)](#measure-first)

[Tips [151](#tips)](#tips)

[Principles [152](#principles)](#principles)

[Examples [154](#examples-6)](#examples-6)

[Dos & Don’ts (cheat-sheet)
[161](#dos-donts-cheat-sheet)](#dos-donts-cheat-sheet)

[Putting It Together [162](#putting-it-together)](#putting-it-together)

[Chapter 18: Integrating with Workflows
[163](#chapter-18-integrating-with-workflows)](#chapter-18-integrating-with-workflows)

[Why Integration Matters
[163](#why-integration-matters)](#why-integration-matters)

[The Role of Automation in Integration
[163](#the-role-of-automation-in-integration)](#the-role-of-automation-in-integration)

[Common Integration Targets
[164](#common-integration-targets)](#common-integration-targets)

[Integration Approaches
[164](#integration-approaches)](#integration-approaches)

[The Cultural Dimension of Integration
[166](#the-cultural-dimension-of-integration)](#the-cultural-dimension-of-integration)

[Risks of Integration
[166](#risks-of-integration)](#risks-of-integration)

[Examples [167](#examples-7)](#examples-7)

[Notes [169](#notes)](#notes)

[Secrets, auth & bitness (read this!)
[174](#secrets-auth-bitness-read-this)](#secrets-auth-bitness-read-this)

[Putting it together (one realistic flow)
[174](#putting-it-together-one-realistic-flow)](#putting-it-together-one-realistic-flow)

[Troubleshooting quick wins
[175](#troubleshooting-quick-wins)](#troubleshooting-quick-wins)

[Checklist (cheat-sheet)
[175](#checklist-cheat-sheet)](#checklist-cheat-sheet)

[Chapter 19: Add-ins vs Scripts
[176](#chapter-19-add-ins-vs-scripts)](#chapter-19-add-ins-vs-scripts)

[Scripts as the First Line of Automation
[176](#scripts-as-the-first-line-of-automation)](#scripts-as-the-first-line-of-automation)

[Add-ins as Compiled Extensions
[177](#add-ins-as-compiled-extensions)](#add-ins-as-compiled-extensions)

[Why Move from Script to Add-in?
[177](#why-move-from-script-to-add-in)](#why-move-from-script-to-add-in)

[Trade-offs [177](#trade-offs-1)](#trade-offs-1)

[Add-ins and Governance
[178](#add-ins-and-governance)](#add-ins-and-governance)

[The Learning Curve [178](#the-learning-curve)](#the-learning-curve)

[A Progressive Path [179](#a-progressive-path)](#a-progressive-path)

[Cultural Impact [179](#cultural-impact)](#cultural-impact)

[Risks of Add-ins [179](#risks-of-add-ins)](#risks-of-add-ins)

[Example [179](#example)](#example)

[When to Migrate Script → Add-in
[181](#when-to-migrate-script-add-in)](#when-to-migrate-script-add-in)

[Migration Example [181](#migration-example)](#migration-example)

[Summary [181](#summary-7)](#summary-7)

[Chapter 20: Troubleshooting
[183](#chapter-20-troubleshooting)](#chapter-20-troubleshooting)

[Why Troubleshooting Matters
[183](#why-troubleshooting-matters)](#why-troubleshooting-matters)

[The Nature of EA’s Quirks
[183](#the-nature-of-eas-quirks)](#the-nature-of-eas-quirks)

[The Usual Suspects [184](#the-usual-suspects)](#the-usual-suspects)

[The Value of Defensive Patterns
[185](#the-value-of-defensive-patterns)](#the-value-of-defensive-patterns)

[Troubleshooting as a Team Resource
[186](#troubleshooting-as-a-team-resource)](#troubleshooting-as-a-team-resource)

[Safe Patterns Recap [189](#safe-patterns-recap)](#safe-patterns-recap)

[Chapter 21: Reference
[191](#chapter-21-reference)](#chapter-21-reference)

[EA Object Model Map (Condensed)
[191](#ea-object-model-map-condensed)](#ea-object-model-map-condensed)

[SQL Cheat-Sheet (Read-only)
[192](#sql-cheat-sheet-read-only)](#sql-cheat-sheet-read-only)

[Standard Script Header Template
[193](#standard-script-header-template)](#standard-script-header-template)

[Logging Helper Snippet
[193](#logging-helper-snippet)](#logging-helper-snippet)

[Common ObjectType Values
[194](#common-objecttype-values)](#common-objecttype-values)

[Common Errors Quick Table
[194](#common-errors-quick-table)](#common-errors-quick-table)

[Quick Reuse Snippets
[196](#quick-reuse-snippets)](#quick-reuse-snippets)

[Summary [196](#summary-8)](#summary-8)

[Appendix A: Scripting Constraints
[198](#appendix-a-scripting-constraints)](#appendix-a-scripting-constraints)

[A.1 Language Constraints
[198](#a.1-language-constraints)](#a.1-language-constraints)

[A.2 Object Handling [198](#a.2-object-handling)](#a.2-object-handling)

[A.3 File I/O [198](#a.3-file-io)](#a.3-file-io)

[A.4 Safety Rules [198](#a.4-safety-rules)](#a.4-safety-rules)

[Appendix B: External Automation
[199](#appendix-b-external-automation)](#appendix-b-external-automation)

[B.1 Attaching Externally
[199](#b.1-attaching-externally)](#b.1-attaching-externally)

[B.2 When to Go External
[199](#b.2-when-to-go-external)](#b.2-when-to-go-external)

[B.3 Bitness [199](#b.3-bitness)](#b.3-bitness)

[B.4 Add-ins [199](#b.4-add-ins)](#b.4-add-ins)

[Appendix C: Glossary of Terms
[200](#appendix-c-glossary-of-terms)](#appendix-c-glossary-of-terms)

[Appendix D: Quick Reference
[202](#appendix-d-quick-reference)](#appendix-d-quick-reference)

[Appendix E: External Automation Setup
[203](#appendix-e-external-automation-setup)](#appendix-e-external-automation-setup)

[E.1 Purpose [203](#e.1-purpose)](#e.1-purpose)

[E.2 Usage [203](#e.2-usage)](#e.2-usage)

[E.3 The EAConnect Helper Class
[204](#e.3-the-eaconnect-helper-class)](#e.3-the-eaconnect-helper-class)

[E.4 Configuration & Setup
[208](#e.4-configuration-setup)](#e.4-configuration-setup)

# Chapter 1: Why Script EA?

Enterprise Architect is a powerful modelling environment out of the box.
You can draw diagrams, generate documentation, and configure Model
Driven Generation (MDG) technologies without touching a single line of
code. So why would anyone want to add scripting on top?

The answer is the same in modelling as it is in software engineering:
**automation saves time, reduces errors, and enforces consistency**.
Every modeller has encountered repetitive or fiddly tasks that drag
attention away from design thinking. With scripting, you can let the
tool do the heavy lifting.

## Benefits of Automation in Modelling

Scripting opens up the underlying API of EA. That API gives you
programmatic access to repositories, packages, elements, connectors,
attributes, tagged values, and diagrams. With it you can:

- **Eliminate repetition.** Instead of manually renaming hundreds of
  elements, you can script a simple loop that applies a naming rule
  across the entire model.

- **Standardise quality.** Governance checks, linting rules, and model
  “smell” detection can run in seconds rather than hours of manual
  review.

- **Accelerate integration.** Exports to CSV, JSON, or XML can be
  automated. You can generate reports in custom formats, or sync model
  content with Jira, Confluence, or Git.

- **Boost productivity.** What once took hours of manual clicking can be
  done in minutes — freeing modellers to focus on architecture, not
  administration.

Automation is not about doing something new, but about doing the same
things faster, more reliably, and at greater scale.

## Typical Use Cases

Some of the most common applications of EA scripting include:

- **Bulk editing.** Update tagged values, stereotypes, or connector
  types across entire packages.

- **Model hygiene.** Detect and fix duplicates, missing names, or
  invalid references.

- **Data imports.** Read CSV or Excel files and convert them into EA
  elements automatically.

- **Round-tripping.** Export a model to JSON or Excel, allow external
  review, and then re-import changes.

- **Governance and QA.** Apply rules such as “all classes must have
  documentation” or “all business processes must trace to capabilities.”

- **Integration.** Connect EA to external tools — e.g. push backlog
  items into Jira, or register metadata in a catalogue.

Each of these tasks is achievable through EA’s menus, but scripting
transforms them from *manual chores* into *repeatable processes*.

## When Not to Script

Not everything benefits from automation. EA already has built-in
features that solve common problems. Before reaching for the scripting
console, ask:

- **Is there a native feature?** Diagram filters, search definitions,
  model validation, and MDG profiles often cover the same ground.

- **Is the effort justified?** Writing, testing, and maintaining scripts
  takes time. A one-off change to five elements is faster by hand.

- **Could it cause damage?** Poorly written scripts can corrupt a model
  — deleting content, overwriting GUIDs, or applying unintended changes
  at scale.

The golden rule: script only when the benefit outweighs the risk and
effort.

## Why Scripting Matters for Governance

Beyond productivity, scripting is one of the strongest tools for
governance. A script does not forget the rules. It applies the same
checks the same way every time. That makes it a reliable companion in
quality assurance, regulatory compliance, or enterprise standards
adoption.

For example, a governance script can enforce naming conventions or
ensure that all system components are linked to business capabilities.
This kind of automation embeds policy into practice — turning guidelines
into enforceable, repeatable checks.

## Your First “Hello EA” Script

Before diving into the technicalities of scripting languages and APIs in
Chapter 2, it is worth seeing what a minimal script looks like. The
following example is deliberately simple: it retrieves the package
currently selected in the Project Browser and lists all the elements it
contains.

//
----------------------------------------------------------------------------------------

// Example 1.1 – HelloEA

// Purpose: Output the names of all elements in the selected package

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var package = Repository.GetTreeSelectedPackage();

if (!package) {

Session.Prompt("Please select a package in the Project Browser.",
promptOK);

return;

}

var elements = package.Elements;

for (var i = 0; i \< elements.Count; i++) {

var element = elements.GetAt(i);

Session.Output("Element: " + element.Name);

}

}

main();

Run this script from the *Scripts* window after selecting a package in
the Project Browser. The output window will list the names of each
element in that package. It may not look impressive, but this is the
scripting equivalent of “Hello World.” It proves the loop works, the API
responds, and you are in control.

This tiny fragment also illustrates some key rules that will come up
repeatedly in later chapters:

- EA collections (like package.Elements) are not arrays, so you use
  .Count and .GetAt(i).

- Update() is required after any change to persist modifications.

- Session.Output() is your friend when debugging.

With this in place, you have taken the first step from *manual modeller*
to *toolsmith* — someone who bends the tool to fit the workflow, rather
than the other way round.

## Safe Practice: The Dry Run Principle

Throughout this handbook, you will notice a recurring pattern: every
modifying script begins with a line like var DRY_RUN = true;. This is
not cosmetic. It is the single most important safety feature in EA
scripting. A dry run means the script logs what it *would do*, but does
not commit changes. Only once the log looks correct do you flip DRY_RUN
= false and let the script update the repository.

This principle is vital because EA does not have a transaction rollback.
Once you delete, it is gone. Once you rename, it sticks. Scripts without
dry-run mode are dangerous. Scripts with dry-run mode are tools of
governance.

## A Different Way of Modelling

Scripting changes the way you think about modelling. Instead of asking
*“what diagram should I draw?”* you begin to ask *“what structure should
I generate?”*. You start to see the repository as data, not just
pictures. A model becomes a dataset: a structured set of packages,
elements, and relationships. Scripting makes it possible to treat
modelling as **data curation**: build, transform, export, integrate.

This shift is liberating. It allows architects to keep models aligned
with fast-moving environments, to connect architecture with delivery
tools, and to maintain integrity at scale.

## Preparing for the Examples

The rest of this chapter (and indeed this book) is practical. We will
show code snippets that run inside EA, fully commented so you understand
every line. They start simple (“Hello World”), then build into patterns
for traversal, creation, updating, deleting, and exporting.

Before diving into the examples, remember the key lessons of this
introduction:

1.  Script when scale, consistency, integration, or governance require
    it.

2.  Don’t script when EA has a built-in feature that meets your need.

3.  Always script safely: dry-run, backup, and log.

4.  Treat the model as a dataset, not just diagrams.

With these principles, you are ready to move from being a modeller who
only draws diagrams to an architect who **shapes models
programmatically**.

## Looking Ahead

This chapter has introduced the “why” of scripting, and given you a
working starter example. The chapters that follow explain the “how.” We
will explore the scripting engines available in EA, the core API, and
the safe patterns you should follow to avoid breaking your model. Later
parts of this book will offer a cookbook of practical examples, patterns
for common tasks, and even ways of using AI assistants to accelerate
script development.

By the end, you should have the confidence to create scripts that save
time, improve quality, and make Enterprise Architect work for you, not
the other way around.

# Chapter 2: Automation Landscape

Before you can write useful scripts, you need to understand the
landscape. Enterprise Architect gives you several ways to automate its
behaviour, both from within the tool and from the outside. Each option
comes with strengths and limitations. Choosing the right one depends on
your goals, your tolerance for risk, and the skills of your team.

## Built-In Script Engine

Enterprise Architect includes a scripting window where you can create,
edit, and run scripts directly inside the repository. These scripts are
stored with the model and organised into groups. They can be invoked
from menus or context menus, which makes them perfect for quick
automation tasks or shared governance checks.

The scripting window offers three “languages”: **VBScript, JScript, and
JavaScript**. At first glance this looks like a generous choice. In
practice, all three map back to Microsoft’s legacy scripting engines —
which means you are working with very old language runtimes.

## Scripting options

When creating a script in EA you are prompted to select one of the
following:

**VBScript**

- Microsoft Visual Basic Scripting Edition.

- Looks and feels like writing macros in Excel or classic Visual Basic.

- Verbose but accessible to non-developers.

- Still supported inside EA, but deprecated by Microsoft in Windows.

- Weak library support; relies heavily on the EA API and ActiveX.

**JScript**

- Microsoft’s implementation of **ECMAScript 3 (1999)**.

- Very similar to early JavaScript, but locked at that level.

- No modern JavaScript features: no let, const, arrow functions, JSON
  libraries, or array helpers such as map or filter.

- Requires “old school” loops and helper functions for common tasks.

- This is EA’s most commonly used internal scripting option.

**JavaScript** (as labelled in EA)

- Misleading. Selecting “JavaScript” in EA simply invokes the same
  JScript engine.

- No ES5/ES6+ features, despite the familiar name.

- Treat “JavaScript” and “JScript” as identical inside EA.

**In short:** inside EA you are working with either VBScript or JScript
(ES3). If you want modern features, you need to step outside.

## External Automation

You are not limited to the internal scripting engine. EA exposes its
entire object model through a **COM interface**. Any COM-aware language
can connect and manipulate the repository. This makes it possible to use
modern languages with modern tooling.

Typical external options include:

- **C#** (the richest support, with type libraries).

- **Python** via pywin32.

- **PowerShell, Perl, Java**, and others via COM bridges.

External automation runs outside EA and does not live in the repository.
It is well-suited to integration with CI/CD pipelines, registries, Jira,
Confluence, or analytics platforms.

## “Hello EA” Examples

The following examples illustrate the same simple task: list the names
of all elements in the package currently selected in the Project
Browser. Seeing the same logic in three languages highlights their
differences.

**VBScript** (inside EA)

' -------------------------------------------------------

' Example 2.1 - HelloEA in VBScript

' Purpose: Output the names of all elements in the

' selected package in the Project Browser.

' -------------------------------------------------------

!INC Local Scripts.EAConstants-VBScript

sub main()

' Get the selected package

dim package

set package = Repository.GetTreeSelectedPackage()

if package is nothing then

Session.Prompt "Please select a package in the Project Browser.",
promptOK

exit sub

end if

' Get the collection of elements in the package

dim elements

set elements = package.Elements

' Loop through the collection

dim i

for i = 0 to elements.Count - 1

dim element

set element = elements.GetAt(i) ' EA collections use GetAt()

Session.Output "Element: " & element.Name

next

end sub

main

**JScript** (inside EA)

// -------------------------------------------------------

// Example 2.2 - HelloEA in JScript

// Purpose: Output the names of all elements in the

// selected package in the Project Browser.

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

// Get the selected package

var package = Repository.GetTreeSelectedPackage();

if (!package) {

Session.Prompt("Please select a package in the Project Browser.",
promptOK);

return;

}

// Get the collection of elements in the package

var elements = package.Elements;

// Loop through the collection

for (var i = 0; i \< elements.Count; i++) {

var element = elements.GetAt(i); // EA collections are not arrays

Session.Output("Element: " + element.Name);

}

}

main();

**Python** (external via pywin32)

\# -------------------------------------------------------

\# Example 2.3 - HelloEA in Python

\# Purpose: Output the names of all elements in the

\# selected package in the Project Browser.

\# Notes:

\# - Requires EA to be running.

\# - Requires pywin32 package installed.

\# -------------------------------------------------------

import win32com.client

\# Connect to the running EA instance

ea = win32com.client.Dispatch("EA.App")

repository = ea.Repository

\# Get the currently selected package

package = repository.GetTreeSelectedPackage()

if not package:

print("Please select a package in the Project Browser.")

exit(0)

\# Get the collection of elements in the package

elements = package.Elements

\# Loop through the collection

for i in range(elements.Count):

element = elements.GetAt(i) \# EA collections expose GetAt()

print("Element:", element.Name)

## Comparing the Three

- **VBScript** feels like a 1990s macro language. Clear for beginners
  but verbose.

- **JScript** is terser, familiar to anyone with Java/C-style
  backgrounds, but limited to ES3 features.

- **Python** is modern, expressive, and integrates with rich libraries —
  but requires external automation and setup.

## The Role of COM

At the heart of both external automation and add-ins is **COM**
(Component Object Model). EA exposes its Repository object through COM.
This is what allows C#, Python, or Java to talk to EA.

COM is old, and sometimes brittle, but it is also the glue that allows
EA to integrate with the wider world. The Interop.EA.dll assembly is the
.NET wrapper over this COM interface. For Python, pywin32 plays the same
role. For Java, jacob or similar libraries provide bindings.

Understanding COM isn’t strictly necessary to write scripts, but it
explains why **bitness matters** (32-bit EA requires 32-bit Python), why
**registration matters** (DLLs must be registered), and why debugging
sometimes feels awkward.

## Choosing the Right Tool

A simple selection matrix helps:

- Quick fixes and governance checks inside EA → JScript.

- For teams with strong Visual Basic heritage → VBScript.

- For data-heavy tasks, JSON, or integration pipelines → external
  automation (Python or C#).

- For stable, long-lived features → migrate scripts into Add-ins.

## Safety in Each Layer

Each automation option carries its own risks:

- **Internal scripts**: no undo, dangerous if dry-run is not used.

- **External automation**: risk of version mismatch (32/64-bit), risk of
  corrupting repos if SQL writes are used incorrectly.

- **Add-ins**: risk of startup errors breaking EA menus; heavier
  debugging burden.

The best safety net in all cases is to **test on a dummy repository
first**, use **dry-run patterns**, and maintain **version control** for
your scripts or add-ins.

## Shaping Automation Practice

For many organisations, the EA automation landscape evolves in phases:

1.  **Exploration** — a modeller writes small scripts to rename things
    or export CSV.

2.  **Consolidation** — a team shares scripts across repositories, with
    common helpers.

3.  **Integration** — external automation ties EA to Jira, Confluence,
    Git.

4.  **Productisation** — stable solutions become add-ins with menus and
    event handlers.

Knowing where you are in this journey helps you decide which option to
invest in.

Preparing for the Examples

The rest of this chapter will show practical code samples for each
automation mode: internal scripts in JScript, external COM automation in
C# and Python, and a glimpse of add-in structure. These examples are
fully commented, showing how to set up, how to log safely, and how to
use dry-run modes.

Before diving into the code, remember:

1.  **Internal scripts** are your first tool.

2.  **External automation** connects EA to the wider enterprise.

3.  **Add-ins** formalise solutions into products.

This layered landscape is what makes EA unusually flexible: it can serve
a single modeller working on a small project, or an enterprise team
building integrations across systems.

## Looking Ahead

The next chapter dives into **EA API Essentials**. We will explore the
80/20 of the object model: Repository, Package, Element, Connector,
Attribute, and TaggedValue. We will also see why methods like Update()
and RefreshModelView() are so critical. With this foundation, you will
be ready to write scripts that safely and effectively manipulate your
models.

# Chapter 3: Getting Started 

Every technical journey begins with first steps, and scripting
Enterprise Architect is no exception. After seeing the big picture of
why scripting matters (Chapter 1) and the landscape of options available
(Chapter 2), it is tempting to jump straight into code. But before you
do, there is one critical lesson: **safety first**.

Scripting in EA is not like writing macros in a spreadsheet where you
can undo or close without saving. The EA repository is a live database.
Every script you run has the power to add, modify, or delete hundreds or
thousands of elements in a matter of seconds. There is no “undo” button
for automation. That is why this chapter is dedicated to getting started
safely. We will cover the principles and practices that protect your
repository, minimise risk, and give you confidence when you begin
experimenting with automation.

## The Importance of Backups

The very first safeguard is **backups**. EA repositories come in
different forms: .qea files, .eapx files, or database connections to SQL
Server, Oracle, or PostgreSQL. Regardless of the backend, before you run
any script that modifies content, take a backup.

For file-based repositories, this can be as simple as copying the file
to another folder. For server-based repositories, use database backup
routines or export a snapshot to XMI. The principle is the same: always
have a way back. If your script misbehaves and wipes out a branch of the
model, you need the comfort of knowing you can restore it.

Experienced script authors often keep a **sandbox repository**: a copy
of the model used only for testing scripts. This lets you experiment
freely without fear of damaging the production model. Once your script
behaves as expected, you can run it against the real repository.

## The Dry-Run Principle

Perhaps the single most important safeguard in scripting is the
**dry-run flag**. Every modifying script in this book includes a line
near the top:

var DRY_RUN = true;

When DRY_RUN is true, the script logs what it *would* do, but does not
commit any changes. Only when you flip it to false will the script
actually update the repository. This gives you a rehearsal phase: you
see what names would be changed, what tags would be added, what elements
would be deleted.

This principle of simulation before execution is vital. It is your
safety net. Many a modeller has regretted running a bulk update script
without such a safeguard. By adopting dry-run as a discipline, you make
your scripts trustworthy not only for yourself but also for colleagues
who may reuse them.

## Logging and Transparency

Logging is your second line of defence. A script that silently modifies
hundreds of elements without telling you what it did is dangerous. A
safe script always logs its actions, either to EA’s Output tab, to a CSV
file, or both.

Logging serves three purposes:

1.  **Feedback** — you see what the script is doing in real time.

2.  **Audit** — you can review afterwards which elements were touched.

3.  **Debugging** — if something goes wrong, logs help you trace the
    problem.

Good practice is to log to CSV, with columns such as ElementID, Name,
OldValue, NewValue, Action. That way you can filter and analyse in Excel
or share the log with others.

## Understanding the Repository Structure

Before you can script safely, you must understand the structure you are
scripting against. EA is more than diagrams. At the top is the
**Repository** object. Inside are **Models** (also known as root
packages). Each model contains **Packages**, and packages contain
**Elements** and **Diagrams**.

Think of it as a tree:

> **Repository**
>
> **├─ Model (root package)**
>
> **│ ├─ Package**
>
> **│ │ ├─ Elements**
>
> **│ │ ├─ Diagrams**
>
> **│ │ └─ Sub-packages**
>
> **│ └─ Package**
>
> **└─ Other models**

At the element level, you have properties (name, type, status) and
collections (attributes, methods, connectors, tagged values). Connectors
link elements together. Diagrams show visual instances of elements.

Understanding this hierarchy is essential because every script you write
will involve traversing these structures. A safe script is one that
navigates correctly: it knows when it is handling a package versus an
element, and it never assumes without checking ObjectType.

## Update and Refresh

Another foundational safety concept is the difference between
**Update()** and **RefreshModelView()**.

- **Update()** commits your change to the repository. Without it, the
  change is lost.

- **RefreshModelView()** tells EA’s user interface to reload content.
  Without it, the change may be invisible until you close and reopen EA.

Many beginners forget one or the other. Forgetting Update() means the
script appears to work but nothing actually changes. Forgetting
RefreshModelView() means the script did work but you can’t see the
result.

The safe pattern is:

1.  Modify the object.

2.  Call .Update().

3.  At the end of the script (or per batch), call
    Repository.RefreshModelView().

## Avoiding Dangerous Patterns

Certain scripting mistakes are particularly hazardous:

- **Forward deletion loops**: deleting items in a forward loop causes
  index shifts, skipping items. Always delete backwards.

- **Assuming selection type**: don’t assume the user has selected a
  package; they may have selected a diagram or element. Always check
  ObjectType.

- **Using names as keys**: element names are not unique. Use GUIDs or
  IDs for identification.

- **Direct SQL writes**: avoid Repository.Execute("UPDATE…"). This
  bypasses EA’s business rules and can corrupt the repository. Use SQL
  only for *reading* (SQLQuery), never for writing.

## Testing on Small Sets

Before applying a script to thousands of elements, test it on a small
package with a handful of items. This lets you confirm behaviour without
risking widespread impact. A safe workflow is:

1.  Copy a few elements into a test package.

2.  Run the script with DRY_RUN = true.

3.  Check the log output.

4.  Switch to DRY_RUN = false and run.

5.  Verify the changes.

6.  Only then apply to the full repository.

## Cultural Safety

Safety is not just technical; it is cultural. Teams should adopt norms:

- Never run destructive scripts in production without dry-run first.

- Always share logs of what was changed.

- Keep a shared script library under version control (Git).

- Review scripts with peers before first run.

These norms build trust. Architects and modellers become more willing to
use automation when they know safeguards are built in.

## Building the Right Habits

The purpose of this chapter is not to scare you, but to build the right
habits from the start. If you learn to always include a dry-run flag,
always log, always test on small sets, and always backup, then scripting
EA becomes an empowering tool rather than a risky gamble.

Think of it like climbing: the harness, helmet, and rope may feel
restrictive at first, but they enable you to climb higher with
confidence. In the same way, scripting safety patterns may feel like
overhead at first, but they let you automate more ambitious tasks
without fear.

# Chapter 4: API Essentials

Enterprise Architect is first and foremost a modelling tool. But beneath
its diagrams, toolboxes, and properties windows lies a structured
**object model** — a formal API (Application Programming Interface) that
represents everything you see in the repository. Packages, elements,
connectors, diagrams, attributes, tagged values: all are exposed as
objects with properties and methods.

The EA Automation API can feel intimidating at first. It includes dozens
of classes, hundreds of properties, and subtle rules about when you must
call Update() or RefreshModelView(). But in practice, you do not need
the whole surface of the API to be productive. In fact, like many large
systems, EA’s object model follows the **80/20 rule**: about 20% of the
classes and methods cover 80% of what you will ever need.

This chapter focuses on that 20%. It introduces the core objects —
Repository, Package, Element, Connector, Attribute, and TaggedValue —
and explains their roles in the automation model. It also explains how
to navigate between them, when to use the object API and when to use
SQL, and the importance of persisting changes. By the end of this
introduction, you will understand the “grammar” of the EA API, which
will make the worked examples far easier to follow.

## Why Understand the API?

It might seem obvious: if you are going to script EA, you need to know
the API. But there is a deeper point. Many beginners approach scripting
by copying and pasting snippets without understanding what is happening.
This can work for small tasks, but it is risky at scale. Without a
mental model of the API, you may accidentally treat an EA collection
like a JavaScript array, or forget to call Update(), or misinterpret a
connector direction.

Understanding the API means you can reason about scripts. You can
predict what a script will do, debug why something didn’t work, and
design new scripts with confidence. It is the difference between
following recipes and actually knowing how to cook.

## The Object Model

The EA API follows the structure of the tool itself:

1.  **Repository** — the root object, representing the entire open
    model.

2.  **Package** — a container for elements, diagrams, and sub-packages.

3.  **Element** — a UML element (class, component, use case, capability,
    etc.).

4.  **Connector** — a relationship between elements (association,
    dependency, trace, etc.).

5.  **Attribute / Operation** — members inside an element.

6.  **TaggedValue** — metadata attached to an element or connector.

Almost every script you write will start with the **Repository** object
and work downwards.

## Repository

Everything begins with the **Repository** object. This represents the
currently open EA project — whether it is a .qea file, a database, or a
shared repository. From Repository, you can access root models
(Repository.Models), query by SQL (Repository.SQLQuery), retrieve
selected objects (GetTreeSelectedPackage, GetTreeSelectedObject), or
refresh the UI (RefreshModelView).

Think of the Repository as your **gateway**. You cannot script without
it, because it is the only object that is always available.

The Repository object is provided automatically when running a script
inside EA. It represents the current model. From it you can query
packages, elements, and diagrams, or run SQL directly.

**Example**: Output the model’s name

// -------------------------------------------------------

// Example 4.1 – Output repository name

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

// The Repository object is available by default

var modelName = Repository.ConnectionString;

Session.Output("Connected to: " + modelName);

}

main();

Repository.ConnectionString tells you the path or database connection
for the open model.

Use Session.Output instead of console.log — EA doesn’t know what a
console is.

## Packages

The next level down is the **Package**. Packages are containers. They
hold elements, diagrams, and child packages. Traversing the model
usually means starting at a package and working your way down through
its sub-packages and elements.

A key safety note: don’t assume a user has selected a package. Always
check the object type. If you write a script that expects a package but
gets a diagram, you will get confusing errors.

**Example**: Traverse packages and list names

// -------------------------------------------------------

// Example 4.2 – Traverse top-level packages

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var models = Repository.Models; // Collection of root packages

for (var i = 0; i \< models.Count; i++) {

var model = models.GetAt(i);

Session.Output("Root package: " + model.Name);

}

}

main();

Key notes:

- EA collections use .Count and .GetAt(i).

- Root packages are accessed through Repository.Models.

## Elements

The **Element** is the heart of the EA API. Every class, requirement,
actor, capability, or component is an Element. Elements have properties
(Name, Type, Notes, Status), collections (Attributes, Methods,
Connectors, TaggedValues), and behaviours (scenarios, responsibilities).

If you learn to script elements, you unlock most of EA’s power. The most
common tasks involve creating elements, updating their properties, and
traversing their relationships.

**Example**: List elements in a selected package

// -------------------------------------------------------

// Example 4.3 – List all elements in selected package

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var package = Repository.GetTreeSelectedPackage();

if (!package) {

Session.Prompt("Please select a package in the Project Browser.",
promptOK);

return;

}

var elements = package.Elements;

for (var i = 0; i \< elements.Count; i++) {

var element = elements.GetAt(i);

Session.Output("Element: " + element.Name + " (Type: " + element.Type +
")");

}

}

main();

Notes:

- Always check for null — if nothing is selected,
  GetTreeSelectedPackage() returns null.

- element.Type returns the UML type (e.g. Class, Requirement, Activity).

## Connectors

Architecture is about relationships. In EA, those are represented by
**Connectors**. An element’s Connectors collection lists all
relationships where that element is either client or supplier. A
connector has a Type (“Association,” “Dependency,” “Realisation”), plus
source and target IDs.

A common beginner’s mistake is to assume connectors are directional in a
UML sense. In practice, EA stores them with ClientID and SupplierID, and
the interpretation depends on connector type. Scripts must take care to
assign the correct ends.

**Example**: Show connectors from an element

// -------------------------------------------------------

// Example 4.4 – Show connectors from a selected element

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var element as EA.Element;

element = Repository.GetTreeSelectedObject();

if (!element \|\| element.ObjectType != otElement) {

Session.Prompt("Please select an element in the Project Browser.",
promptOK);

return;

}

var connectors = element.Connectors;

for (var i = 0; i \< connectors.Count; i++) {

var conn = connectors.GetAt(i);

Session.Output("Connector: " + conn.Type +

" from " + conn.ClientID +

" to " + conn.SupplierID);

}

}

main();

Notes:

- Connectors is a collection of relationships.

- ClientID and SupplierID are IDs of the connected elements. You can
  resolve them with Repository.GetElementByID().

## Attribute and Method: Details of Elements

Attributes and methods live inside elements. They are relevant mostly
for data models and software design. If you are modelling business
capabilities or processes, you may never touch them. But for class
modelling, they are essential. The API treats them like small objects
with Name, Type, Notes, and collections of tagged values.

// -------------------------------------------------------

// Example 4.5 – Add Attribute and Method

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var el = Repository.GetTreeSelectedObject();

if (el.ObjectType != otElement \|\| el.Type != "Class") {

Session.Prompt("Select a Class element first.", promptOK);

return;

}

// List existing attributes and methods

for (var i = 0; i \< el.Attributes.Count; i++)

Session.Output("Attribute: " + el.Attributes.GetAt(i).Name);

for (var j = 0; j \< el.Methods.Count; j++)

Session.Output("Method: " + el.Methods.GetAt(j).Name + "()");

// Add one of each

el.Attributes.AddNew("exampleAttr", "String").Update();

el.Methods.AddNew("exampleMethod", "").Update();

el.Update();

Repository.RefreshModelView(el.PackageID);

Session.Output("Added exampleAttr and exampleMethod.");

}

main();

## Tagged Values

Perhaps the most important part of the API for governance is **Tagged
Values**. Tagged values let you attach metadata to elements, connectors,
attributes, and more. They are the bridge between generic modelling and
your organisation’s specific needs. For example, you can tag every
application with “Owner” or every requirement with “Source System.”

In scripts, tagged values are indispensable. They let you propagate
metadata, check for compliance, and integrate with external registries.

**Example**: Read and update tagged values

// -------------------------------------------------------

// Example 4.6 – Read and update tagged values

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var element = Repository.GetTreeSelectedObject();

if (!element \|\| element.ObjectType != otElement) {

Session.Prompt("Please select an element.", promptOK);

return;

}

var tags = element.TaggedValues;

for (var i = 0; i \< tags.Count; i++) {

var tag = tags.GetAt(i);

Session.Output("Tag: " + tag.Name + " = " + tag.Value);

}

// Add or update a tagged value

var newTag = element.TaggedValues.AddNew("Status", "Draft");

newTag.Update();

// Remember to call Update() on the element itself

element.Update();

Session.Output("Tagged value added/updated.");

}

main();

Key rules:

- Tagged values are stored as a collection on the element.

- After modifying, call Update() to persist.

- Always refresh the model view if you want changes to show immediately.

## SQL vs API

EA exposes its data model both as an **object API** and as a **database
schema**. You can query directly with Repository.SQLQuery(sql), which
returns XML. This is often faster for reads, especially when you need
thousands of rows. But you should never write to the database directly.
The object API enforces rules, cascades updates, and ensures integrity.

The safe pattern is: **SQL for read, API for write**. Query with SQL,
act with API.

// -------------------------------------------------------

// Example 4.6 – Use SQLQuery for performance

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

// Simple SQL query – always returns XML

var result = Repository.SQLQuery("SELECT Name FROM t_object WHERE
Object_Type='Class'");

Session.Output("Result XML: " + result);

}

main();

- SQL queries return XML, not rows. You must parse the XML manually.

- SQL is much faster for bulk queries but dangerous if you don’t
  understand EA’s schema.

## Update and RefreshModelView

If there is one golden rule in the EA API, it is this: **nothing changes
until you call Update()**. Setting element.Name = "X" does nothing
unless you follow with element.Update(). Forget this, and you will
wonder why your script “didn’t work.”

The second golden rule is: **the UI doesn’t refresh automatically**.
After bulk changes, call Repository.RefreshModelView() to force the
Project Browser to update. Without it, changes may exist in the database
but remain invisible until EA is restarted.

## The 80/20 Principle in Practice

Although EA has many more objects — Diagrams, DiagramObjects, Scenarios,
Issues, Tests — most automation tasks use the same handful: Repository,
Package, Element, Connector, Attribute, TaggedValue. Master these, and
you can already do 80% of practical scripting.

The rest of the API is there for advanced needs. You don’t need to learn
it all at once. By focusing on the essentials, you avoid overwhelm and
build confidence quickly.

## Learning Through Patterns

The examples later in this chapter illustrate common patterns:

- Traversal (loop through all elements in a package).

- Creation (add a new element and update).

- Relationship management (add connectors).

- Metadata (set tagged values).

- SQL vs object trade-offs (query then act).

These patterns recur constantly. Once you know them, you can adapt them
to almost any task.

## Common Pitfalls

Even at the API essentials level, there are traps:

- Misusing EA collections (they are not arrays).

- Forgetting Update() or RefreshModelView().

- Confusing stereotype with StereotypeEx (use the latter for
  profile-qualified stereotypes).

- Assuming element names are unique (they are not; always prefer GUID or
  ID).

- Overusing Session.Output in large loops (slow).

These pitfalls are avoidable once you internalise the essentials.

## Looking Ahead

This chapter covered the essentials: Repository, Package, Element,
Connector, and TaggedValue. You now know how to retrieve, inspect, and
modify them. In the next chapter we will look at working **inside EA
with JScript**, including common pitfalls, utility functions, and
debugging strategies.

# Chapter 5: Inside EA with JScript

The previous chapters have explained why you would script Enterprise
Architect (EA), how automation fits into the overall landscape, and
which core objects form the backbone of the API. Now it is time to get
specific about the scripting language you will actually use inside EA.

EA provides three options in its built-in scripting window:
**VBScript**, **JScript**, and in newer versions, **JavaScript**. Each
of these has its own history, syntax, and quirks. For most users today,
the best balance of accessibility, capability, and long-term viability
is found in **JavaScript** — or more accurately, in Microsoft’s JScript
engine, which is EA’s internal implementation of ECMAScript 3.

This chapter explores what it means to work inside EA with
JavaScript/JScript. It explains the constraints of the runtime, the
pitfalls of assuming modern ECMAScript features, and the techniques that
make the language usable for practical automation. It also sets
expectations: you will not be writing modern Node.js code, but you can
still achieve powerful results with a lean, disciplined subset of
JavaScript.

## The Language Landscape

Why does EA support these languages? The answer lies in its history. In
the early 2000s, Windows scripting was dominated by **VBScript** and
**JScript**, both hosted by the Windows Script Host. They were the
default scripting choices for automation in Microsoft Office and many
other applications. EA adopted them as its embedded scripting languages.

VBScript is verbose, procedural, and feels like a cousin of Visual Basic
for Applications (VBA). JScript is Microsoft’s implementation of
ECMAScript 3 (ES3), roughly equivalent to JavaScript as it existed in
Internet Explorer 6.

More recently, Sparx Systems added support for JavaScript labelled as
such, but under the hood it is still the JScript ES3 runtime. That means
many of the features you may expect from modern JavaScript — let, const,
arrow functions, array methods like forEach, JSON parsing — are missing.
If you try to use them, your script will fail.

## JavaScript or JScript?

Given these limitations, why choose JavaScript over VBScript? There are
several reasons:

- **Familiarity**: even with its older syntax, JavaScript feels more
  familiar to today’s developers and architects than VBScript.

- **Readability**: JScript code tends to be shorter and cleaner than
  equivalent VBScript.

- **Longevity**: while VBScript has been officially deprecated by
  Microsoft, JavaScript remains the world’s most widely used language.
  Even if EA lags in its runtime, the language concepts remain
  transferable.

- **Transition potential**: once you know how to script EA in JScript,
  moving to external JavaScript (Node.js, modern ES) or Python is
  easier.

For these reasons, this book assumes you will primarily use
**JScript/JavaScript** as your internal scripting language. VBScript
examples are included occasionally for reference, but JScript is the
pragmatic choice going forward.

## The Constraints of JScript ES3

The most important thing to understand is what you **cannot do** in EA’s
JScript engine. Here are the key constraints:

- **No modern declarations**: only var is allowed; let and const are not
  recognised.

- **No arrow functions**: ()=\> syntax is invalid. Use function()
  instead.

- **No array helpers**: methods like forEach, map, filter, reduce do not
  exist.

- **No JSON methods**: JSON.parse and JSON.stringify are not available.
  If you need JSON, you must parse manually or use external automation.

- **No promises or async/await**: everything is synchronous.

- **String handling**: only basic functions like indexOf, substring,
  replace are available.

This feels restrictive, especially if you come from modern JavaScript.
But it is enough for the kinds of tasks EA scripting requires:
traversing collections, setting properties, logging, and basic string
manipulation.

## Scripting Tips

### Adapting to EA Collections

One of the most common mistakes beginners make is assuming EA’s
collections behave like JavaScript arrays. They do not. EA’s collections
are COM objects. They expose only two members: .Count and .GetAt(index).

That means you must loop with a standard for loop:

var els = pkg.Elements;

for (var i = 0; i \< els.Count; i++) {

var e = els.GetAt(i);

Session.Output(e.Name);

}

Try to call els.forEach(...) and you will get an error. Understanding
this quirk is half the battle of learning EA scripting.

### Logging with Session.Output

Another adaptation is how you print feedback. There is no console.log.
Instead, EA provides Session.Output, which writes to the Output tab. For
example:

Session.Output("Hello from EA!");

For large operations, use file logging instead (via FileSystemObject),
because thousands of lines in the Output tab will slow EA down.

### Dry-Run and Logging Discipline

The limitations of the language make **discipline even more important**.
That is why this book insists on starting every modifying script with a
DRY_RUN flag and embedding structured logging. Because there is no undo,
and because the debugging tools are limited, you must build safety into
your scripts from the start.

### The Benefits of Simplicity

There is a positive side to JScript’s limitations: it forces you to keep
scripts **simple and focused**. Each script should do one thing well —
rename elements, export to CSV, check for missing tags. You won’t be
tempted to over-engineer or add unnecessary abstractions.

For larger tasks, the advice is clear: use external automation in Python
or C#. Internal JScript is for sharp, focused tools that run close to
the model.

### Thinking Like a Modeller

It is worth remembering that most EA users are not professional
programmers. They are architects, analysts, engineers — people who need
automation to support modelling, not to build software products. JScript
inside EA is perfectly suited to this audience. It lets you express
simple logic in a few lines. It integrates directly with the repository.
It is always available without external setup.

This chapter is therefore less about writing elegant JavaScript and more
about **thinking like a modeller who scripts**. The aim is clarity,
safety, and repeatability.

## A Progressive Learning Curve

The examples in this chapter begin simple — how to add an element, set a
tagged value, or traverse a package tree. They then build toward more
practical utilities: bulk renaming, enforcing conventions, exporting
tagged values. Each example is fully commented so you see not only the
syntax but also the reasoning.

As you practice, you will find that most tasks follow similar patterns:

- Find a package.

- Loop through elements.

- Check a property.

- Modify or log as needed.

- Call Update().

- Refresh the view.

This pattern is so common it becomes second nature. Once you see it a
few times, you can adapt it to almost anything.

## Preparing for the Examples

The worked examples that follow this introduction will show how to:

- Create elements inside a package.

- Set stereotypes and tagged values.

- Traverse package hierarchies.

- Safely update and refresh content.

Remember as you study them:

1.  JScript is old, but it works.

2.  Stick to ES3 constructs (var, for, function).

3.  Treat EA collections as COM objects, not arrays.

4.  Use Session.Output for small logs, CSV files for large ones.

5.  Always keep DRY_RUN = true until you are certain.

Mastering these basics will make you comfortable in EA’s scripting
environment, ready to explore external automation and add-ins later.

**  **

### Safe Variable Declarations

// -------------------------------------------------------

// Example 5.1 – Safe variable declarations in JScript

// -------------------------------------------------------

// ❌ Wrong (not supported in JScript)

// let x = 10;

// const y = 20;

// ✅ Correct

var x = 10;

var y = 20;

// Variables declared inside blocks are still visible outside

if (true) {

var z = 30; // visible outside the if block

}

Session.Output("x=" + x + ", y=" + y + ", z=" + z);

### Utility Functions

Since JScript lacks many string and array helpers, you should include
utility functions in most scripts.

// -------------------------------------------------------

// Example 5.2 – Common utility functions for JScript

// -------------------------------------------------------

// Trim whitespace

function trim(str) {

if (str == null \|\| str == undefined) return "";

return String(str).replace(/^\s+\|\s+\$/g, "");

}

// Case-insensitive string comparison

function safeCompare(str1, str2) {

return String(str1 \|\| "").toLowerCase() === String(str2 \|\|
"").toLowerCase();

}

// Check if string starts with a prefix

function startsWith(str, prefix) {

return String(str \|\| "").indexOf(prefix) === 0;

}

// Check if string contains substring

function contains(str, substring) {

return String(str \|\| "").indexOf(substring) !== -1;

}

// Demonstration

Session.Output("Trimmed: '" + trim(" hello ") + "'");

Session.Output("Compare: " + safeCompare("Test","test"));

Session.Output("StartsWith: " + startsWith("Enterprise
Architect","Enter"));

Session.Output("Contains: " + contains("Enterprise
Architect","Architect"));

### Iterating EA Collections

EA collections are **not** JavaScript arrays.

// -------------------------------------------------------

// Example 5.3 – Iterating through EA collections

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var package = Repository.GetTreeSelectedPackage();

if (!package) {

Session.Prompt("Please select a package.", promptOK);

return;

}

var elements = package.Elements;

// ❌ Wrong – this will fail

// elements.forEach(function(e) { ... });

// ✅ Correct – use Count and GetAt()

for (var i = 0; i \< elements.Count; i++) {

var element = elements.GetAt(i);

Session.Output("Element: " + element.Name);

}

}

main();

### File I/O with ActiveX

If you need to read or write files, use the Windows FileSystemObject.

// -------------------------------------------------------

// Example 5.4 – Reading a text file in JScript

// -------------------------------------------------------

function readFile(filePath) {

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = fso.OpenTextFile(filePath, 1); // 1 = ForReading

var content = file.ReadAll();

file.Close();

return content;

}

function main() {

try {

var text = readFile("C:\\temp\\example.txt");

Session.Output("File contents: " + text);

} catch(e) {

Session.Output("Error: " + e.message);

}

}

main();

### Debugging with Session.Output

Unlike modern environments, you don’t have a console. Use
Session.Output() to print values and track progress.

// -------------------------------------------------------

// Example 5.5 – Debugging with Session.Output

// -------------------------------------------------------

function main() {

Session.Output("Debugging start...");

var package = Repository.GetTreeSelectedPackage();

if (!package) {

Session.Output("No package selected.");

return;

}

Session.Output("Selected package: " + package.Name);

var elements = package.Elements;

Session.Output("Element count: " + elements.Count);

for (var i = 0; i \< elements.Count; i++) {

var element = elements.GetAt(i);

Session.Output("Element\[" + i + "\]: " + element.Name);

}

Session.Output("Debugging finished.");

}

main();

### Error Handling

JScript supports try–catch, but exceptions are limited.

// -------------------------------------------------------

// Example 5.6 – Error handling in JScript

// -------------------------------------------------------

function main() {

try {

var result = 10 / 0; // Still valid, result = Infinity

Session.Output("Result: " + result);

// Force an error by calling undefined function

undefinedFunction();

} catch (e) {

// e.message is usually the only useful property

Session.Output("Caught error: " + e.message);

}

}

main();

### Putting It All Together

By combining these patterns, you can write safe, predictable scripts
inside EA:

1.  Always use var for variables.

2.  Include helper functions for missing features.

3.  Loop over collections with .Count and .GetAt(i).

4.  Use Update() to persist changes and RefreshModelView() to update the
    UI.

5.  Use Session.Output() for debugging.

6.  Use try–catch, but don’t expect detailed stack traces.

## Looking Ahead

This chapter has focused on the quirks of JScript inside EA. With this
knowledge, you can write safe, basic scripts without falling into the
traps of modern JavaScript expectations. In the next chapter we move to
**external automation**, where Python, C#, and other modern languages
open up much more powerful possibilities for integration and data
processing.

# Chapter 6: External Automation

Internal scripts in Enterprise Architect (EA) are perfect for quick
utilities, governance checks, and tidy-ups that live with the
repository. Sometimes you need more. Integrations with registries and
backlog tools, JSON-heavy exports, analytics over thousands of elements,
CI/CD checks, and richer UX all benefit from **external automation**.

External automation means driving EA from a separate program (e.g.,
C#/.NET, Python) via EA’s COM interface. Your program attaches to (or
launches) EA, grabs the same Repository object you use inside scripts,
and then performs work — with modern language ecosystems, logging,
tests, packaging, and debugging.

## Why external automation?

- **Modern capabilities**: async, structured logging, JSON, LINQ/pandas.

- **Ecosystem**: proper source control, CI, test frameworks, packaging.

- **Integration**: REST/Graph APIs, registries, issue trackers, data
  platforms.

- **Maintainability**: clearer separation of concerns and deployable
  tools.

- **Scale**: process large repositories, batch operations, pipelines.

## How it works (at a glance)

EA registers a COM server (EA.App). Your tool attaches (or launches),
obtains EA.App.Repository, and then uses the familiar API for packages,
elements, connectors, diagrams, SQL reads, and so on — just from outside
EA.

### Example 6.1 — End-to-End External Automation with EAConnect

The example below shows a practical, fully-commented **C#** console
utility that:

1.  Connects to EA (attach or launch)

2.  Ensures a model is open (optionally open a specified file)

3.  Finds a working package (selected in UI or falls back to first root)

4.  Creates a new Element in that package

5.  Persists and refreshes the UI so the change is immediately visible

The EAConnect helper (namespace EA.Automation) centralises COM wiring,
timing/polling, and small UX conveniences. The full helper
implementation and setup guidance live in **Appendix A – EAConnect
Helper & Setup**.

//
=============================================================================================

// Example 6.1

// File: Program.cs

// Project: EA Automation – Example Utility

// Author: \<Your Name\>

//

// Created: 2025-08-31

// Last Update: 2025-08-31

//

// PURPOSE

// -------

// Demonstrates a practical end-to-end EA automation task using the
EAConnect helper:

// 1) Connect to Enterprise Architect (attach or launch)

// 2) Ensure a model is open (optionally open a specified
.qea/.qeax/.eapx)

// 3) Identify a target package (selected in the UI or fallback to the
first root)

// 4) Create a new Element in that package

// 5) Persist and refresh the UI so the user immediately sees the change

//

// USAGE

// -----

// From a developer console (matching EA bitness):

// MyEaTool.exe "New Class Name" "Class" "Optional notes"

// "OptionalProfile::OptionalStereotype"

//

// Arguments (all optional; sensible defaults provided):

// \[0\] name : Element name (default: "New Class")

// \[1\] type : Element type (default: "Class"; e.g., "Component",
"Requirement", "UseCase")

// \[2\] notes: Notes/description (default: "Created by example
utility.")

// \[3\] stereotypeEx : Fully qualified stereotype (default: none; e.g.,
"BPMN2.0::Task")

//

// PRE-REQUISITES

// --------------

// - Windows + .NET 8 (Windows)

// - \<TargetFramework\>net8.0-windows\</TargetFramework\>

// - \<PlatformTarget\>x64\</PlatformTarget\> (for EA 64-bit) or x86 for
32-bit EA

// - Reference Interop.EA.dll from your EA installation

// - Entry point marked \[STAThread\]

//

// NOTES

// -----

// If nothing is selected in EA’s Project Browser, we default to the
first root package.

// After creating the element, call element.Update() to persist and then
refresh the model view.

// We also advise EA’s UI that the element changed to update open
diagrams.

//

// UPDATE HISTORY

// --------------

// - 2025-08-31: Initial illustrative example.

//
==============================================================================================

\#nullable enable

using System;

using EA;

using EA.Automation; // EAConnect helper

internal static class Program

{

\[STAThread\] // EA COM automation expects an STA thread

private static void Main(string\[\] args)

{

// --------------------------------------------

// 0) Parse command-line args with safe defaults

// --------------------------------------------

string name = args.Length \> 0 ? args\[0\] : "New Class";

string type = args.Length \> 1 ? args\[1\] : "Class";

string notes = args.Length \> 2 ? args\[2\] : "Created by example
utility.";

string? stereotype = args.Length \> 3 ? args\[3\] : null;

// Optional: set this if you want to force-opening a specific model file
when none is open.

// If you’re writing a general utility, you might leave it null and let
the user open/select.

string? modelPath = null;

// Example:

// modelPath = @"C:\Users\Public\Documents\Sparx Systems\EA\EA
Example.qea";

Console.WriteLine("EA Automation Example – Add Element to Package");

Console.WriteLine(\$"Requested element: Name='{name}', Type='{type}',
StereotypeEx='{stereotype ?? "(none)"}'");

try

{

// ------------------------------------------------------------

// 1) Connect to EA, ensure a model is open, and show the UI

// ------------------------------------------------------------

using var ea = EAConnect.AttachOrLaunch(new EAConnect.Options

{

PreferAttach = true, // attach to a running EA if possible

LaunchIfNotRunning = true, // otherwise launch a new EA instance

ModelPath = modelPath, // open a known model if none is open

ShowUI = true, // show EA UI so user sees what happens

StartupWaitMs = 1500, // small settle time after opening/launching

RepoPollMs = 100, // poll interval for App.Repository

RepoPollMax = 50 // up to 5 seconds for Repo to appear

});

//
-----------------------------------------------------------------------

// 2) Find the working package: selected package or fallback to
root\[0\]

//
-----------------------------------------------------------------------

Package pkg = ea.GetSelectedPackageOrRoot();

Console.WriteLine(\$"Target package: {pkg.Name} (ID={pkg.PackageID})");

// --------------------------------------------------------

// 3) Create a new element inside that package (core steps)

// - AddNew(name, type)

// - Set optional properties (Notes, StereotypeEx)

// - Update() to persist changes

// --------------------------------------------------------

Element el = (Element)pkg.Elements.AddNew(name, type);

if (!string.IsNullOrEmpty(stereotype))

{

// For MDG types, you can set fully qualified stereotype (e.g.,
"BPMN2.0::Task")

el.StereotypeEx = stereotype;

}

if (!string.IsNullOrWhiteSpace(notes))

el.Notes = notes;

// Persist the new element into the repository

if (!el.Update())

{

// If Update() returns false, EA has an error you can read via

// repo.GetLastError()

throw new InvalidOperationException("Element.Update() failed.");

}

//
------------------------------------------------------------------------

// 4) Refresh EA’s UI so the user immediately sees the new element
appear

//
------------------------------------------------------------------------

// - AdviseElementChange: tells EA something changed – updates any open
diagrams

// - RefreshModelView : reloads the package in the Project Browser

ea.Repo.AdviseElementChange(el.ElementID);

ea.Repo.RefreshModelView(pkg.PackageID);

Console.WriteLine(\$"Created: {el.Name} \[{el.Type}\]");

Console.WriteLine(\$"GUID : {el.ElementGUID}");

// -----------------------------------------

// 5) Bonus: enumerate elements in the pkg

// -----------------------------------------

Console.WriteLine();

Console.WriteLine("Elements now present in package:");

short count = pkg.Elements.Count;

for (short i = 0; i \< count; i++)

{

var existing = (Element)pkg.Elements.GetAt(i);

Console.WriteLine(\$" - {existing.Name} ({existing.Type})");

}

Console.WriteLine();

Console.WriteLine("Done. Press any key to exit.");

Console.ReadKey();

}

catch (Exception ex)

{

// In production tools you might log the stack. For a book example, keep
output readable.

Console.WriteLine();

Console.WriteLine("ERROR:");

Console.WriteLine(ex.Message);

Console.WriteLine("Tip: Ensure EA is installed (matching x64/x86),
Interop.EA.dll is referenced,");

Console.WriteLine(" and that a model is open or ModelPath is set.");

Console.WriteLine("Press any key to exit.");

Console.ReadKey();

}

}

}

## Trade-offs

**Pros**

- Modern language, logging, testing, and packaging.

- Clear separation from the model repository.

- Works well for integrations, analytics, and pipelines.

- Easier to scale and maintain over time.

**Cons**

- Requires setup (Interop reference, bitness alignment, COM
  availability).

- Windows/COM dependency.

- Distribution/versioning outside the model.

- Speed + power mean mistakes propagate quickly if you skip safety.

**Safety still matters**

- Prefer **dry-run** patterns and **audit logs** for batch updates.

- Use **SQL-find + API-write** for scale (helper provides this).

- Test on **sandbox repositories** first.

- **Batch** writes and **refresh** the UI once per operation.

## Where this goes next

Most teams adopt a blended approach: internal scripts for quick hygiene;
external utilities for integrations and heavy lifting; add-ins for
stable, menu-driven capabilities. With EAConnect, you keep examples
concise while centralising boilerplate and sharp edges in one place.

See **Appendix A – EAConnect Helper & Setup** for the full helper class
(verbose header, usage, assumptions, dependencies, and update history),
plus environment notes (Interop.EA.dll, bitness, COM), optional
“directory-only” output pickers, CSV logging utilities, a
curate-then-apply pipeline, and the SQL-accelerated find / API-safe
write pattern.

# Chapter 7: Script Design Patterns

When you first begin scripting in Enterprise Architect, the process
feels like a series of one-off solutions. You need to rename a batch of
elements, so you write a loop. You want to add a tagged value
everywhere, so you copy and tweak the loop. You need to enforce a naming
convention, so you adjust the loop again. Each script solves the
immediate problem but looks and feels slightly different from the last.
After a while, you realise you are writing the same structural code over
and over, just with small changes in logic.

This is not accidental. EA scripting tasks fall into recurring shapes.
Recognising these shapes and naming them as **design patterns** gives
you a powerful advantage. Instead of starting from scratch each time,
you select the right pattern and plug in your task-specific logic.
Patterns make scripts **shorter, safer, and more consistent**. They also
make it easier to share code with colleagues, because everyone
recognises the pattern being used.

This chapter introduces a handful of design patterns that cover the
majority of practical EA scripting needs. They are not patterns in the
object-oriented sense of Singleton or Observer, but scripting patterns
tuned to the EA environment. Each one addresses a class of problems —
traversing and filtering elements, applying changes in two phases,
propagating metadata, checking quality. Once you master them, scripting
EA becomes less about inventing and more about assembling known patterns
into solutions.

## Why Patterns Matter

The first reason to adopt patterns is **safety**. Many script errors
arise because someone hand-coded a loop in haste, forgot to check
ObjectType, or failed to include Update(). A pattern encapsulates safe
practices — dry-run flags, logging, backwards deletion, UI refreshes —
so you don’t have to remember them each time.

The second reason is **productivity**. A good pattern reduces
boilerplate. You can focus on what the script should *do*, rather than
how to set up the loop. For example, the Find/Filter/Apply pattern sets
up traversal for you; you just provide the filter condition and the
apply logic.

The third reason is **communication**. When you share a script with a
colleague and they see it follows a known pattern, they can understand
it quickly. It creates a shared vocabulary: “oh, this is a
Curate-then-Write script” means more than “this is some code that loops
twice.”

## Examples

### Shared Helper

Drop this small helper library in your script group (e.g.,
“\_Common\Helpers.js”) and !INC it from each script.

// -------------------------------------------------------

// Example 7.1 - Helpers.js (JScript ES3) – Common utility helpers

// Purpose: Logging, safety utilities, folder picker, CSV writer

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

// ---- Safety & string helpers (ES3) ----

function isNil(x) { return x === null \|\| x === undefined; }

function trim(s) { return isNil(s) ? "" :
String(s).replace(/^\s+\|\s+\$/g, ""); }

function equalsIgnoreCase(a, b) { return String(a\|\|"").toLowerCase()
== String(b\|\|"").toLowerCase(); }

function startsWith(s, p) { return String(s\|\|"").indexOf(p) === 0; }

function contains(s, sub) { return String(s\|\|"").indexOf(sub) !== -1;
}

// ---- Output tab management ----

function ensureOutputTab(name) {

try { Repository.CreateOutputTab(name); } catch(e) {}

try { Repository.ClearOutput(name); } catch(e) {}

try { Repository.EnsureOutputVisible(name); } catch(e) {}

}

function log(tab, msg) { Session.Output("\[" + tab + "\] " + msg); }

// ---- Folder picker (directory only; no file names) ----

function browseForFolder(promptText) {

// Shell.BrowseForFolder is reliable and does \*directory only\*

var shell = new ActiveXObject("Shell.Application");

var folder = shell.BrowseForFolder(0, promptText, 0, 0);

if (!folder) return null;

// Ensure plain path (Self.Path)

return folder.Self.Path;

}

// ---- CSV writer (append; creates file on first write) ----

function CsvWriter(path) {

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = null;

function openAppend() {

// 8 = ForAppending, 2 = TristateTrue (Unicode); EA often prefers ANSI,
so use default

// (TristateFalse=0)

// We'll stick with default encoding for broader compatibility.

file = fso.OpenTextFile(path, 8, true);

}

this.writeHeader = function(headerLine) {

if (!file) openAppend();

file.WriteLine(headerLine);

};

this.writeRow = function(arr) {

if (!file) openAppend();

var i, out = "";

for (i=0; i\<arr.length; i++) {

var cell = String(arr\[i\]).replace(/"/g, '""'); // escape quotes

if (contains(cell, ",") \|\| contains(cell, "\\") ) {

out += "\\" + cell + "\\";

} else {

out += cell;

}

if (i \< arr.length - 1) out += ",";

}

file.WriteLine(out);

};

this.close = function() { if (file) file.Close(); };

}

// ---- Timing helper ----

function nowMs() { return (new Date()).getTime(); }

### Pattern 1 – Find / Filter / Apply

The most common pattern in EA scripting is:

1.  **Find** a collection of items (elements, connectors, diagrams).

2.  **Filter** them based on conditions (type, stereotype, missing tag).

3.  **Apply** an action (rename, add tag, log).

This pattern underlies most governance checks and batch updates. It is
safe, scalable, and easy to extend. You will see many examples in this
chapter where the Find/Filter/Apply loop is the skeleton on which the
logic hangs.

**When to use:** bulk changes with clear criteria (e.g. rename, retag,
stereotype changes).  
Why: separates selection from action; an easy, safe mental model.

// -------------------------------------------------------

// Example 7.2 - Pattern1_FindFilterApply.js – JScript (ES3)

// Purpose: Demonstrates Find/Filter/Apply on elements in a selected
package

// Usage: Select a package → run script. Uses dry-run by default.

// Assumptions:

// - ES3 only; EA collections require Count/GetAt(i)

// - No modern JS features

// Parameters: adjust TYPE_FILTER / NAME_PREFIX to your needs

// Dependencies: Helpers.js (browseForFolder, CsvWriter, logging)

// Update history: 1.0 initial

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "FindFilterApply";

ensureOutputTab(TAB);

// ---- Config ----

var DRY_RUN = true; // switch to false to commit

var TYPE_FILTER = "Class"; // only operate on these element types (e.g.,
"Requirement", "Capability")

var NAME_PREFIX = "ARCH\_"; // example change: ensure name has this
prefix

var WRITE_CSV = true;

// ---- Context ----

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Please select a package.", promptOK);
return; }

log(TAB, "Selected package: " + pkg.Name + " (ID " + pkg.PackageID +
")");

var t0 = nowMs();

// ---- CSV setup (directory-only; no filename prompts) ----

var csv = null;

if (WRITE_CSV) {

var dir = browseForFolder("Select output folder for log CSV (directory
only):");

if (dir) {

var stamp = (new Date()).getTime();

var outPath = dir + "\\pattern1_find_filter_apply\_" + stamp + ".csv";

csv = new CsvWriter(outPath);

csv.writeHeader("ElementID,GUID,OldName,NewName,Type,Action");

log(TAB, "Logging to: " + outPath);

} else {

log(TAB, "No folder selected; CSV logging disabled.");

}

}

// ---- Find & filter ----

var targets = \[\];

var elements = pkg.Elements;

var i;

for (i=0; i\<elements.Count; i++) {

var el = elements.GetAt(i);

if (!equalsIgnoreCase(el.Type, TYPE_FILTER)) continue;

// Filter condition: name missing prefix

var hasPrefix = startsWith(el.Name, NAME_PREFIX);

if (!hasPrefix) targets.push(el);

}

log(TAB, "Found " + targets.length + " target(s).");

// ---- Apply ----

var changed = 0;

for (i=0; i\<targets.length; i++) {

var e = targets\[i\];

var oldName = e.Name;

var newName = NAME_PREFIX + oldName;

if (csv) csv.writeRow(\[e.ElementID, e.ElementGUID, oldName, newName,
e.Type, (DRY_RUN? "DRY-RUN" : "RENAME")\]);

if (!DRY_RUN) {

e.Name = newName;

e.Update(); // persist

}

changed++;

}

// Refresh UI if we wrote changes

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(pkg.PackageID);

var dt = nowMs() - t0;

log(TAB, "Changed " + changed + " / " + targets.length + " target(s).
Dry-run=" + DRY_RUN + ". Time=" + dt + "ms");

if (csv) csv.close();

}

main();

### Pattern 2 – Curate-then-Write (2-Phase Updates)

Sometimes you cannot safely update as you go. Perhaps you want to check
what will change before actually changing it. Perhaps you want to let a
governance board review the list before updates are applied.

The **Curate-then-Write** pattern solves this by splitting the process
into two phases:

1.  **Curate** — gather and log the items that *would* be changed
    (always with DRY_RUN).

2.  **Write** — only later, with approval, run the script again with
    changes applied.

This pattern reduces risk and increases confidence. It mirrors the
dry-run principle, but formalises it into a workflow.

**When to use:** risky or large updates. First produce a **reviewable
CSV**, then run again to apply.  
**Why:** EA has no transactions; curate first to avoid irreversible bulk
mistakes.

// -------------------------------------------------------

// Example 7.3 - Pattern2_CurateThenWrite.js – JScript (ES3)

// Purpose: Phase 1 = produce CSV for review; Phase 2 = read curated CSV
and apply

// Usage:

// - Phase 1: set MODE="export" → generates CSV with proposed changes

// - Review/edit the CSV (approve rows by setting Apply=YES)

// - Phase 2: set MODE="apply" → reads CSV and applies only approved
rows

// Assumptions:

// - ES3 only; CSV written in ANSI for broad compatibility

// - Directory chooser only (no filename prompts)

// Dependencies: Helpers.js

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "CurateThenWrite";

ensureOutputTab(TAB);

// ---- Config ----

var MODE = "export"; // "export" or "apply"

var TYPE_FILTER = "Requirement";

var PROPOSED_STATUS = "Approved";

if (MODE == "export") return exportPhase(TAB, TYPE_FILTER,
PROPOSED_STATUS);

if (MODE == "apply") return applyPhase(TAB);

Session.Prompt("Unknown MODE. Use 'export' or 'apply'.", promptOK);

}

function exportPhase(TAB, TYPE_FILTER, PROPOSED_STATUS) {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var dir = browseForFolder("Select output folder for curation CSV:");

if (!dir) { log(TAB, "Cancelled."); return; }

var stamp = (new Date()).getTime();

var path = dir + "\\pattern2_curate_export\_" + stamp + ".csv";

var csv = new CsvWriter(path);

csv.writeHeader("Apply,ElementID,GUID,Name,Type,CurrentStatus,ProposedStatus,Notes");

var i, elements = pkg.Elements;

var exported = 0;

for (i=0; i\<elements.Count; i++) {

var e = elements.GetAt(i);

if (!equalsIgnoreCase(e.Type, TYPE_FILTER)) continue;

// Propose: set Status to PROPOSED_STATUS

csv.writeRow(\["NO", e.ElementID, e.ElementGUID, e.Name, e.Type,
e.Status, PROPOSED_STATUS, "Set to Approved if meets criteria X"\]);

exported++;

}

csv.close();

log(TAB, "Wrote " + exported + " row(s) to " + path + ". Review and
change 'Apply' to YES where appropriate.");

}

function applyPhase(TAB) {

// Directory-only input: we’ll look for a single CSV file in the chosen
folder by pattern.

var dir = browseForFolder("Select folder that contains curated CSV
(pattern2_curate_export\_\*.csv):");

if (!dir) { log(TAB, "Cancelled."); return; }

// Very simple scan for the newest curated CSV file

var fso = new ActiveXObject("Scripting.FileSystemObject");

var folder = fso.GetFolder(dir);

var en = new Enumerator(folder.Files);

var newest = null, newestTime = 0;

for (; !en.atEnd(); en.moveNext()) {

var file = en.item();

if (contains(file.Name, "pattern2_curate_export\_") &&
endsWith(file.Name, ".csv")) {

if (file.DateLastModified.getTime() \> newestTime) {

newest = file; newestTime = file.DateLastModified.getTime();

}

}

}

if (!newest) { log(TAB, "No curated CSV found."); return; }

log(TAB, "Applying from: " + newest.Path);

// Read CSV line by line (very simple parser; assumes no commas in
unquoted cells)

var ts = fso.OpenTextFile(newest.Path, 1); // ForReading

// Skip header

if (!ts.AtEndOfStream) ts.ReadLine();

var applied = 0, considered = 0;

while (!ts.AtEndOfStream) {

var line = ts.ReadLine();

var cells = line.split(",");

if (cells.length \< 8) continue;

var apply = trim(cells\[0\]);

var elementID = parseInt(cells\[1\], 10);

var proposedStatus = trim(cells\[6\]);

considered++;

if (!equalsIgnoreCase(apply, "YES")) continue; // only approved rows

var e = Repository.GetElementByID(elementID);

if (!e) continue;

e.Status = proposedStatus;

e.Update();

applied++;

}

ts.Close();

if (applied\>0) Repository.RefreshModelView(0);

log(TAB, "Applied " + applied + " change(s) out of " + considered + "
curated row(s).");

}

// ES3 helper – endsWith (not natively available)

function endsWith(s, suffix) {

s = String(s\|\|"");

var idx = s.lastIndexOf(suffix);

return idx \>= 0 && (idx + suffix.length === s.length);

}

main();

### Pattern 3 – Tag Propagation (Parent → Children)

Another frequent need is to ensure that metadata flows correctly between
related elements. For example, if a Capability has an Owner tag, then
all its linked Requirements should inherit that Owner. Or if a System
has a Criticality tag, then its Interfaces should carry the same.

The **Tag Propagation** pattern handles this: traverse a relationship,
read a tag from one element, apply it to another, log the change. It
enforces consistency and helps maintain traceability.

**When to use:** enforce a tagged value from a parent element or package
onto all contained elements (e.g., Domain=Diabetes).  
**Options:** set only if missing, or overwrite.

// -------------------------------------------------------

// Example 7.4 - Pattern3_TagPropagation.js – JScript (ES3)

// Purpose: Copy a tagged value from a selected \*source element\*

// to all elements in a selected \*target package\*

// Usage: Select source element → run; then select target package → run

// Assumptions: source has TagName present; target elements may or may
not

// Safety: DRY_RUN = true by default

// Dependencies: Helpers.js

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "TagPropagation";

ensureOutputTab(TAB);

// ---- Config ----

var DRY_RUN = true;

var TAG_NAME = "Domain";

var OVERWRITE = false; // false = set only if missing

// ---- Step 1: obtain source tag from selected element ----

var src = Repository.GetTreeSelectedObject();

if (!src \|\| src.ObjectType != otElement) {

Session.Prompt("Select the \*source element\* that contains the tag '" +
TAG_NAME + "'.", promptOK);

return;

}

var srcVal = readTag(src, TAG_NAME);

if (trim(srcVal) === "") {

Session.Prompt("Source element does not have tag '" + TAG_NAME + "'.",
promptOK);

return;

}

// ---- Step 2: ask user to select target \*package\* ----

Session.Prompt("Now select the \*target package\* and run the script
again to apply propagation.", promptOK);

// If you prefer one-run UX: comment out the prompt above and use
GetTreeSelectedPackage()

// directly

}

function applyToTarget() {

var TAB = "TagPropagation";

ensureOutputTab(TAB);

var DRY_RUN = true;

var TAG_NAME = "Domain";

var OVERWRITE = false;

// Re-get source from memory? For simplicity here we re-read it from
user:

// In practice you might stash it in a temp file or ask user for the
value via InputBox.

var val = Session.Input("Enter value to propagate for tag '" +
TAG_NAME + "':", "");

if (trim(val) === "") { log(TAB, "No value provided; aborting.");
return; }

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a \*target package\*.", promptOK);
return; }

var i, changed=0, elements = pkg.Elements;

for (i=0; i\<elements.Count; i++) {

var e = elements.GetAt(i);

var cur = readTag(e, TAG_NAME);

if (trim(cur) === "") {

// tag missing → set

log(TAB, "Set " + TAG_NAME + " on " + e.Name + " → " + val);

if (!DRY_RUN) { writeTag(e, TAG_NAME, val); }

changed++;

} else if (OVERWRITE && cur != val) {

log(TAB, "Overwrite " + TAG_NAME + " on " + e.Name + " : " + cur + " →
" + val);

if (!DRY_RUN) { writeTag(e, TAG_NAME, val); }

changed++;

}

}

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(pkg.PackageID);

log(TAB, "Updated " + changed + " element(s). Dry-run=" + DRY_RUN);

}

// ---- Tag helpers ----

function readTag(e, name) {

var i, tvs = e.TaggedValues;

for (i=0; i\<tvs.Count; i++) {

var tv = tvs.GetAt(i);

if (equalsIgnoreCase(tv.Name, name)) return String(tv.Value\|\|"");

}

return "";

}

function writeTag(e, name, value) {

var i, tvs = e.TaggedValues;

for (i=0; i\<tvs.Count; i++) {

var tv = tvs.GetAt(i);

if (equalsIgnoreCase(tv.Name, name)) {

tv.Value = value; tv.Update(); e.Update(); return;

}

}

// add new if not found

var ntv = tvs.AddNew(name, String(value));

ntv.Update(); e.Update();

}

// Choose which entry point to bind in EA’s Scripts window:

// main() for step-by-step or applyToTarget() for one-shot after
prompting

// main();

applyToTarget();

### Pattern 4 – Linting & Quality Gates (Report-Only by Default)

Just as programmers use “linters” to check code quality, modellers can
use scripts to check model quality. The **Linting** pattern is about
scanning the repository for “smells”: missing notes, duplicate names,
orphaned elements, inconsistent stereotypes.

The script doesn’t necessarily fix the issues. It logs them, creates a
report, and highlights what needs attention. This is especially powerful
in enterprise settings where governance requires objective evidence of
model quality.

**When to use:** continuous hygiene checks (naming, required tags,
required relationships).  
**Why:** consistent, repeatable, fast feedback before governance
reviews.

// -------------------------------------------------------

// Example 7.5 - Pattern4_LintQuality.js – JScript (ES3)

// Purpose: Report model "smells" in selected package (no writes by
default)

// Checks:

// - Name not empty

// - Required tag exists (e.g., "Owner")

// - Name matches regex prefix (e.g., "REQ\_")

// Output: CSV + Output tab; dry-run concept not needed (read-only)

// Dependencies: Helpers.js

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "Lint";

ensureOutputTab(TAB);

// ---- Config ----

var REQUIRED_TAG = "Owner";

var NAME_PREFIX = "REQ\_";

var WRITE_CSV = true;

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package to lint.", promptOK);
return; }

var dir=null, csv=null;

if (WRITE_CSV) {

dir = browseForFolder("Select output folder for lint report:");

if (dir) {

var stamp = (new Date()).getTime();

var path = dir + "\\pattern4_lint_report\_" + stamp + ".csv";

csv = new CsvWriter(path);

csv.writeHeader("ElementID,GUID,Name,Type,Issue,Details");

log(TAB, "Logging to: " + path);

}

}

var i, issues=0, elements = pkg.Elements;

for (i=0; i\<elements.Count; i++) {

var e = elements.GetAt(i);

// Check 1: name present

if (trim(e.Name) === "") {

issues += emit(csv, e, "MissingName", "Element has no name");

}

// Check 2: required tag exists

if (trim(readTag(e, REQUIRED_TAG)) === "") {

issues += emit(csv, e, "MissingTag", "Required tag '"+REQUIRED_TAG+"' is
missing or empty");

}

// Check 3: naming convention

if (!startsWith(e.Name, NAME_PREFIX)) {

issues += emit(csv, e, "NamePrefix", "Expected prefix '" + NAME_PREFIX +
"'");

}

}

if (csv) csv.close();

log(TAB, "Lint finished. Issues found: " + issues);

}

function emit(csv, e, issue, details) {

var line = e.ElementID + " " + e.Name + " – " + issue + " : " + details;

log("Lint", line);

if (csv) csv.writeRow(\[e.ElementID, e.ElementGUID, e.Name, e.Type,
issue, details\]);

return 1;

}

function readTag(e, name) {

var i, tvs = e.TaggedValues;

for (i=0; i\<tvs.Count; i++) {

var tv = tvs.GetAt(i);

if (equalsIgnoreCase(tv.Name, name)) return String(tv.Value\|\|"");

}

return "";

}

main();

### Pattern 5 – SQL-Accelerated Find, API-Safe Write (Hybrid)

One of the most effective ways to balance speed with safety in EA
scripting is the **hybrid pattern**: use SQL to locate candidates, but
rely on the API to perform updates.

- **When to use**: this approach shines when you need to identify
  thousands of elements quickly — for example, all Requirements missing
  an Owner tag, or all Components in a given layer. Traversing entire
  package trees with .Count and .GetAt() can be slow; SQL queries are
  much faster.

- **Why not just update with SQL?** Because direct database updates
  bypass EA’s business rules and can corrupt the repository. That’s why
  writes must still go through the API.

**The idea** is simple:

1.  Use Repository.SQLQuery() with a SELECT statement to pull back the
    candidate IDs.

2.  Parse the XML result to extract element IDs or GUIDs.

3.  Loop over those IDs, load each object via the API, and apply updates
    safely (Update() + RefreshModelView()).

This hybrid approach gives you the best of both worlds:

- **Fast selection** (SQL can scan tens of thousands of rows in
  seconds).

- **Safe updates** (API ensures model integrity).

It is one of the most important performance patterns for large
repositories.

**When to use:** you need to *find* thousands of items quickly, but
still want **safe updates** via the API (not raw SQL writes).

**Idea:** use Repository.SQLQuery() to *select* candidates (fast), parse
the XML result to get IDs, then loop via API for writes (safe).

// -------------------------------------------------------

// Example 7.6. - Pattern5_SqlFind_ApiWrite.js – JScript (ES3)

// Purpose: Fast "find" via SQLQuery, then safe writes via API

// Usage: Select any package (context not required for SQL);
DRY_RUN=true by default

// Dependencies: Helpers.js

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "SqlFindApiWrite";

ensureOutputTab(TAB);

var DRY_RUN = true;

var TYPE_FILTER = "Class";

var STEREOTYPE_TO_SET = "DomainObject";

// 1) SQL find (XML result)

var sql = "SELECT Object_ID, ea_guid, Name FROM t_object WHERE
Object_Type='" + TYPE_FILTER + "' AND Stereotype IS NULL";

var xml = Repository.SQLQuery(sql);

// 2) Parse minimal XML (very simple string parsing; robust XML parser
not available in ES3)

// Expect rows like:
\<Row\>\<Object_ID\>123\</Object_ID\>\<ea_guid\>{...}\</ea_guid\>\<Name\>Foo\</Name\>\</Row\>

var ids = extractAll(xml, "\<Object_ID\>", "\</Object_ID\>");

var i, changed=0;

log(TAB, "Candidates: " + ids.length);

for (i=0; i\<ids.length; i++) {

var id = parseInt(trim(ids\[i\]), 10);

var e = Repository.GetElementByID(id);

if (!e) continue;

// Only set stereotype if empty (defensive sanity)

if (trim(e.Stereotype) === "") {

log(TAB, "Set stereotype on " + e.Name + " → " + STEREOTYPE_TO_SET);

if (!DRY_RUN) {

e.Stereotype = STEREOTYPE_TO_SET;

e.Update();

}

changed++;

}

}

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(0);

log(TAB, "Changed " + changed + " element(s). Dry-run=" + DRY_RUN);

}

// Minimal XML extraction helpers (no DOM available in ES3)

function extractAll(hay, openTag, closeTag) {

var res = \[\], start=0;

while (true) {

var i = hay.indexOf(openTag, start);

if (i \< 0) break;

var j = hay.indexOf(closeTag, i + openTag.length);

if (j \< 0) break;

var val = hay.substring(i + openTag.length, j);

res.push(val);

start = j + closeTag.length;

}

return res;

}

main();

## Pattern Handling

### Patterns as a Library

The beauty of patterns is that they can be turned into a **script
library**. Instead of writing bespoke code, you start from a template:

//
-------------------------------------------------------------------------------------------

// Example 7.7

//
-------------------------------------------------------------------------------------------

function findFilterApply(pkg, filterFn, applyFn) {

var els = pkg.Elements;

for (var i = 0; i \< els.Count; i++) {

var e = els.GetAt(i);

if (filterFn(e)) {

applyFn(e);

}

}

}

With such a template, your script becomes simply the filter and apply
functions. The boilerplate is taken care of. Even within EA’s limited
JScript environment, this approach saves effort and reduces bugs.

### Patterns and Governance

One of the most important applications of patterns is governance. Large
organisations rely on consistent models for reporting, compliance, and
decision-making. Manual governance is too slow. Patterns like
Find/Filter/Apply and Linting turn governance into a repeatable,
automated process.

For example, you can script a governance check that every Requirement
must have an Owner tag. The script follows the Find/Filter/Apply
pattern, filters Requirements, checks tags, and logs violations. By
running it regularly, you maintain model hygiene.

### Patterns Across Languages

Although the examples in this chapter are in JScript, the patterns
themselves are language-agnostic. If you later write external automation
in Python or C#, the same patterns apply. A Find/Filter/Apply loop in
Python looks slightly different, but the structure is identical. This
makes patterns a great way to transfer knowledge across teams and
technologies.

### The Safety Net of Patterns

Patterns also act as a safety net against AI hallucinations. As we saw
earlier, AI can generate starter scripts but often introduces
unsupported syntax. If you know the underlying pattern, you can spot and
correct mistakes quickly. For example, if AI gives you a forEach, you
know the pattern requires a .Count/.GetAt() loop, and you can adjust
accordingly.

## Performance & Safety Notes

- Prefer **Find/Filter/Apply** for clarity; switch to **SQL-accelerated
  find** when scale demands it.

- Keep **DRY_RUN = true** until you’ve inspected CSV logs.

- Call **Update()** after modifications, then **RefreshModelView()** for
  UI.

- For very large sets, consider chunking (operate in batches of, say,
  250 items) and pausing UI updates:

- // Pseudocode – EA may ignore UI flag in some contexts; rely on
  batching regardless

- // Repository.EnableUIUpdates = false; // not always honoured

- // ...do batches...

- // Repository.EnableUIUpdates = true;

- // Repository.RefreshModelView(0);

## Bonus: Python “Curate → Apply” Pipeline

Use this when CSV shaping, validation or integration (e.g., SharePoint,
Jira) is easier outside EA.

\# -------------------------------------------------------

\# Example 7.8 - pattern6_curate_apply_external.py – Python 3 (pywin32)

\# Purpose: Read a curated CSV of element updates and apply via EA API

\# Safety: Only rows with Apply=YES are executed

\# -------------------------------------------------------

import csv, win32com.client

def main(csv_path):

ea = win32com.client.Dispatch("EA.App")

repo = ea.Repository

changes = 0

with open(csv_path, "r") as f:

rdr = csv.DictReader(f)

for row in rdr:

if str(row.get("Apply","")).strip().lower() != "yes":

continue

eid = int(row\["ElementID"\])

new_status = row\["ProposedStatus"\]

e = repo.GetElementByID(eid)

if e:

e.Status = new_status

e.Update()

changes += 1

if changes:

repo.RefreshModelView(0)

print(f"Applied {changes} curated change(s).")

if \_\_name\_\_ == "\_\_main\_\_":

main(r"C:\path\to\pattern2_curate_export_123.csv")

## What to Use When (cheat-sheet)

- **Small, safe rename/retag** → Pattern 1 (Find/Filter/Apply).

- **Risky/wide updates** → Pattern 2 (Curate-then-Write).

- **Set common metadata** → Pattern 3 (Tag Propagation).

- **Governance checks** → Pattern 4 (Linting & Quality Gates).

- **Huge models** → Pattern 5 (SQL-find, API-write).

- **Pipelines & integrations** → Python external bonus.

# Chapter 8: Object Details

Enterprise Architect’s automation interface exposes a large number of
objects, each representing some aspect of the model: repositories,
packages, elements, connectors, attributes, tagged values, and many
more. The official Sparx documentation lists these objects, but it can
be terse and difficult to map back to day-to-day modelling tasks.

This chapter bridges that gap: it introduces the most common objects in
the API, explains how to use their attributes and collections, and
provides **fully commented JScript examples** you can run directly in
EA.

## Sparx EA Objects

### Repository

The **Repository** is always your starting point. It represents the
currently open EA project file (EAP, QEA, or DBMS connection).

//
----------------------------------------------------------------------------------------

// Example 8.1 - RepoInfo

// Purpose: Demonstrates key Repository properties

// Author: Handbook

// Date: 2025-08-26

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

// The Repository object is always available inside EA scripts

var repo = Repository;

// Connection string: file path or DB connection string

Session.Output("Connection: " + repo.ConnectionString);

// Root models

var models = repo.Models;

Session.Output("Root packages count: " + models.Count);

// Security

Session.Output("Security enabled: " + repo.IsSecurityEnabled);

// Current EA Edition

Session.Output("Edition: " + repo.EAEdition);

}

main();

### Package

A **Package** is a container for elements, diagrams, and child packages.

//
----------------------------------------------------------------------------------------

// Example 8.2 PackageTraverse

// Purpose: List all child packages and their elements

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-Jscript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) {

Session.Prompt("Select a package in the browser.", promptOK);

return;

}

Session.Output("Package: " + pkg.Name);

// Loop child packages

var childPkgs = pkg.Packages;

for (var i = 0; i \< childPkgs.Count; i++) {

var child = childPkgs.GetAt(i);

Session.Output(" Child package: " + child.Name);

}

// Loop elements in this package

var elements = pkg.Elements;

for (var j = 0; j \< elements.Count; j++) {

var el = elements.GetAt(j);

Session.Output(" Element: " + el.Name + " (" + el.Type + ")");

}

}

main();

### Element

An **Element** is any model item (Class, Requirement, Component, Actor,
etc.).

//
----------------------------------------------------------------------------------------

// Example 8.3 - ElementCreate

// Purpose: Add a new class to a selected package

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

// Add a new Class element

var el = pkg.Elements.AddNew("NewClass", "Class");

el.Notes = "This class was created by script.";

el.Update(); // Always update to persist

// Refresh UI so user sees it

Repository.RefreshModelView(pkg.PackageID);

Session.Output("Created class: " + el.Name);

}

main();

### Connector

A **Connector** represents a relationship between two elements.

//
----------------------------------------------------------------------------------------

// Example 8.4 - ConnectorCreate

// Purpose: Create a dependency between two selected elements

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

// Assumes two elements are selected in a diagram

var diagram = Repository.GetCurrentDiagram();

if (!diagram) { Session.Prompt("Open a diagram and select two
elements.", promptOK); return; }

if (diagram.SelectedObjects.Count != 2) {

Session.Prompt("Select exactly two elements.", promptOK);

return;

}

var el1 =
Repository.GetElementByID(diagram.SelectedObjects.GetAt(0).ElementID);

var el2 =
Repository.GetElementByID(diagram.SelectedObjects.GetAt(1).ElementID);

// Create dependency

var conn = el1.Connectors.AddNew("", "Dependency");

conn.SupplierID = el2.ElementID;

conn.Update();

Repository.RefreshModelView(el1.PackageID);

Session.Output("Created dependency: " + el1.Name + " → " + el2.Name);

}

main();

### Attribute

Attributes belong to elements (e.g., class fields).

//
----------------------------------------------------------------------------------------

// Example 8.5 - AddAttributes

// Purpose: Add attributes to a selected class

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var el = Repository.GetTreeSelectedObject();

if (!el \|\| el.ObjectType != otElement) {

Session.Prompt("Select a class element.", promptOK);

return;

}

if (el.Type != "Class") {

Session.Prompt("Element is not a class.", promptOK);

return;

}

// Add attribute

var attr = el.Attributes.AddNew("id", "int");

attr.Notes = "Primary key";

attr.Update();

el.Update();

Session.Output("Added attribute 'id:int' to " + el.Name);

}

main();

### Tagged Values

Tagged Values extend elements and connectors with metadata.

//
----------------------------------------------------------------------------------------

// Example 8.6 - TagValuesDemo

// Purpose: Add or update tagged values

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var el = Repository.GetTreeSelectedObject();

if (!el \|\| el.ObjectType != otElement) {

Session.Prompt("Select an element.", promptOK);

return;

}

// Add new tag

var tag = el.TaggedValues.AddNew("Owner", "ArchitectureTeam");

tag.Update();

// Update element after tag change

el.Update();

Session.Output("Tagged value 'Owner=ArchitectureTeam' set on " +
el.Name);

}

main();

### Diagram Objects

Diagram objects are visual instances of elements. They store
coordinates, styles, and appearance, not the semantic content.

//
----------------------------------------------------------------------------------------

// Example 8.7 - DiagramObjectStyle

// Purpose: Change fill color of selected diagram object

//
----------------------------------------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var dia = Repository.GetCurrentDiagram();

if (!dia) { Session.Prompt("Open a diagram.", promptOK); return; }

if (dia.SelectedObjects.Count == 0) {

Session.Prompt("Select at least one element on the diagram.", promptOK);

return;

}

var dobj = dia.SelectedObjects.GetAt(0);

dobj.BackgroundColor = 16777215; // White

dobj.Update();

Repository.ReloadDiagram(dia.DiagramID);

Session.Output("Updated background color for object ID " +
dobj.InstanceID);

}

main();

## Summary

This chapter covered the most important objects in EA’s automation
model: Repository, Package, Element, Connector, Attribute, TaggedValue,
and DiagramObject. Each has specific rules:

- Always call Update() to persist changes.

- Use .Count and .GetAt(i) for collections (they are not arrays).

- Refresh the model or diagram to see changes in the UI.

- Be cautious with null values (names, tags).

# Chapter 9: Imports & Exports

One of the first serious challenges you encounter when scripting
Enterprise Architect is how to move data in and out of the repository. A
model is rarely a self-contained island. Requirements may start life in
Jira or Excel. Application inventories may be stored in a CMDB. Metadata
may need to be exported to registries or analytics platforms. Architects
frequently face the practical need to **import content into EA** or
**export content from EA** to other systems.

This chapter focuses on imports and exports — arguably the most common
automation tasks in EA. At first glance, they may seem trivial: read
from CSV, create elements, write back. But once you attempt real-world
imports and exports, you quickly discover subtle complexities: handling
GUIDs, avoiding duplicates, ensuring round-trip consistency, and dealing
with encoding.

Understanding these complexities is essential. A poorly designed import
script can flood your repository with duplicates. A naïve export may
omit critical metadata or lose relationships. The goal of this chapter
is to build robust patterns for imports and exports that are safe,
repeatable, and auditable.

## Why Imports Matter

Imports are the way EA connects to upstream sources of truth. In many
organisations, architects are not the ones who originate requirements,
applications, or datasets. Those live in other systems. EA is where they
are curated, connected, and visualised.

For example:

- Requirements authored in Jira need to be imported into EA for
  traceability.

- Application inventories stored in Excel need to be imported as
  elements with tagged values.

- Data elements defined in a registry need to be imported into EA’s
  logical data model.

Without imports, EA risks becoming a disconnected silo. With imports, it
becomes part of the wider enterprise information flow.

## Why Exports Matter

The opposite direction is just as important. Many stakeholders do not
use EA directly. They expect to see outputs in Excel, JSON, Confluence,
or dashboards. Exports make EA’s content consumable.

For example:

- Exporting element inventories to CSV for analysis in Excel.

- Exporting model metadata to JSON for loading into a data catalog.

- Exporting governance reports to Confluence for project teams.

Exports also serve as safety tools: before running a script that
modifies content, export a snapshot for comparison.

## The Round-Trip Challenge

In theory, import and export should be symmetrical: export, modify
externally, import back. In practice, this is hard because of
**identity**. How do you know that a row in CSV corresponds to the same
element in EA?

If you match by name, duplicates are inevitable. If you match by ID, the
ID may change across repositories. The robust solution is to use
**GUIDs**. Every element, package, and connector in EA has a GUID. By
exporting and re-importing GUIDs, you can round-trip reliably.

This chapter emphasises the importance of GUID handling in all
import/export scripts.

## Common Pitfalls

Beginners often stumble into a few traps when writing import/export
scripts:

- **Duplicate creation**: forgetting to check if an element already
  exists before creating a new one.

- **Lost metadata**: exporting only names, not tags, stereotypes, or
  relationships.

- **Encoding errors**: CSV exports losing accented characters due to
  ANSI encoding.

- **Uncontrolled scope**: importing thousands of rows without dry-run or
  logging.

Each of these pitfalls can damage model integrity. The patterns in this
chapter address them with checks, dry-runs, and logs.

## Choosing a Format

The two most common formats for imports and exports are **CSV** and
**JSON**.

- **CSV** is simple, widely supported, and easy to review in Excel. It
  works best for tabular data: lists of requirements, applications, or
  tagged values.

- **JSON** is richer, supporting nested structures and hierarchies. It
  is more natural for hierarchical data, such as package trees or nested
  attributes.

EA scripts can handle CSV easily using FileSystemObject. JSON is
trickier because JScript lacks a parser, but you can still generate JSON
strings. For parsing JSON, external automation (Python, C#) is usually
better.

## GUIDs, Keys, and Identity

As mentioned earlier, GUIDs are the key to round-trip imports/exports.
Best practice is:

- **Always export the GUID** alongside names and types.

- **When importing**, check if the GUID exists in EA. If yes, update. If
  no, create.

- **If GUIDs are absent** (e.g., external system), generate your own
  external ID tag (e.g., JiraKey). Use this as the round-trip identity.

Scripts should never rely on element names alone for identity.

## Curated Imports

Another best practice is to **curate before commit**. Instead of blindly
importing all rows, first log what would be created or updated. Write
the proposed changes to a CSV, review them, then re-run the script with
DRY_RUN = false.

This two-phase approach mirrors the “Curate-then-Write” pattern
described in Chapter 7. It prevents surprises and builds trust in
automation.

## Safety in Exports

Exports may feel safer than imports — after all, they don’t change EA.
But they come with their own risks. An incomplete export can give
stakeholders a misleading picture. An unfiltered export may expose
sensitive data.

Safe export practices include:

- Logging the scope of what was exported.

- Including metadata fields like GUIDs, stereotypes, and tags.

- Confirming encoding (e.g., use external Python for UTF-8).

## Integrating Imports/Exports into Workflows

Imports and exports are rarely ends in themselves. They usually form
part of a wider workflow. For example:

1.  Export application inventory from EA to CSV.

2.  Send CSV to data owners for updates.

3.  Import CSV back into EA with changes.

Or:

1.  Import requirements from Jira.

2.  Trace them to capabilities and applications in EA.

3.  Export traceability report to Confluence.

Thinking of imports/exports as workflow steps encourages you to script
them with logging, curation, and repeatability.

## What you’ll use

Inside EA: JScript (ES3), FileSystemObject, Excel.Application (ActiveX),
EA API.

Outside EA: Python (pywin32) for JSON parsing and advanced integrations.

We’ll assume you have the **Shared Helpers** from Chapter 6
(\_Common.Helpers) available: ensureOutputTab, browseForFolder,
CsvWriter, string helpers, and nowMs().

### CSV Round-Trip (in-EA)

CSV is the simplest review format for non-technical stakeholders. The
safest pattern is **two-phase**: export a proposal → humans curate in
Excel → apply only rows marked “YES”.

### Export elements (recursive) to CSV

// -------------------------------------------------------

// Example 9.1 - ExportCSV_PackageRecursive.js – JScript (ES3)

// Purpose: Export elements of the selected package (and subpackages) to
CSV

// Usage: Select a package in the Project Browser → run script

// Output: directory-only chooser; filename auto-derived

// Assumptions:

// - ES3 only; EA collections use Count/GetAt(i)

// - Includes key fields for round-trip (IDs, GUIDs, parent package)

// Dependencies: \_Common.Helpers

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "ExportCSV";

ensureOutputTab(TAB);

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package to export.", promptOK);
return; }

var outDir = browseForFolder("Select output folder (CSV)");

if (!outDir) { log(TAB, "Cancelled."); return; }

var stamp = (new Date()).getTime();

var path = outDir + "\\export_elements\_" + safeName(pkg.Name) + "\_" +
stamp + ".csv";

var csv = new CsvWriter(path);

csv.writeHeader("Apply,ElementID,GUID,PackageID,PackageName,Name,Type,Stereotype,Status,Notes");

var count = walkPackage(pkg, function(el, p) {

csv.writeRow(\[

"NO", // Apply = NO by default (curate later)

el.ElementID,

el.ElementGUID,

p.PackageID,

p.Name,

el.Name,

el.Type,

String(el.Stereotype\|\|""),

String(el.Status\|\|""),

sanitize(el.Notes)

\]);

});

csv.close();

log(TAB, "Exported " + count + " element(s) → " + path);

}

function walkPackage(pkg, onElement) {

var n = 0, i;

var els = pkg.Elements;

for (i=0; i\<els.Count; i++) {

onElement(els.GetAt(i), pkg); n++;

}

var kids = pkg.Packages;

for (i=0; i\<kids.Count; i++) {

n += walkPackage(kids.GetAt(i), onElement);

}

return n;

}

function sanitize(s) {

// Compress newlines for CSV readability (optional)

s = String(s\|\|"");

s = s.replace(/\r\n/g, " ").replace(/\n/g, " ").replace(/\r/g, " ");

return s;

}

function safeName(s) { return
String(s\|\|"").replace(/\[^A-Za-z0-9\_\]+/g, "\_"); }

main();

### Apply curated CSV to update elements

CSV edited by humans is brittle; we keep parsing simple and only support
a few controlled changes. We’ll update Name, Stereotype, Status, and
optionally one tag**ged value** (e.g., Owner). Only rows with Apply=YES
will execute.

// -------------------------------------------------------

// Example 9.2 - ImportCSV_UpdateElements.js – JScript (ES3)

// Purpose: Apply curated updates to elements from a CSV (round-trip)

// Usage: Place curated CSV in a folder → run script → pick folder

// Safety: Only Apply=YES rows are executed; ElementID/GUID matching

// Dependencies: \_Common.Helpers

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "ImportCSV";

ensureOutputTab(TAB);

var dir = browseForFolder("Select folder containing curated CSV
(export_elements\_\*.csv)");

if (!dir) { log(TAB, "Cancelled."); return; }

var file = newestCsv(dir, "export_elements\_");

if (!file) { log(TAB, "No matching CSV found."); return; }

log(TAB, "Applying from: " + file.Path);

var fso = new ActiveXObject("Scripting.FileSystemObject");

var ts = fso.OpenTextFile(file.Path, 1); // ForReading

if (!ts.AtEndOfStream) ts.ReadLine(); // skip header

var applied=0, considered=0;

while (!ts.AtEndOfStream) {

var line = ts.ReadLine();

if (trim(line) === "") continue;

var cells = splitCsvLine(line); // naive split (works if reviewers
avoided stray commas)

// Expected header:
Apply,ElementID,GUID,PackageID,PackageName,Name,Type,Stereotype,Status,Notes

var apply = trim(getCell(cells,0));

var elementID= parseInt(getCell(cells,1),10);

var guid = trim(getCell(cells,2));

var newName = trim(getCell(cells,5));

var newStereo= trim(getCell(cells,7));

var newStatus= trim(getCell(cells,8));

considered++;

if (equalsIgnoreCase(apply,"YES")) {

var el = null;

// Prefer GUID match if provided

if (guid !== "") {

el = Repository.GetElementByGuid ? Repository.GetElementByGuid(guid) :
Repository.GetElementByGUID(guid);

}

if (!el && elementID \> 0) {

el = Repository.GetElementByID(elementID);

}

if (!el) { log(TAB, "Row skipped: element not found (GUID="+guid+"
ID="+elementID+")"); continue; }

var dirty = false;

if (newName !== "" && el.Name != newName) { el.Name = newName; dirty =
true; }

if (newStereo !== "" && String(el.Stereotype\|\|"") != newStereo) {
el.Stereotype = newStereo; dirty = true; }

if (newStatus !== "" && String(el.Status\|\|"") != newStatus) {
el.Status = newStatus; dirty = true; }

if (dirty) { el.Update(); applied++; }

}

}

ts.Close();

if (applied\>0) Repository.RefreshModelView(0);

log(TAB, "Applied " + applied + " curated change(s) out of " +
considered + " row(s).");

}

// Return newest CSV whose name starts with prefix

function newestCsv(dir, prefix) {

var fso = new ActiveXObject("Scripting.FileSystemObject");

var folder = fso.GetFolder(dir);

var en = new Enumerator(folder.Files);

var newest=null, t=0;

for (; !en.atEnd(); en.moveNext()) {

var f = en.item();

if (endsWith(f.Name.toLowerCase(), ".csv") && startsWith(f.Name,
prefix)) {

var m = f.DateLastModified.getTime();

if (m \> t) { newest=f; t=m; }

}

}

return newest;

}

// Very simple CSV splitting (assumes reviewers didn’t add embedded
commas/quotes)

function splitCsvLine(line) { return line.split(","); }

function getCell(arr, idx) { return idx \< arr.length ? arr\[idx\] : "";
}

function endsWith(s, suffix){ s=String(s\|\|""); var
i=s.lastIndexOf(suffix); return i\>=0 && (i+suffix.length===s.length); }

main();

**Tip**: If you must support commas/quotes in curated text, switch to
the **external Python importer** in §8.4; it uses the csv module to
parse safely.

### Excel via COM (in-EA)

Sometimes you must deliver a real **.xlsx** instead of a CSV. You can
drive Excel via ActiveX.

**Export to Excel (.xlsx)**

// -------------------------------------------------------

// Example 9.3 - ExportExcel_PackageSimple.js – JScript (ES3)

// Purpose: Write selected package elements to an .xlsx via Excel COM

// Usage: Select a package → run script → pick output folder

// Requirements: Microsoft Excel installed (same bitness as EA)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "ExportExcel";

ensureOutputTab(TAB);

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var outDir = browseForFolder("Select output folder (.xlsx)");

if (!outDir) { log(TAB, "Cancelled."); return; }

var stamp = (new Date()).getTime();

var filePath = outDir + "\\export\_" + safeName(pkg.Name) + "\_" +
stamp + ".xlsx";

var xl = new ActiveXObject("Excel.Application");

xl.Visible = false;

var wb = xl.Workbooks.Add();

var ws = wb.ActiveSheet;

ws.Name = "Elements";

// Header

ws.Cells(1,1).Value = "ElementID";

ws.Cells(1,2).Value = "GUID";

ws.Cells(1,3).Value = "Name";

ws.Cells(1,4).Value = "Type";

ws.Cells(1,5).Value = "Stereotype";

var r = 2;

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++, r++) {

var e = els.GetAt(i);

ws.Cells(r,1).Value = e.ElementID;

ws.Cells(r,2).Value = e.ElementGUID;

ws.Cells(r,3).Value = e.Name;

ws.Cells(r,4).Value = e.Type;

ws.Cells(r,5).Value = String(e.Stereotype\|\|"");

}

// Autosize

ws.Columns.AutoFit();

// Save and clean up

wb.SaveAs(filePath);

wb.Close(false);

xl.Quit();

wb = null; ws = null; xl = null; // release COM references

log(TAB, "Excel written → " + filePath);

}

function safeName(s){ return
String(s\|\|"").replace(/\[^A-Za-z0-9\_\]+/g,"\_"); }

main();

**Note**: Reading **from** Excel in JScript is also possible (open
workbook, loop rows until blank). For reliability and parsing
complexity, prefer CSV for imports, or use the Python importer below.

### JSON Pipelines

**Why JSON?** It’s friendly to automation and works nicely in Git. EA’s
internal JScript has no JSON parser, so we recommend: **export JSON
inside EA**, **import JSON externally** (Python).

**Export JSON (simple structure) inside EA**

// -------------------------------------------------------

// Example 9.4 - ExportJSON_Package.js – JScript (ES3)

// Purpose: Export selected package elements to a JSON file

// Usage: Select a package → run script → pick output folder

// Notes: JScript has no JSON.stringify, so we build JSON manually.

// Keep values escaped and simple.

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "ExportJSON";

ensureOutputTab(TAB);

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var outDir = browseForFolder("Select output folder (JSON)");

if (!outDir) { log(TAB, "Cancelled."); return; }

var stamp = (new Date()).getTime();

var path = outDir + "\\export\_" + safeName(pkg.Name) + "\_" + stamp +
".json";

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = fso.OpenTextFile(path, 2, true); // 2=ForWriting

file.WriteLine("\[");

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var line = " {" +

"\\elementId\\:" + e.ElementID + "," +

"\\guid\\:\\" + jsonEscape(e.ElementGUID) + "\\," +

"\\name\\:\\" + jsonEscape(e.Name) + "\\," +

"\\type\\:\\" + jsonEscape(e.Type) + "\\," +

"\\stereotype\\:\\" + jsonEscape(String(e.Stereotype\|\|"")) + "\\" +

"}";

if (i \< els.Count-1) line += ",";

file.WriteLine(line);

}

file.WriteLine("\]");

file.Close();

log(TAB, "JSON written → " + path);

}

function jsonEscape(s){ s=String(s\|\|""); return
s.replace(/\\/g,"\\\\").replace(/"/g,'\\"'); }

function safeName(s){ return
String(s\|\|"").replace(/\[^A-Za-z0-9\_\]+/g,"\_"); }

main();

### Import JSON externally (Python)

This importer:

- Tries **GUID** first (GetElementByGuid/GetElementByGUID).

- Falls back to **name + type within a package** (to avoid dupes).

- Creates new elements if missing *(note: EA does not let you set GUIDs
  via API; new elements get new GUIDs—store a mapping if you need
  cross-walks)*.

\# -------------------------------------------------------

\# Example 9.5 - import_json_into_ea.py – Python 3 (pywin32)

\# Purpose: Import elements from JSON into a target package

\# Usage: python import_json_into_ea.py "C:\\..\export_Package_123.json"
1234

\# where 1234 is the target PackageID in EA

\# Safety:

\# - Avoid duplicates by GUID first, else by (name,type,package)

\# - Log new GUIDs so you can maintain a cross-walk

\# -------------------------------------------------------

import sys, json, win32com.client

def find_by_name_type(pkg, name, etype):

els = pkg.Elements

for i in range(els.Count):

e = els.GetAt(i)

if e.Name == name and e.Type == etype:

return e

return None

def main():

if len(sys.argv) \< 3:

print("Usage: import_json_into_ea.py \<json_path\>
\<target_package_id\>")

return

json_path = sys.argv\[1\]

target_pkg_id = int(sys.argv\[2\])

ea = win32com.client.Dispatch("EA.App")

repo = ea.Repository

pkg = repo.GetPackageByID(target_pkg_id)

if not pkg:

print("Target package not found:", target_pkg_id); return

data = json.load(open(json_path, "r"))

created, updated = 0, 0

for item in data:

guid = item.get("guid","")

name = item.get("name","")

etype= item.get("type","Class")

stereo=item.get("stereotype","")

el = None

if guid:

try:

el = repo.GetElementByGuid(guid) \# newer EA

except:

try:

el = repo.GetElementByGUID(guid) \# older EA

except:

el = None

if not el:

el = find_by_name_type(pkg, name, etype)

if not el:

el = pkg.Elements.AddNew(name, etype)

el.Stereotype = stereo

el.Update()

created += 1

\# NOTE: el.ElementGUID is NEW and cannot be set via API.

print(f"Created: {name} ({etype}) NEW_GUID={el.ElementGUID}")

else:

dirty = False

if stereo and el.Stereotype != stereo:

el.Stereotype = stereo; dirty = True

if dirty:

el.Update(); updated += 1

if created or updated:

repo.RefreshModelView(pkg.PackageID)

print(f"Done. Created={created}, Updated={updated}")

if \_\_name\_\_ == "\_\_main\_\_":

main()

**GUID reality check**: EA’s API exposes ElementGUID but does **not**
let you set it for new elements. If you must preserve GUIDs from an
external master, consider **XMI import** or EA’s native importers.
Otherwise, store a **cross-walk CSV** of {external_id → EA GUID} after
creation.

## Managing GUIDs & Avoiding Duplicates

**Best-practice order of matching:**

- **GUID** (strongest identity) → GetElementByGUID/GetElementByGuid.

- **Stable external key** (your own code) if you maintain one as a
  tagged value, e.g., ExternalID.

- **Name + Type + Package** (weaker; beware rename collisions).

**For new items:**

- You cannot set EA GUIDs via API; EA assigns them.

- Immediately log {externalKey → new EA GUID} to a CSV so future updates
  can target the same element.

**Avoiding duplicates:**

- Before creating, **search for existing** by GUID or external key.

- If you must use name/type, scope the search to the target package (or
  run an **SQLQuery** to check repository-wide).

- Build imports as **two-phase**: curate first, then apply, so humans
  can resolve ambiguous matches.

## Scaling Up (Performance)

- Use **SQL for finding**, **API for writing** (Pattern 5 in Chapter 6).

- Batch large updates (e.g., 250 elements) and refresh the UI at the
  end.

- Keep logs: write a CSV of every change (old → new).

**Example**: fast existence check before creating

// -------------------------------------------------------

// Example 9.6 - ExistsByNameType_SQL.js – JScript (ES3)

// Purpose: Repository-wide check if (Name,Type) exists; returns first
Object_ID

// Notes: SQLQuery returns XML; we do a tiny string parse

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function existsByNameType(name, type) {

var sql = "SELECT TOP 1 Object_ID FROM t_object WHERE Name='" +
esc(name) +

"' AND Object_Type='" + esc(type) + "'";

var xml = Repository.SQLQuery(sql);

var id = between(xml, "\<Object_ID\>", "\</Object_ID\>");

return id ? parseInt(id,10) : 0;

}

function esc(s){ return String(s\|\|"").replace(/'/g,"''"); }

function between(h, a, b){ var i=h.indexOf(a); if(i\<0) return ""; var
j=h.indexOf(b,i+a.length); return j\<0?"":h.substring(i+a.length,j); }

## Safety Checklist

- **Dry-run first** (or export-curate-apply).

- **Back up** repositories (or work on a copy).

- **Log everything** (CSV with old/new values).

- **Update()** every modified object; **RefreshModelView()** to show
  changes.

- Prefer **CSV/JSON for input**, Excel only when required.

- For rich parsing, do it **externally** (Python) and keep in-EA scripts
  small and safe.

## What to use when

- Quick exports for review → CSV export (8.1.1).

- Curated updates → CSV apply (8.1.2) or Python CSV/JSON importer
  (8.3.2).

- Stakeholder-friendly spreadsheet → Excel export (8.2.1).

- Dev pipelines / Git → JSON export (8.3.1) + Python importer (8.3.2).

- Strong identity → prefer GUIDs or your own ExternalID tagged value.

# Chapter 10: MDG-Aware Scripting

By now, we’ve looked at the essentials of EA scripting, design patterns,
and the mechanics of importing and exporting. But Enterprise Architect
is more than just a generic UML tool. Its true power lies in **MDG
Technologies** (Model Driven Generation). MDGs extend EA with
domain-specific languages, toolboxes, and stereotypes that tailor the
tool to specific contexts: ArchiMate, BPMN, SysML, TOGAF, and countless
custom frameworks.

For script authors, MDGs present both opportunities and challenges. On
one hand, they give structure — a controlled set of stereotypes, tagged
values, and toolboxes. On the other hand, they introduce complexity —
multiple profiles, extended stereotypes, and hidden differences between
what the GUI shows and what the API actually stores.

This chapter explores how to make your scripts **MDG-aware**. It
explains what MDGs are, how stereotypes and tagged values are defined,
why you must use StereotypeEx instead of Stereotype, and how to validate
models against MDG definitions. Without MDG awareness, your scripts may
appear to work but silently misalign with the modelling framework your
organisation depends on. With MDG awareness, your scripts become
governance tools that reinforce standards and prevent drift.

## What Are MDGs?

MDG Technologies are EA’s mechanism for packaging modelling extensions.
They define:

- **Stereotypes**: specialisations of UML element types (e.g., ArchiMate
  ApplicationComponent).

- **Toolboxes**: palettes of elements and connectors available to
  modellers.

- **Tagged Values**: metadata fields automatically attached to
  stereotyped elements.

- **Profiles and MetaModels**: rules about what elements and connectors
  can be created.

An MDG is essentially a bundle that turns EA from a generic modelling
tool into a domain-specific environment.

## Why MDGs Matter for Scripting

When you script EA, you are not usually working with plain UML classes
or components. You are working with **stereotyped elements defined by
MDGs**. For example, if you are automating ArchiMate models, your script
needs to distinguish ApplicationComponents from BusinessActors. If you
are automating BPMN, you need to treat Tasks, Gateways, and Events
differently.

Scripts that ignore MDGs risk breaking models. A script might rename or
move elements without preserving stereotypes. Or it might overwrite a
stereotype by writing to Element.Stereotype instead of
Element.StereotypeEx. These mistakes create elements that look right in
the Project Browser but misbehave in diagrams or reports.

## Important Tips

### The Stereotype vs. StereotypeEx Trap

One of the most notorious pitfalls in EA scripting is the difference
between Stereotype and StereotypeEx.

- **Stereotype** returns only the primary stereotype string, stripped of
  profile information.

- **StereotypeEx** returns the fully qualified stereotype, including the
  profile (profile::stereotype).

If you rely on Stereotype, your script may confuse two stereotypes with
the same name from different profiles. Worse, if you set Stereotype, you
may erase MDG metadata.

The safe rule is: **always use StereotypeEx** when working with MDG
stereotypes.

### Tagged Value Definitions

MDGs often define tagged values that attach automatically to elements
with a given stereotype. For example, an ArchiMate ApplicationComponent
may come with tagged values like “Layer” or “Technology.”

Scripts must handle these tagged values carefully. You should:

- Check if the tag exists before adding a new one.

- Use the correct tag names from the MDG definition.

- Avoid overwriting tags with unexpected values.

Proper handling ensures your automation works with, not against, the
MDG.

### Toolboxes and Element Creation

When creating elements via script, it’s important to align with MDG
toolboxes. If your organisation uses a custom MDG that defines “Business
Capability” as MyProfile::Capability, then your script must create
elements with that stereotype. Creating a plain UML Class and renaming
it “Capability” will cause confusion.

The safe pattern is to:

- Identify the correct stereotype from the MDG.

- Use Elements.AddNew(name, baseType) followed by StereotypeEx =
  "profile::stereo".

- Call Update() and RefreshModelView().

### Validating MDG Usage

MDG-aware scripting isn’t only about creating elements correctly. It’s
also about validating existing models. Common checks include:

- Elements of stereotype X must have certain tagged values populated.

- Connectors of type Y may only connect specific element types.

- Packages must only contain elements from an approved toolbox.

By writing MDG-aware validation scripts, you can enforce compliance and
prevent “model drift” where users create incorrect structures.

### When MDGs Change

Another challenge is that MDGs evolve. Stereotypes may be renamed,
tagged values may be added, or toolboxes reorganised. Scripts must be
robust to such changes. That means:

- Avoid hardcoding stereotypes wherever possible — use configuration
  files or central mappings.

- Log when unknown stereotypes are encountered.

- Keep scripts version-controlled and updated alongside MDG changes.

## MDGs in External Automation

Everything we’ve said so far applies inside EA’s scripting engine, but
it also applies in external automation. If you are pulling EA content
into Python or C#, you still need to handle stereotypes correctly. That
means reading StereotypeEx, exporting tagged values, and mapping them to
your enterprise data models.

In fact, external automation often makes MDG handling easier because you
can use richer libraries (YAML, JSON) to store stereotype/tag mappings.

## Safety and Governance

MDG-aware scripting is not just a technical detail. It is a matter of
governance. In large organisations, MDGs embody agreed standards: what
modelling constructs are allowed, how they are tagged, and how they
interrelate. Scripts that respect MDGs reinforce governance. Scripts
that ignore them undermine it.

By making scripts MDG-aware, you align automation with enterprise
architecture frameworks, regulatory requirements, and industry
standards.

## Examples 

### Stereotypes 101 (MDG-aware)

- **Element.Stereotype**: the “plain” stereotype string (often just the
  short name).

- **Element.StereotypeEx**: the **fully-qualified** list (may contain
  profile::stereotype, comma-separated).

- **Multiple stereotypes**: use StereotypeEx.

- **Best practice**: when working with MDGs, **set and test against
  StereotypeEx** with the profile::stereo form.

// -------------------------------------------------------

// Example 10.1 - MDG_ApplyStereotype.js – JScript (ES3)

// Purpose: Ensure elements in the selected package have a specific MDG
stereotype

// Notes:

// - Uses profile::stereotype form via StereotypeEx

// - Safe by default with DRY_RUN flag

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

function main() {

var TAB = "MDG_ApplyStereo";

ensureOutputTab(TAB);

// ---- Config ----

var DRY_RUN = true; // switch to false to commit

var PROFILE = "MyProfile"; // MDG profile name

var STEREO = "BusinessCapability"; // Stereotype short name

var FQ = PROFILE + "::" + STEREO; // fully-qualified

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a target package.", promptOK);
return; }

var els = pkg.Elements, changed = 0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

// Skip non-matching base types if you want (e.g., only Classes)

// if (e.Type != "Class") continue;

if (!hasFQStereotype(e, FQ)) {

log(TAB, "Apply stereotype to '" + e.Name + "': " + FQ);

if (!DRY_RUN) {

// Add (or replace) StereotypeEx preserving any existing ones

e.StereotypeEx = addFQStereotype(e.StereotypeEx, FQ);

e.Update();

}

changed++;

}

}

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(pkg.PackageID);

log(TAB, "Updated " + changed + " element(s). Dry-run=" + DRY_RUN);

}

function hasFQStereotype(e, fq) {

var list = String(e.StereotypeEx\|\|"");

// simple token check; EA uses comma-separated list

var items = list.split(",");

for (var i=0; i\<items.length; i++) {

if (equalsIgnoreCase(trim(items\[i\]), fq)) return true;

}

return false;

}

function addFQStereotype(current, fq) {

current = String(current\|\|"").trim();

if (current === "") return fq;

// Avoid dupes

var items = current.split(","), i;

for (i=0; i\<items.length; i++) {

if (equalsIgnoreCase(trim(items\[i\]), fq)) return current;

}

return current + "," + fq;

}

main();

### Tagged Value Definitions (MDG-driven)

MDGs typically define tagged value **types** (lists, refs, memo) and
**required** tags per stereotype. From scripts you usually don’t read
MDG metadata directly; instead you **encode your project’s rules** in a
small configuration map and then **enforce** those rules.

// -------------------------------------------------------

// Example 10.2 - MDG_Rulebook.js – JScript (ES3)

// Purpose: Central config for your MDG validation/repair scripts

// Notes: Express stereotypes fully-qualified as PROFILE::STEREO

// -------------------------------------------------------

var MDG_RULES = {

"MyProfile::BusinessCapability": {

baseType: "Class", // optional; skip other base types

requiredTags: \[

{ name: "Owner", defaultValue: "ArchitectureTeam" },

{ name: "Lifecycle", defaultValue: "Active" },

{ name: "ExternalID", defaultValue: "" } // leave blank; must be filled
by users/imports

\],

namePrefix: "BC\_" // optional naming convention

},

"MyProfile::ApplicationService": {

baseType: "Class",

requiredTags: \[

{ name: "Owner", defaultValue: "AppTeam" },

{ name: "Criticality", defaultValue: "Medium" }

\],

namePrefix: "AS\_"

}

};

Keep this in one place (e.g., \_Common.MDG_Rulebook) and !INC it in
validator and repair scripts.

### MDG Validator (report-only)

This script reports deviations: wrong/missing stereotype, missing tags,
blank required values, naming violations. It **never writes**; use it in
governance jobs and daily hygiene.

// -------------------------------------------------------

// Example 10.3 - MDG_Lint.js – JScript (ES3)

// Purpose: Report MDG violations for elements in selected package
(read-only)

// Output: Output tab + CSV (directory-only chooser)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

!INC \_Common.MDG_Rulebook

function main() {

var TAB = "MDG_Lint";

ensureOutputTab(TAB);

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package to lint.", promptOK);
return; }

var outDir = browseForFolder("Select output folder for MDG lint
report");

var csv = null;

if (outDir) {

var stamp = (new Date()).getTime();

csv = new CsvWriter(outDir + "\\mdg_lint\_" + stamp + ".csv");

csv.writeHeader("ElementID,GUID,Name,Type,AppliedStereotypes,Issue,Details,ExpectedProfileStereo");

}

var els = pkg.Elements, issues=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var applied = String(e.StereotypeEx\|\|"");

var expectedFQ = pickRuleKey(e, applied); // finds the rule, if any

if (!expectedFQ) continue; // element not in scope of our rulebook

var rule = MDG_RULES\[expectedFQ\];

// 1) Base type check (optional)

if (rule.baseType && rule.baseType != e.Type) {

issues += emit(csv, e, applied, "BaseTypeMismatch", "Expected base type
"+rule.baseType, expectedFQ);

continue; // don’t check tags if base type is wrong

}

// 2) Stereotype check

if (!hasFQStereo(applied, expectedFQ)) {

issues += emit(csv, e, applied, "MissingStereotype", "Apply
"+expectedFQ, expectedFQ);

}

// 3) Required tags

for (var t=0; t\<rule.requiredTags.length; t++) {

var tn = rule.requiredTags\[t\].name;

var tv = readTag(e, tn);

if (trim(tv) === "") {

issues += emit(csv, e, applied, "MissingTag", "Tag '"+tn+"' is
required", expectedFQ);

}

}

// 4) Naming convention (optional)

if (rule.namePrefix && !startsWith(e.Name, rule.namePrefix)) {

issues += emit(csv, e, applied, "NamePrefix", "Should start with
'"+rule.namePrefix+"'", expectedFQ);

}

}

if (csv) csv.close();

log(TAB, "MDG lint complete. Issues: " + issues);

}

function pickRuleKey(e, appliedList) {

// Strategy:

// - If any rule key is present in StereotypeEx, prefer it.

// - Else if base type matches exactly one rule, use that rule for
“expected” check.

var keys = keysOf(MDG_RULES);

// prefer explicit match

for (var i=0; i\<keys.length; i++) {

if (hasFQStereo(appliedList, keys\[i\])) return keys\[i\];

}

// fallback: base type inference if unambiguous

var chosen=null;

for (i=0; i\<keys.length; i++) {

var r = MDG_RULES\[keys\[i\]\];

if (r.baseType && r.baseType == e.Type) {

if (chosen && chosen != keys\[i\]) return null; // ambiguous

chosen = keys\[i\];

}

}

return chosen;

}

function hasFQStereo(applied, fq) {

var items = String(applied\|\|"").split(",");

for (var i=0; i\<items.length; i++) {

if (equalsIgnoreCase(trim(items\[i\]), fq)) return true;

}

return false;

}

function readTag(e, name) {

var tvs = e.TaggedValues;

for (var i=0; i\<tvs.Count; i++) {

var tv = tvs.GetAt(i);

if (equalsIgnoreCase(tv.Name, name)) return String(tv.Value\|\|"");

}

return "";

}

function emit(csv, e, applied, issue, details, expected) {

var line = e.ElementID + " " + e.Name + " – " + issue + ": " + details;

log("MDG_Lint", line);

if (csv) csv.writeRow(\[e.ElementID, e.ElementGUID, e.Name, e.Type,
applied, issue, details, expected\|\|""\]);

return 1;

}

function keysOf(o){ var r=\[\],k; for(k in o){ if(o.hasOwnProperty(k))
r.push(k);} return r; }

main();

### MDG Repair (guided and safe)

This companion script **fixes** the issues reported by the linter. It
uses a **dry-run** flag and writes a CSV log of every attempted change.

// -------------------------------------------------------

// Example 10.4 - MDG_Repair.js – JScript (ES3)

// Purpose: Apply MDG fixes (stereotype, required tags, naming prefix)

// Safety: DRY_RUN=true by default; logs every change

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

!INC \_Common.MDG_Rulebook

function main() {

var TAB = "MDG_Repair";

ensureOutputTab(TAB);

// ---- Config ----

var DRY_RUN = true;

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var outDir = browseForFolder("Select output folder for MDG repair log");

var csv = null;

if (outDir) {

var stamp = (new Date()).getTime();

csv = new CsvWriter(outDir + "\\mdg_repair\_" + stamp + ".csv");

csv.writeHeader("Action,ElementID,GUID,Name,Details");

}

var els = pkg.Elements, changed=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var expectedFQ = pickRuleKey(e, String(e.StereotypeEx\|\|""));

if (!expectedFQ) continue;

var rule = MDG_RULES\[expectedFQ\];

// 1) Enforce stereotype (fully-qualified)

if (!hasFQStereo(String(e.StereotypeEx\|\|""), expectedFQ)) {

log(TAB, "Apply stereotype: " + expectedFQ + " on '" + e.Name + "'");

if (csv) csv.writeRow(\["ApplyStereo", e.ElementID, e.ElementGUID,
e.Name, expectedFQ\]);

if (!DRY_RUN) { e.StereotypeEx = addFQStereo(e.StereotypeEx,
expectedFQ); e.Update(); changed++; }

}

// 2) Ensure required tags (create if missing, fill default if blank)

for (var t=0; t\<rule.requiredTags.length; t++) {

var tn = rule.requiredTags\[t\].name;

var dv = String(rule.requiredTags\[t\].defaultValue\|\|"");

var cur = readTag(e, tn);

if (trim(cur) === "" && dv !== "") {

log(TAB, "Set tag '" + tn + "'='" + dv + "' on '" + e.Name + "'");

if (csv) csv.writeRow(\["SetTag", e.ElementID, e.ElementGUID, e.Name,
tn+"="+dv\]);

if (!DRY_RUN) { writeTag(e, tn, dv); changed++; }

} else if (cur === "") {

// missing and no default → warn only

if (csv) csv.writeRow(\["MissingTag", e.ElementID, e.ElementGUID,
e.Name, tn+" (no default)"\]);

}

}

// 3) Naming prefix (optional)

if (rule.namePrefix && !startsWith(e.Name, rule.namePrefix)) {

var newName = rule.namePrefix + e.Name;

log(TAB, "Rename '" + e.Name + "' → '" + newName + "'");

if (csv) csv.writeRow(\["Rename", e.ElementID, e.ElementGUID, e.Name, "→
"+newName\]);

if (!DRY_RUN) { e.Name = newName; e.Update(); changed++; }

}

}

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(pkg.PackageID);

log(TAB, "Repair complete. Changes=" + changed + ", Dry-run=" +
DRY_RUN);

}

// Helpers (subset specialised for this script)

function pickRuleKey(e, applied){ var keys=keysOf(MDG_RULES); var i;

for(i=0;i\<keys.length;i++) if(hasFQStereo(applied, keys\[i\])) return
keys\[i\];

// optional baseType inference

var chosen=null; for(i=0;i\<keys.length;i++){ var
r=MDG_RULES\[keys\[i\]\]; if(r.baseType && r.baseType==e.Type){
if(chosen && chosen!=keys\[i\]) return null; chosen=keys\[i\]; } }

return chosen;

}

function hasFQStereo(applied, fq){ var
items=String(applied\|\|"").split(","); for(var
i=0;i\<items.length;i++){ if(equalsIgnoreCase(trim(items\[i\]),fq))
return true; } return false;}

function addFQStereo(current, fq){ current=String(current\|\|"").trim();
if(current==="") return fq; var items=current.split(","),i;
for(i=0;i\<items.length;i++){ if(equalsIgnoreCase(trim(items\[i\]),fq))
return current; } return current + "," + fq;}

function readTag(e, name){ var tvs=e.TaggedValues; for(var
i=0;i\<tvs.Count;i++){ var tv=tvs.GetAt(i);
if(equalsIgnoreCase(tv.Name,name)) return String(tv.Value\|\|""); }
return ""; }

function writeTag(e, name, value){ var tvs=e.TaggedValues, i;
for(i=0;i\<tvs.Count;i++){ var tv=tvs.GetAt(i);
if(equalsIgnoreCase(tv.Name,name)){ tv.Value=String(value); tv.Update();
e.Update(); return; } } var nt=tvs.AddNew(name,String(value));
nt.Update(); e.Update(); }

function keysOf(o){ var r=\[\],k; for(k in o){ if(o.hasOwnProperty(k))
r.push(k);} return r; }

main();

### Validating toolbox conformance (lightweight)

You usually enforce toolbox usage **indirectly**:

- **Base type** matches your profile expectation (e.g., Class).

- **Stereotype** is the one from your profile (profile::stereo).

- **Required tags** exist (often defined by your MDG).

If all three pass, the modeller effectively used your toolbox.

For stricter checks, you can augment the rulebook with **allowed
connector types** and **required relationships** per stereotype, then
lint them the same way.

// Example 10.5 - Add to MDG_RULES:

"MyProfile::BusinessCapability": {

baseType: "Class",

requiredTags: \[{name:"Owner", defaultValue:"ArchitectureTeam"}\],

namePrefix: "BC\_",

requiresOutgoing: \[ { type:"Realization",
toStereo:"MyProfile::ApplicationService" } \]

}

Then in your linter:

// After tag checks:

if (rule.requiresOutgoing) {

for (var r=0; r\<rule.requiresOutgoing.length; r++) {

var req = rule.requiresOutgoing\[r\];

if (!hasOutgoing(e, req.type, req.toStereo)) {

issues += emit(csv, e, applied, "MissingLink",

"Require outgoing " + req.type + " to " + req.toStereo, expectedFQ);

}

}

}

function hasOutgoing(e, connType, toFQStereo){

var cons = e.Connectors;

for (var i=0; i\<cons.Count; i++) {

var c = cons.GetAt(i);

if (c.Type != connType) continue;

var supplier = Repository.GetElementByID(c.SupplierID);

if (!supplier) continue;

if (hasFQStereo(String(supplier.StereotypeEx\|\|""), toFQStereo)) return
true;

}

return false;

}

### Bulk discovery using SQL (fast find, safe check)

On very large repositories, **find with SQL** then verify via the API.

// -------------------------------------------------------

// Example 10.6 - MDG_SQL_FindMissingTag.js – JScript (ES3)

// Purpose: Pre-filter candidates with SQL, then verify with API

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

!INC \_Common.Helpers

!INC \_Common.MDG_Rulebook

function main() {

var TAB="MDG_SQL_Find";

ensureOutputTab(TAB);

var key = "MyProfile::BusinessCapability";

var rule = MDG_RULES\[key\];

var tagName = "Owner";

// Fast repo-wide prefilter: base type & stereotype absent or wrong
(rough)

// NOTE: Stereotypes are stored in multiple places; we prefilter by type
and post-check StereotypeEx via API.

var sql = "SELECT Object_ID FROM t_object WHERE Object_Type='" +
rule.baseType + "'";

var xml = Repository.SQLQuery(sql);

var ids = extractAll(xml, "\<Object_ID\>", "\</Object_ID\>");

var offenders = 0;

for (var i=0; i\<ids.length; i++) {

var el = Repository.GetElementByID(parseInt(ids\[i\],10));

if (!el) continue;

if (!hasFQ(String(el.StereotypeEx\|\|""), key)) continue; // truly in
scope

var tv = readTag(el, tagName);

if (trim(tv) === "") {

offenders++;

Session.Output("Missing tag '" + tagName + "': " + el.Name + " (" +
el.ElementID + ")");

}

}

log(TAB, "Offenders (missing "+tagName+"): " + offenders);

}

function extractAll(h,a,b){ var r=\[\],s=0; while(true){ var
i=h.indexOf(a,s); if(i\<0) break; var j=h.indexOf(b,i+a.length);
if(j\<0) break; r.push(h.substring(i+a.length,j)); s=j+b.length; }
return r; }

function hasFQ(applied,fq){ var arr=String(applied\|\|"").split(",");
for(var i=0;i\<arr.length;i++){ if(equalsIgnoreCase(trim(arr\[i\]),fq))
return true; } return false; }

function readTag(e,n){ var tvs=e.TaggedValues; for(var
i=0;i\<tvs.Count;i++){ var t=tvs.GetAt(i);
if(equalsIgnoreCase(t.Name,n)) return String(t.Value\|\|""); } return
""; }

main();

## Safety & governance notes

- Always prefer StereotypeEx for MDG accuracy.

- Never raw-update MDG metadata in EA tables unless you absolutely must
  (and then only when you fully understand the schema).

- Centralise rules in a small “rulebook” map; your linter and repairer
  both use it.

- Dry-run first and log CSVs of changes for audit.

- Use SQL to find, API to fix at scale.

## What to use when (cheat-sheet)

- **Apply a profile stereotype** to many items → Example 9.1.

- **Report MDG drift** (tags/names/stereos) → Example 9.3 (linter).

- **Fix drift** with defaults and renaming → Example 9.4 (repairer).

- **Enforce relationships** between MDG types → 9.5 extension.

- **Huge repositories** → 9.6 SQL pre-filter + API verification.

# Chapter 11: Governance Scripts

Governance is one of the most important and least glamorous aspects of
modelling. It is the quiet discipline that ensures models remain
trustworthy, consistent, and usable over time. Without governance,
repositories decay. Naming conventions drift, orphaned elements
accumulate, stereotypes are misapplied, and diagrams no longer reflect
reality. A model that begins as a clear architectural guide slowly
becomes a jungle of inconsistencies, and eventually stakeholders stop
trusting it.

Enterprise Architect provides some built-in validation features, but
governance at scale requires automation. This is where **governance
scripts** come in. They act as model guardians: scanning repositories
for violations, enforcing standards, and generating objective reports on
quality. They take subjective debates about “style” and turn them into
automated checks that either pass or fail. In doing so, they transform
governance from a painful, manual process into a manageable and
repeatable workflow.

This chapter introduces the concept of governance scripts. It explains
why governance matters, what kinds of issues can be checked, how
automation changes the governance process, and why scripting is uniquely
suited to this role. It also emphasises the importance of balance:
governance should not be punitive or bureaucratic, but enabling — a way
to help modellers do good work with confidence.

## Why Governance Matters

Models are living artefacts. They are updated by many people over months
or years. Left unchecked, even small deviations accumulate into serious
problems:

- Inconsistent naming makes elements hard to find.

- Missing tags leave models unfit for analysis.

- Incorrect connectors break traceability.

- Duplicated elements cause confusion in reports.

- Orphaned elements give the illusion of coverage but no actual linkage.

Governance provides the antidote. It ensures the model remains a
reliable foundation for decision-making, documentation, and integration
with other tools.

## The Pain of Manual Governance

Traditionally, governance has been manual: reviewers inspect models,
checklists are filled in, and corrective actions assigned. This is slow,
subjective, and demoralising. Architects end up spending more time
policing modellers than doing architecture. Reviewers argue about style
rather than substance. And problems are often caught late, when
correcting them is expensive.

Manual governance is also inconsistent. Different reviewers may apply
different standards, leading to confusion and resentment. The result is
often governance fatigue: modellers stop caring, reviewers stop
enforcing, and quality slides.

### The Case for Automation

Scripting changes the dynamic completely. With governance scripts,
checks are automated, repeatable, and objective. A script does not get
tired, bored, or inconsistent. It simply scans the repository and
reports results.

Benefits include:

- **Speed**: thousands of elements can be checked in seconds.

- **Objectivity**: standards are enforced consistently.

- **Transparency**: logs show exactly what passed and failed.

- **Scalability**: large repositories can be governed without
  multiplying staff effort.

Automated governance also changes culture. Instead of governance being
seen as policing, it becomes part of normal workflow. Modellers can run
scripts themselves before committing changes, catching issues early.

### What Governance Scripts Check

Governance scripts can cover many aspects of model quality. Common
categories include:

- **Naming conventions**: e.g., requirements must start with REQ\_,
  capabilities with BC\_.

- **Stereotype compliance**: only approved stereotypes may be used.

- **Tagged value completeness**: certain tags must exist and be
  populated.

- **Connector rules**: e.g., only ApplicationComponents may realise
  Capabilities.

- **Model smells**: orphaned elements, duplicate names, unused diagrams.

- **Coverage checks**: every requirement must trace to a capability,
  every component to a service.

These checks can be run as reports or as enforcement scripts that
auto-correct issues.

### From Policing to Enablement

One danger of governance automation is that it can become heavy-handed:
modellers feel constrained and demotivated. The key is to frame
governance as **enablement, not punishment**. Scripts are there to help,
not hinder.

For example:

- A script that renames elements automatically to match conventions
  saves modellers time.

- A script that adds missing tags reduces manual entry.

- A script that reports orphans gives clear guidance for cleanup.

When governance scripts are seen as helpers, adoption increases.

### Governance as Quality Assurance

Governance is not separate from quality; it is quality assurance for
models. Just as code is tested by unit tests and static analysis, models
should be tested by governance scripts. This analogy is powerful:
modellers begin to see governance not as red tape but as the modelling
equivalent of running tests. Passing governance checks means your model
is ready for use.

### Levels of Governance

Governance can be applied at different levels:

- **Local**: a modeller runs a script on their package before
  publishing.

- **Team**: governance scripts are run during reviews or milestones.

- **Enterprise**: scheduled jobs scan the whole repository and produce
  dashboards.

Scripting supports all three levels. Internal scripts are ideal for
local checks. External automation can handle enterprise-wide scans and
reporting.

### Reporting and Transparency

The value of governance scripts is not only in enforcement but also in
**reporting**. A script that logs issues to CSV can feed dashboards or
be shared in review meetings. Reports provide evidence of compliance,
useful for audits or regulatory contexts.

Transparency is key: modellers must be able to see why something failed
and how to fix it. A governance report that simply says “non-compliant”
is not helpful. A report that lists exactly which elements are missing
which tags is actionable.

## Governance and MDGs

As Chapter 9 explained, MDGs define the modelling language in use.
Governance scripts must respect MDGs: checking that stereotypes are used
correctly, tags are populated, and connector rules are followed. This
alignment ensures that automation reinforces, rather than undermines,
the MDG.

For example, a governance script for an ArchiMate MDG might check that
every ApplicationComponent has a Layer tag and that only
ApplicationComponents realise Capabilities.

## Examples

### Naming Conventions

// -------------------------------------------------------

// Example 11.2 - Gov_NamingConvention.js – JScript (ES3)

// Purpose: Enforce naming convention "REQ\_" for Requirement elements

// Safety: DRY_RUN = true by default

// Output: Logs violations, optional repair

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function trim(str) {

if (str == null \|\| str == undefined) return "";

return String(str).replace(/^\s+\|\s+\$/g, "");

}

function startsWith(str, prefix) {

return String(str\|\|"").indexOf(prefix) === 0;

}

function main() {

var DRY_RUN = true;

var PREFIX = "REQ\_";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var fixed=0, issues=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Requirement") {

if (!startsWith(e.Name, PREFIX)) {

issues++;

var newName = PREFIX + trim(e.Name);

Session.Output("Naming issue: " + e.Name + " → " + newName);

if (!DRY_RUN) {

e.Name = newName;

e.Update();

fixed++;

}

}

}

}

if (!DRY_RUN && fixed\>0) Repository.RefreshModelView(pkg.PackageID);

Session.Output("Issues=" + issues + " Fixed=" + fixed + " Dry-run=" +
DRY_RUN);

}

main();

### Model Smells

// -------------------------------------------------------

// Example 11.2 - Gov_ModelSmells_Orphans.js – JScript (ES3)

// Purpose: Find elements without any connectors (orphans)

// Output: Report-only

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var orphans=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Connectors.Count == 0) {

orphans++;

Session.Output("Orphan: " + e.Name + " (" + e.Type + ")");

}

}

Session.Output("Total orphans found: " + orphans);

}

main();

### Duplicate Elements

// -------------------------------------------------------

// Example 11.3 - Gov_ModelSmells_Duplicates.js – JScript (ES3)

// Purpose: Report duplicate element names within a package

// Output: Report-only

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var seen = {};

var dups = 0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var name = String(e.Name\|\|"");

if (seen\[name\]) {

Session.Output("Duplicate name: " + name + " (ElementID=" +
e.ElementID + ")");

dups++;

} else {

seen\[name\] = true;

}

}

Session.Output("Duplicate count: " + dups);

}

main();

### Coverage & Traceability

Traceability rules ensure that modelled items are linked correctly
(e.g., each requirement must trace to at least one capability).

// -------------------------------------------------------

// Example 11.4 - Gov_Traceability_Check.js – JScript (ES3)

// Purpose: Verify every Requirement in a package has at least one
Realization link to a Capability

// Safety: Report-only

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var missing=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Requirement") {

var cons = e.Connectors;

var hasTrace = false;

for (var j=0; j\<cons.Count; j++) {

var c = cons.GetAt(j);

if (c.Type == "Realisation" \|\| c.Type == "Realization") {

var target = Repository.GetElementByID(c.SupplierID);

if (target && target.Stereotype == "Capability") {

hasTrace = true;

break;

}

}

}

if (!hasTrace) {

missing++;

Session.Output("Requirement without Capability trace: " + e.Name + "
(ID=" + e.ElementID + ")");

}

}

}

Session.Output("Traceability issues found: " + missing);

}

main();

### Governance Reports (CSV)

For larger models, CSV outputs make governance easier to review.

// -------------------------------------------------------

// Example 11.5 - Gov_ExportViolations.js – JScript (ES3)

// Purpose: Collect naming, orphan, and traceability issues into CSV

// Output: directory-only chooser; filename auto-derived

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function trim(str) {

if (str == null \|\| str == undefined) return "";

return String(str).replace(/^\s+\|\s+\$/g, "");

}

function browseForFolder(promptText) {

var shell = new ActiveXObject("Shell.Application");

var folder = shell.BrowseForFolder(0, promptText, 0, 0);

return folder ? folder.Self.Path : null;

}

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var outDir = browseForFolder("Select output folder for governance CSV");

if (!outDir) return;

var fso = new ActiveXObject("Scripting.FileSystemObject");

var stamp = (new Date()).getTime();

var path = outDir + "\\governance_report\_" + stamp + ".csv";

var file = fso.CreateTextFile(path, true);

file.WriteLine("IssueType,ElementID,Name,Details");

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

// Naming check

if (e.Type == "Requirement" && !startsWith(e.Name, "REQ\_")) {

file.WriteLine("Naming,"+e.ElementID+","+e.Name+",Missing REQ\_
prefix");

}

// Orphan check

if (e.Connectors.Count == 0) {

file.WriteLine("Orphan,"+e.ElementID+","+e.Name+",No connectors");

}

// Traceability check

if (e.Type == "Requirement" && !hasCapabilityTrace(e)) {

file.WriteLine("Traceability,"+e.ElementID+","+e.Name+",No Capability
trace");

}

}

file.Close();

Session.Output("Governance report written → " + path);

}

function startsWith(str, prefix) {

return String(str\|\|"").indexOf(prefix) === 0;

}

function hasCapabilityTrace(e) {

var cons = e.Connectors;

for (var j=0; j\<cons.Count; j++) {

var c = cons.GetAt(j);

if (c.Type == "Realisation" \|\| c.Type == "Realization") {

var target = Repository.GetElementByID(c.SupplierID);

if (target && target.Stereotype == "Capability") return true;

}

}

return false;

}

main();

## Summary

Governance scripts are simple but powerful. They let you:

- Enforce naming standards (Example 10.1).

- Detect structural smells like orphans and duplicates (Examples 10.2 &
  10.3).

- Check coverage and traceability (Example 10.4).

- Export reports for human review (Example 10.5).

Together, these create a **living quality gate** for your repository —
fast, repeatable, and objective.

# Chapter 12: Cookbook of Examples

After learning the essentials of EA scripting, exploring design
patterns, and examining governance automation, you are ready for a
different kind of resource: a **cookbook**. This chapter serves as a
library of practical scripts — small, focused recipes that solve common
problems.

Why a cookbook? Because most architects and modellers do not want to
read abstract descriptions of APIs or design principles when they are
under pressure to deliver. They want to grab a working example, tweak a
few lines, and get results. A cookbook provides exactly that: practical,
runnable scripts that cover the typical scenarios you will encounter in
everyday work with Enterprise Architect.

This introduction explains how to use the cookbook effectively, why
examples are powerful learning tools, what safety precautions to take,
and how to adapt recipes to your organisation’s context.

## The Value of Worked Examples

Learning by example is one of the fastest ways to acquire scripting
skills. You see the structure of a script, copy it, run it, and modify
it. Each time you adapt an example, you internalise a little more of the
API. Over time, the examples stop being magic incantations and start
becoming familiar patterns.

This mirrors how many people learn to cook. Few start by reading
chemistry textbooks. They follow recipes, taste the results, and
gradually learn to improvise. A scripting cookbook provides the same
bridge: from passive reading to active doing.

## The Scope of the Cookbook

The examples in this chapter span a wide range of tasks:

- Simple utilities (rename elements, list tagged values).

- Governance checks (enforce naming conventions, detect orphans).

- Import/export helpers (CSV, JSON).

- Diagram utilities (rename objects on diagrams, layout tweaks).

- Advanced recipes (generate XMI, bulk stereotype changes).

Together, these recipes form a library you can draw on again and again.

## Why Not Just Copy from the Internet?

It is true that you can find EA script snippets on forums, blogs, or Q&A
sites. But they are often incomplete, outdated, or written without
safety in mind. Some use direct SQL writes that risk corrupting the
repository. Some assume modern JavaScript features that EA’s JScript
engine does not support.

The difference here is that every recipe in this cookbook is:

- Fully runnable in EA’s script environment.

- Corrected for ES3 constraints.

- Structured with a standard header, dry-run flag, and logging.

- Explained line by line with comments.

This makes them safer and more reliable than random fragments you might
stumble across online.

## Safety First in a Cookbook

Even though these are examples, they still modify repositories. That
means the safety principles of Chapter 3 apply even more strongly here.

Every modifying recipe includes:

- A **DRY_RUN flag** set to true by default.

- **Session.Output** logging for feedback.

- Clear documentation of purpose, assumptions, and usage.

- Where relevant, CSV logging so you can review results.

Your responsibility as a user is to:

1.  Run in dry-run mode first.

2.  Review the logs.

3.  Only then set DRY_RUN = false and rerun.

Used this way, the cookbook is safe and predictable.

## Adapting Recipes to Your Context

No recipe is ever perfect out of the box. Just as you might add more
spice or substitute an ingredient in cooking, you will adapt these
scripts to your organisation’s needs. That might mean:

- Changing the stereotype names to match your MDG.

- Adding extra tagged values.

- Adjusting logging paths to your file system.

- Expanding filters to cover additional element types.

The important thing is that you do not start from zero. You begin with a
working, commented script and adapt it.

## The Teaching Role of Recipes

Examples do more than solve immediate problems. They also teach. By
comparing two recipes, you begin to notice similarities — the same
.Count and .GetAt() loops, the same Update() calls, the same
RefreshModelView(). You start to see the skeleton of the EA API
underneath. This is how cookbook use deepens understanding: repetition
makes the patterns obvious.

## Building a Shared Library

One of the most powerful practices is to build a **shared library of
scripts** for your team. Start with this cookbook, adapt recipes, and
store them in version control (Git). Over time, your organisation
develops its own tailored cookbook, aligned to your MDGs, governance
rules, and workflows. This not only saves time but also enforces
consistency across projects.

## Cookbook Limitations

A cookbook is not a substitute for deeper understanding. If you only
ever copy and paste without comprehension, you risk misuse. That is why
every recipe is heavily commented — to explain not only *what* happens
but *why*. The goal is not just to give you fish but to teach you how to
fish.

## AI and Cookbook Expansion

One interesting modern twist is that AI can generate new recipes on
demand. You might start with a cookbook script and then ask an AI to
adapt it: “Modify this script to export to JSON instead of CSV.”
However, as we saw in earlier chapters, AI often hallucinates. That is
why having a solid cookbook matters: you can use AI to vary a reliable
base, rather than trusting AI to invent code from scratch.

### Rename All Elements in a Package

// -------------------------------------------------------

// Example 12.1 - RenameElements_Prefix.js – JScript (ES3)

// Purpose: Add a prefix to all element names in the selected package

// Assumptions: User selects a package in Project Browser

// Safety: DRY_RUN = true by default

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var PREFIX = "ARCH\_";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package first.", promptOK); return;
}

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Name.indexOf(PREFIX) != 0) {

var newName = PREFIX + e.Name;

Session.Output("Would rename: " + e.Name + " → " + newName);

if (!DRY_RUN) {

e.Name = newName;

e.Update();

}

}

}

if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);

}

main();

### Add a Tagged Value to All Elements

// -------------------------------------------------------

// Example 12.2 - AddTag_AllElements.js – JScript (ES3)

// Purpose: Add or update a tagged value across all elements in a
package

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var TAG_NAME = "Owner";

var TAG_VALUE = "ArchitectureTeam";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var tags = e.TaggedValues;

var found = false;

for (var j=0; j\<tags.Count; j++) {

var t = tags.GetAt(j);

if (t.Name == TAG_NAME) {

found = true;

if (t.Value != TAG_VALUE) {

Session.Output("Update tag for " + e.Name);

if (!DRY_RUN) { t.Value = TAG_VALUE; t.Update(); e.Update(); }

}

}

}

if (!found) {

Session.Output("Add tag for " + e.Name);

if (!DRY_RUN) {

var nt = tags.AddNew(TAG_NAME, TAG_VALUE);

nt.Update(); e.Update();

}

}

}

if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);

}

main();

### Export All Requirements to CSV

// -------------------------------------------------------

// Example 12.3 - ExportRequirements_CSV.js – JScript (ES3)

// Purpose: Write requirement names and notes to CSV

// Output: File written to chosen folder

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var shell = new ActiveXObject("Shell.Application");

var folder = shell.BrowseForFolder(0, "Select output folder", 0, 0);

if (!folder) return;

var dir = folder.Self.Path;

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = fso.CreateTextFile(dir + "\\requirements.csv", true);

file.WriteLine("ID,Name,Notes");

var sql = "SELECT Object_ID, Name, Note FROM t_object WHERE
Object_Type='Requirement'";

var xml = Repository.SQLQuery(sql);

// Parse simple XML rows

var rows = xml.split("\<Row\>");

for (var i=1; i\<rows.length; i++) {

var row = rows\[i\];

var id = between(row,"\<Object_ID\>","\</Object_ID\>");

var nm = between(row,"\<Name\>","\</Name\>");

var nt = between(row,"\<Note\>","\</Note\>");

file.WriteLine(id + ",\\" + nm + "\\,\\" + nt + "\\");

}

file.Close();

Session.Output("Requirements exported.");

}

function between(h,a,b){ var i=h.indexOf(a); if(i\<0) return ""; var
j=h.indexOf(b,i+a.length); return j\<0?"":h.substring(i+a.length,j); }

main();

### Find Orphaned Elements

// -------------------------------------------------------

// Example 12.4 - FindOrphans.js – JScript (ES3)

// Purpose: Report elements with no connectors

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var orphans=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Connectors.Count == 0) {

orphans++;

Session.Output("Orphan: " + e.Name);

}

}

Session.Output("Total orphans: " + orphans);

}

main();

### List Elements by Stereotype

// -------------------------------------------------------

// Example 12.5 - ListByStereotype.js – JScript (ES3)

// Purpose: Output all elements with a given stereotype

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var STEREOTYPE = "Capability";

var sql = "SELECT ea_guid, Name FROM t_object WHERE Stereotype='" +
STEREOTYPE + "'";

var xml = Repository.SQLQuery(sql);

var rows = xml.split("\<Row\>");

for (var i=1; i\<rows.length; i++) {

var row = rows\[i\];

var guid = between(row,"\<ea_guid\>","\</ea_guid\>");

var nm = between(row,"\<Name\>","\</Name\>");

Session.Output("Capability: " + nm + " (" + guid + ")");

}

}

function between(h,a,b){ var i=h.indexOf(a); if(i\<0) return ""; var
j=h.indexOf(b,i+a.length); return j\<0?"":h.substring(i+a.length,j); }

main();

### Create a Trace Link Between Selected Elements

// -------------------------------------------------------

// Example 12.6 - CreateTrace.js – JScript (ES3)

// Purpose: Create a Realisation connector between two elements selected
in a diagram

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var dia = Repository.GetCurrentDiagram();

if (!dia) { Session.Prompt("Open a diagram and select two elements.",
promptOK); return; }

if (dia.SelectedObjects.Count != 2) {

Session.Prompt("Select exactly two elements.", promptOK);

return;

}

var el1 =
Repository.GetElementByID(dia.SelectedObjects.GetAt(0).ElementID);

var el2 =
Repository.GetElementByID(dia.SelectedObjects.GetAt(1).ElementID);

var conn = el1.Connectors.AddNew("", "Realisation");

conn.SupplierID = el2.ElementID;

conn.Update();

Repository.RefreshModelView(el1.PackageID);

Session.Output("Trace created: " + el1.Name + " → " + el2.Name);

}

main();

### Report Elements Missing Documentation

// -------------------------------------------------------

// Example 12.7 - FindMissingNotes.js – JScript (ES3)

// Purpose: List elements without notes (documentation)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (trim(e.Notes) == "") {

Session.Output("Missing notes: " + e.Name);

}

}

}

function trim(str){ return
str==null?"":String(str).replace(/^\s+\|\s+\$/g,""); }

main();

### Export Class Attributes

// -------------------------------------------------------

// Example 12.8 - ExportClassAttributes.js – JScript (ES3)

// Purpose: Export attributes of all classes in a package

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Class") {

var attrs = e.Attributes;

for (var j=0; j\<attrs.Count; j++) {

var a = attrs.GetAt(j);

Session.Output("Class " + e.Name + " attr: " + a.Name + ":" + a.Type);

}

}

}

}

main();

### Bulk Set Status

// -------------------------------------------------------

// Example 12.9 - BulkSetStatus.js – JScript (ES3)

// Purpose: Set the Status of all elements in a package

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var NEW_STATUS = "Proposed";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Status != NEW_STATUS) {

Session.Output("Change status: " + e.Name + " → " + NEW_STATUS);

if (!DRY_RUN) { e.Status = NEW_STATUS; e.Update(); }

}

}

if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);

}

main();

### Delete Elements Safely

// -------------------------------------------------------

// Example 12.10 - SafeDelete.js – JScript (ES3)

// Purpose: Delete all elements of a given type in a package

// Safety: DRY_RUN = true by default

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var TYPE_FILTER = "UseCase";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

// Iterate backwards when deleting

for (var i=els.Count-1; i\>=0; i--) {

var e = els.GetAt(i);

if (e.Type == TYPE_FILTER) {

Session.Output("Would delete: " + e.Name);

if (!DRY_RUN) {

els.DeleteAt(i, false); // false = don't refresh each time

}

}

}

if (!DRY_RUN) {

pkg.Update();

Repository.RefreshModelView(pkg.PackageID);

}

}

main();

## Summary

This cookbook chapter delivers **ready-to-use recipes**:

- Bulk editing (11.1, 11.2, 11.9, 11.10).

- Reporting (11.4, 11.5, 11.7, 11.8).

- Traceability utilities (11.6).

- Import/export utilities (11.3).

Each follows the **constraints of EA’s JScript engine** (ES3 only,
ActiveX for files, .Count/.GetAt() for collections).

# Chapter 13: Why AI Helps 

By this point, we have explored why scripting Enterprise Architect is
essential, how the automation landscape is structured, and how to apply
safe, repeatable patterns. We have also seen how practical recipes can
turn concepts into working scripts. Yet for many modellers, one barrier
remains: the leap from knowing *that* scripting is possible to actually
writing the first line of code.

This is where **artificial intelligence (AI)** comes in. Large language
models (LLMs) such as ChatGPT, Claude, or Copilot have introduced a new
way of working: you no longer have to start from a blank editor window.
Instead, you can describe what you want in natural language and receive
a code draft to work with. AI can provide scaffolding, suggest
refactors, and generate boilerplate headers. It cannot replace human
judgement, but it can dramatically accelerate the scripting process.

This chapter examines why AI is such a powerful assistant in the EA
scripting context. It explains the barriers AI helps overcome, the risks
it introduces, and the ways to use it responsibly. By the end, you will
see AI not as a magic solution but as a valuable partner: one that helps
you get started, iterate faster, and learn more effectively.

## Benefits

### The Blank Page Problem

For many modellers, the hardest part of scripting is not the logic but
the start. Opening EA’s script editor and staring at an empty window can
be intimidating. Even if you know what you want to achieve — “rename all
requirements with a REQ\_ prefix” — translating that into correct
JScript syntax feels daunting.

AI reduces this barrier. By typing a prompt such as *“Write an EA script
that adds a prefix to all Requirement elements in a selected package”*,
you receive a draft that includes the right loop structure, .Count and
.GetAt() calls, and Update() method. It may not be perfect, but it is
far less intimidating than starting from zero.

### AI as a Pattern Generator

Earlier chapters emphasised the importance of scripting patterns:
Find/Filter/Apply, Tag Propagation, Curate-then-Write. AI is good at
recognising these patterns and generating boilerplate loops. Instead of
writing the same traversal logic repeatedly, you can ask AI to generate
it and then adjust the details.

For example, a prompt like *“Write a Find/Filter/Apply script that sets
the Status to Approved for all Requirements tagged with
‘Owner=Architecture’”* can yield a working draft in seconds.

### AI as a Translator

One of the practical challenges in EA scripting is the language choice.
Many legacy scripts are in VBScript, while most new ones are in JScript.
AI can act as a **translator**, converting VBScript examples into
JScript ES3. It can also help migrate JScript snippets into Python or C#
for external automation.

For example, you might paste an old VBScript snippet and ask:
*“Translate this into JScript (ES3 only, no forEach, no JSON methods).”*
AI can provide a draft translation that saves hours of manual effort.

### AI as a Refactoring Partner

As your script library grows, you may notice duplication: multiple
scripts with similar loops, slightly different logic, inconsistent
logging. AI can help refactor them into cleaner, more consistent
structures.

For instance, you might prompt: *“Refactor this script to include a
DRY_RUN flag and a logging function that writes to CSV.”* AI will
propose a refactored version, which you can then validate. This makes it
easier to standardise your script style and enforce governance
principles.

### AI for Documentation and Training

Another way AI adds value is in **documentation**. Good scripts should
always include headers (purpose, usage, assumptions, safety,
dependencies). Writing these headers can feel tedious. AI can generate
them for you.

Similarly, AI can create training material: explainers, walkthroughs, or
alternative language examples. For new team members, you can paste a
script into AI and ask it to explain what each line does in plain
English. This makes onboarding easier.

#### The Risks of AI in Scripting

Of course, AI is not perfect. In fact, it is often confidently wrong.
Common risks include:

- **Hallucinations**: inventing methods that do not exist (e.g., forEach
  on EA collections).

- **Unsupported syntax**: using modern JavaScript features (let, const,
  arrow functions) that fail in EA’s ES3 engine.

- **Unsafe updates**: forgetting to include Update() or DRY_RUN, leading
  to destructive changes.

- **Performance issues**: generating scripts that spam Session.Output
  thousands of times.

These risks are not minor. If you copy AI output blindly into a
production repository, you may corrupt or damage your model. That is why
AI must always be used with caution.

## Using AI Safely

The key to using AI effectively is to treat it as a **drafting tool**,
not an authority. You are the architect; AI is your assistant. That
means:

1.  **Craft precise prompts** — specify ES3, mention .Count/.GetAt(),
    require DRY_RUN.

2.  **Always dry-run first** — never trust AI code without logging and
    simulation.

3.  **Review carefully** — read the script line by line, confirm
    Update() is included where needed.

4.  **Test on sandboxes** — never run AI-generated scripts directly on
    production repositories.

With these safeguards, AI becomes a useful accelerator rather than a
liability.

## AI and Learning

Interestingly, using AI to generate scripts can also accelerate your own
learning. When you compare AI’s draft to your mental model, you notice
differences. Sometimes AI is wrong, and that highlights a gap in your
own understanding. Sometimes AI uses a trick you didn’t know, and you
learn from it.

Over time, AI becomes a tutor. You experiment by prompting, you review
the results, you test and refine. The process itself builds fluency in
the EA API.

## AI in Daily Workflow

Later in this book (Chapter 15), we will explore AI in daily workflow:
prompt libraries, Git integration, and governance checks. For now, the
key point is that AI is not just for occasional inspiration; it can be
integrated into your routine. Whether you are writing a new script,
refactoring an old one, or explaining a script to a colleague, AI can
help.

## Examples

### AI-generated vs Corrected

Suppose you ask an AI:

*“Write a script that lists all elements in a package.”*

You might get this **wrong version**:

// ❌ AI output (modern JS not supported in EA)

let pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { alert("Select a package"); }

pkg.Elements.forEach(e =\> console.log(e.Name));

This will fail inside EA because:

- let and arrow functions (=\>) are unsupported (JScript is ES3).

- EA Collections are not true arrays; .forEach does not exist.

- EA uses Session.Output, not console.log.

Here’s the corrected version:

// -------------------------------------------------------

// Example 13.1 - ListElements_Corrected.js – JScript (ES3)

// Purpose: Output element names in the selected package

// Safe version corrected from AI output

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) {

Session.Prompt("Select a package.", promptOK);

return;

}

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

Session.Output("Element: " + e.Name);

}

}

main();

### AI-Assisted Refactoring

You can ask AI:

*“Refactor this script to add dry-run and logging to CSV.”*

AI may provide scaffolding, but you need to ensure it respects EA’s
environment.

Refactored pattern with dry-run and CSV logging:

// -------------------------------------------------------

// Example 13.2 - RefactorWithDryRun.js – JScript (ES3)

// Purpose: Rename all Requirements with prefix, log to CSV

// Example of AI-assisted refactor (corrected to EA ES3)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var PREFIX = "REQ\_";

var shell = new ActiveXObject("Shell.Application");

var folder = shell.BrowseForFolder(0, "Select output folder for log
CSV", 0, 0);

if (!folder) return;

var dir = folder.Self.Path;

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = fso.CreateTextFile(dir + "\\rename_log.csv", true);

file.WriteLine("ElementID,OldName,NewName,Action");

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Requirement" && e.Name.indexOf(PREFIX) != 0) {

var newName = PREFIX + e.Name;

file.WriteLine(e.ElementID + "," + e.Name + "," + newName + "," +
(DRY_RUN ? "DRY_RUN" : "RENAME"));

if (!DRY_RUN) { e.Name = newName; e.Update(); }

}

}

if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);

file.Close();

Session.Output("Script complete. Dry-run=" + DRY_RUN);

}

main();

## Using AI for Documentation

Another practical use of AI is **auto-generating headers**. For example,
you paste in a script and ask:

*“Add a structured header with purpose, usage, assumptions, and update
history.”*

AI can reliably produce your desired verbose headers (see Chapter 6’s
shared format), saving time and keeping your script library consistent.

## Best Practices for AI-Assisted Scripting

1.  **Always state the runtime**: “EA JScript, ES3 only, no ES6
    features.”

2.  **Request safety patterns**: dry-run flag, logging, Update() after
    changes.

3.  **Iterate small**: test on a dummy package, then scale up.

4.  **Curate prompts**: treat prompt engineering as coding. Be explicit.

5.  **Refactor, don’t trust blindly**: AI is a partner, not a
    replacement.

## Summary

AI helps Sparx EA users by generating scaffolding, converting languages,
and automating repetitive refactors. But the constraints of EA’s JScript
runtime mean you must always **review, test, and correct** AI outputs.
Use AI as an assistant, not an autopilot.

In the next chapter we’ll move to **Chapter 13 – Prompt Engineering for
EA Scripting**, where we’ll learn how to craft precise prompts that
yield safe, useful code for EA.

# Chapter 14: Prompt Engineering

In the previous chapter, we saw how artificial intelligence can reduce
the blank-page barrier and accelerate scripting. But to get real value
from AI, you must learn how to **ask properly**. AI is like a very fast
but sometimes careless assistant. If you give vague instructions, it
will give vague or even dangerous results. If you provide precise,
structured prompts, it can generate highly usable code. This practice of
crafting inputs deliberately is called **prompt engineering**.

Prompt engineering is not about writing long, elaborate instructions. It
is about giving AI just enough context, constraints, and examples so
that the output is aligned with your needs. For Enterprise Architect
scripting, that means telling AI about the limitations of JScript ES3,
reminding it to use Update() and RefreshModelView(), and insisting on a
DRY_RUN flag.

This chapter introduces the art of prompt engineering for EA scripting.
It shows why generic prompts fail, what makes EA-specific prompts
different, and how to refine AI outputs safely. It also explains how to
build a library of reusable prompts, so you don’t have to reinvent the
wheel every time you need a script.

## Why Prompt Engineering Matters

AI models are generalists. They have been trained on vast amounts of
code and text, but they do not “know” Enterprise Architect in detail.
That means they will often produce code that looks plausible but does
not run in EA. For example, they may suggest forEach on a collection, or
JSON.parse, or modern JavaScript features that EA’s engine does not
support.

Without careful prompting, you get output that looks fine but fails
immediately. With careful prompting, you get output that respects EA’s
constraints and includes safety features. Prompt engineering makes the
difference between AI as a gimmick and AI as a practical assistant.

### The Anatomy of a Good Prompt

A good prompt for EA scripting usually contains:

1.  **Context**: make clear you are scripting inside Enterprise
    Architect using JScript ES3.

2.  **Task**: what you want the script to do (e.g., rename requirements,
    export tags).

3.  **Constraints**: what not to use (no let, no const, no forEach).

4.  **Safety**: require DRY_RUN, logging, and comments.

5.  **Format**: ask for a complete runnable script with comments, not
    just fragments.

For example:

Write a JScript ES3 script for Sparx Enterprise Architect that traverses
the selected package, finds all Requirement elements, and prefixes their
names with “REQ\_”. Use .Count and .GetAt(i) loops, not modern JS
features. Include a DRY_RUN flag set to true by default, call Update()
for changes, and refresh the package at the end. Comment every step.

This is a prompt that sets context, constraints, safety, and format.

### Iterative Prompting

Prompt engineering is rarely one-and-done. Often the first output will
be close but not perfect. That is normal. The trick is to **iterate**:

1.  Run the script in dry-run mode.

2.  If it fails, feed the error message back into AI: *“The error says
    ‘forEach is not a function’. Rewrite using .Count and .GetAt().”*

3.  If it runs but misbehaves, clarify: *“The script renamed packages as
    well as requirements. Please filter only Elements of type
    Requirement.”*

4.  Keep refining until the script is safe and correct.

This iterative loop is part of prompt engineering. You don’t expect
perfection in one shot; you treat AI as a partner who improves with
feedback.

### Prompt Templates

Over time, you will notice you reuse similar prompts. Instead of writing
them from scratch each time, build **prompt templates**. For example:

- **Traversal template**: “Write a JScript ES3 script that traverses all
  elements in the selected package. Use .Count and .GetAt(). For each
  element, \[do something\]. Include DRY_RUN and logging.”

- **Tagged value template**: “Write a JScript ES3 script that checks all
  elements of stereotype X in the selected package and ensures they have
  a tagged value Y with value Z. Add if missing. Include DRY_RUN,
  logging, and RefreshModelView.”

- **Export template**: “Write a JScript ES3 script that exports all
  elements in the selected package to CSV. Include ElementID, GUID,
  Name, Type, and Stereotype. Use FileSystemObject, ANSI safe. Comment
  every step.”

By maintaining these prompt templates, you save time and improve
consistency.

### Guardrails in Prompts

Because EA is unforgiving (no undo, no rollback), guardrails are
essential. Your prompt should explicitly require:

- DRY_RUN flag.

- Update() on changes.

- RefreshModelView() at the end.

- Comments explaining each step.

- Backward deletion loops when deleting.

- Logs to Output or CSV.

Think of these as non-negotiable. If AI fails to include them, ask it to
add them.

### Prompting for Externals

Prompt engineering also applies when you use AI for external automation.
For example, you might ask for a Python script with pywin32 that
connects to EA. The same principles apply: specify language, COM,
bitness, safety, and logging.

For instance:

*Write a Python 3 script using pywin32 to connect to EA. Traverse the
selected package and print element names. Ensure it checks bitness
(32-bit Python), and include error handling.*

By being explicit, you avoid generic Python that won’t attach to EA.

### Common Prompting Mistakes

New users often make the following mistakes:

- **Being vague**: *“Write a script to rename elements.”* (AI invents
  code with forEach.)

- **Forgetting context**: not mentioning EA or JScript, so AI writes
  browser JavaScript.

- **Skipping safety**: AI writes a script that modifies elements without
  dry-run.

- **Accepting first output blindly**: running unsafe code in production.

Each of these can be avoided by careful prompting and iteration.

## Prompt Engineering as Team Practice

Prompt engineering is not just an individual skill. Teams can share
prompt libraries alongside script libraries. For example, store
templates in Git: one folder for prompts, one for scripts. This allows
consistency across a team and accelerates onboarding for new members.

Teams can also develop **governance prompts**: standard ways of asking
AI to generate scripts that align with organisational policies.

## AI Literacy for Modellers

Not every modeller will become a script writer. But every modeller can
benefit from AI literacy. Even if you don’t run the scripts yourself,
being able to ask AI for “the shape” of a script, review the comments,
and discuss it with colleagues adds value. Prompt engineering is
therefore not only for coders; it is part of the wider skillset of
modern architecture teams.

## Prompt Template

Here’s a reliable template you can use when asking AI to generate an EA
script:

Write a script for Sparx Enterprise Architect using JScript (ES3 only,
no ES6 features).

Constraints:

\- Use var (no let/const)

\- EA collections use .Count and .GetAt(i)

\- Use Session.Output for logging (not console.log)

\- Always call Update() after modifying objects

\- Include a DRY_RUN flag and verbose comments

Task: \[state the specific automation you want\]

## Examples

### List All Requirements

#### Prompt

“Write an EA JScript that lists all requirements in a selected package.
ES3 only, no modern JS features. Include DRY_RUN and comments.”

#### Raw AI Output (often wrong)

// ❌ Incorrect AI output

let pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { console.log("Select a package"); }

pkg.Elements.forEach(e =\> console.log(e.Name));

Problems:

- let and arrow functions unsupported (ES3 only).

- pkg.Elements is an EA collection, not an array (forEach will fail).

- console.log doesn’t exist in EA (use Session.Output).

#### Corrected Script

// -------------------------------------------------------

// Example 14.1 - ListRequirements.js – JScript (ES3)

// Purpose: List all Requirement elements in selected package

// Safety: DRY_RUN pattern included (though not needed for read-only)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true; // Included for consistency

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) {

Session.Prompt("Select a package first.", promptOK);

return;

}

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Requirement") {

Session.Output("Requirement: " + e.Name + " (ID=" + e.ElementID + ")");

}

}

}

main();

### Bulk Prefix Naming

#### Prompt

“Write an EA JScript that renames all elements in a package by adding
prefix ‘SYS\_’. ES3 only, no modern JS features. Include DRY_RUN,
logging, and RefreshModelView.”

#### Corrected Script

// -------------------------------------------------------

// Example 14.2 - BulkPrefixRename.js – JScript (ES3)

// Purpose: Add 'SYS\_' prefix to element names in a selected package

// Safety: DRY_RUN prevents accidental renaming

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var PREFIX = "SYS\_";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var changed=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Name.indexOf(PREFIX) != 0) {

var newName = PREFIX + e.Name;

Session.Output("Would rename: " + e.Name + " → " + newName);

if (!DRY_RUN) {

e.Name = newName;

e.Update();

changed++;

}

}

}

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(pkg.PackageID);

Session.Output("Processed " + els.Count + " elements, changed " +
changed);

}

main();

### Add a Tagged Value with Defaults

#### Prompt

“Write an EA JScript that ensures all elements in a package have a
tagged value ‘Owner=ArchitectureTeam’. ES3 only, no modern JS features.
DRY_RUN and comments required.”

#### Corrected Script

// -------------------------------------------------------

// Example 14.3 - EnsureTag_Owner.js – JScript (ES3)

// Purpose: Add/update tagged value 'Owner=ArchitectureTeam' for all
elements

// Safety: DRY_RUN flag enabled

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var TAG_NAME = "Owner";

var TAG_VALUE = "ArchitectureTeam";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var tags = e.TaggedValues;

var found = false;

for (var j=0; j\<tags.Count; j++) {

var t = tags.GetAt(j);

if (t.Name == TAG_NAME) {

found = true;

if (t.Value != TAG_VALUE) {

Session.Output("Would update tag for " + e.Name);

if (!DRY_RUN) { t.Value = TAG_VALUE; t.Update(); e.Update(); }

}

}

}

if (!found) {

Session.Output("Would add tag for " + e.Name);

if (!DRY_RUN) {

var nt = tags.AddNew(TAG_NAME, TAG_VALUE);

nt.Update(); e.Update();

}

}

}

if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);

}

main();

### Safe Delete

#### Prompt

“Write an EA JScript that deletes all UseCase elements in a package. ES3
only, DRY_RUN by default, with logging.”

Corrected Script

// -------------------------------------------------------

// Example 14.4 - SafeDelete_UseCases.js – JScript (ES3)

// Purpose: Delete all UseCase elements in a package

// Safety: DRY_RUN by default; logs each candidate

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var TYPE_FILTER = "UseCase";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

var deleted=0;

for (var i=els.Count-1; i\>=0; i--) { // iterate backwards

var e = els.GetAt(i);

if (e.Type == TYPE_FILTER) {

Session.Output("Would delete: " + e.Name);

if (!DRY_RUN) {

els.DeleteAt(i, false); // false = don’t refresh each time

deleted++;

}

}

}

if (!DRY_RUN && deleted\>0) Repository.RefreshModelView(pkg.PackageID);

Session.Output("Candidates: " + els.Count + " Deleted: " + deleted + "
Dry-run=" + DRY_RUN);

}

main();

## Best Practices for Prompts

- Always say: “EA JScript (ES3 only, no modern JS features)”.

- Always request: DRY_RUN flag, verbose comments, and RefreshModelView.

- If you want imports/exports: say “use ActiveX FileSystemObject”, not
  fs or modern Node.js.

- If you need CSV/Excel: say “use COM automation for Excel”, not
  external modules.

- Keep prompts specific: “list all Requirements in a package” vs “list
  elements”.

## Summary

Prompt engineering is about **teaching the AI your constraints**. By
making your requests precise (JScript ES3, DRY_RUN, .Count/.GetAt(i)),
you ensure the generated scripts run correctly in EA. AI will often
hallucinate modern JS features; your job is to correct them
systematically using the patterns in this chapter.

In the next chapter, we’ll explore **Chapter 14 – AI as a Refactoring
Partner**: using AI to *improve existing scripts* by converting between
languages, adding documentation headers, or reorganising code for
readability and maintainability.

# Chapter 15: AI Refactoring Partner

Writing new scripts from scratch is only part of the automation journey.
In practice, most of the scripts you will encounter in Enterprise
Architect are not greenfield creations. They are legacy fragments copied
from colleagues, utilities downloaded from forums, or quick fixes you
wrote six months ago and barely remember. Over time, these fragments
accumulate into a patchwork library that works but is inconsistent,
risky, and hard to maintain.

Refactoring is the process of improving code without changing its
intended behaviour. It is about making scripts more readable, more
consistent, safer, and easier to share. For EA scripting, refactoring
often means adding missing headers, introducing dry-run flags,
standardising logging, or converting old VBScript into JScript.

This is where artificial intelligence comes into its own as a
**refactoring partner**. While AI can generate new scripts, it is
especially powerful at taking existing ones and restructuring them.
Given clear instructions, it can modernise syntax, add comments, and
apply safety patterns. Of course, AI cannot be trusted blindly, but with
human oversight it becomes a force multiplier for improving script
quality.

## Why Refactoring Matters in EA Scripting

There are several reasons refactoring is essential:

- **Consistency**: a mixed library of VBScript and JScript makes it hard
  for teams to share and reuse.

- **Safety**: older scripts may lack dry-run flags or logging, making
  them risky.

- **Clarity**: many scripts lack headers or comments, leaving future
  readers confused.

- **Maintainability**: scripts with inconsistent style are harder to
  debug or adapt.

- **Governance**: in regulated environments, scripts must demonstrate
  safety and traceability.

Refactoring turns a messy script into a clean, well-documented artefact
that you can safely run and confidently share.

## The AI Advantage in Refactoring

Traditional refactoring is manual: you read old code, spot issues, and
rewrite. AI can accelerate this by doing the heavy lifting:

- Translate VBScript into JScript ES3.

- Insert a standard header block with purpose, usage, safety, and update
  history.

- Replace unsupported features (forEach, let, const) with EA-compatible
  constructs.

- Add dry-run wrappers around destructive operations.

- Insert comments explaining each step.

You still need to review the output, but AI removes much of the tedium.
Instead of spending hours rewriting loops, you can focus on reviewing
safety and correctness.

## Common Refactoring Needs

In EA scripting, the most frequent refactoring needs include:

1.  **VBScript to JScript migration**  
    Many legacy scripts were written in VBScript. Translating them by
    hand is slow; AI can do it in seconds.

2.  **Adding safety scaffolding**  
    Scripts without dry-run or logging are dangerous. AI can wrap
    actions in if (!DRY_RUN) and add log statements.

3.  **Commenting and documentation**  
    Many scripts are just raw code. AI can add structured comments that
    explain purpose and usage.

4.  **Standardising patterns**  
    Replace ad-hoc loops with a Find/Filter/Apply structure. Replace
    forward deletion with backward deletion.

5.  **Splitting monoliths**  
    Some scripts try to do too much at once. AI can help break them into
    smaller functions with clear responsibilities.

## Risks of AI Refactoring

While AI is powerful, it is not infallible. Risks include:

- **Hallucinated methods**: inserting functions that don’t exist in EA
  (e.g., .forEach).

- **Over-modernisation**: using ES6 syntax not supported in EA’s JScript
  ES3 runtime.

- **Silent changes**: accidentally altering behaviour while
  “refactoring.”

- **Over-commenting**: adding comments that explain the obvious but miss
  the critical.

That is why human review is non-negotiable. AI can propose changes, but
you must check every line.

## A Human–AI Workflow for Refactoring

A safe refactoring workflow looks like this:

1.  **Select a script** — choose one that needs improvement (e.g., lacks
    dry-run, VBScript only).

2.  **Prompt AI clearly** — specify: *“Refactor this into JScript ES3,
    add DRY_RUN, add comments, keep functionality the same.”*

3.  **Review output** — check loops, updates, stereotypes, and API
    calls.

4.  **Test in sandbox** — run dry-run mode on a small package.

5.  **Iterate** — adjust prompt or script until correct.

6.  **Adopt as standard** — store the refactored script in Git with
    version history.

This workflow ensures that AI accelerates without undermining trust.

## AI for Documentation Retrofitting

One of the least glamorous but most valuable uses of AI is adding
**documentation headers**. You can paste a bare script into AI and ask:
*“Add a standard EA script header with purpose, usage, assumptions,
safety, dependencies, and update history.”* AI will generate a block
that matches the conventions established earlier in this book.

Over time, this makes your library far more navigable. Anyone can open a
script and know immediately what it does and how to use it.

## Refactoring for Governance

Refactoring is not just a technical hygiene exercise; it supports
governance. In many organisations, scripts themselves are part of the
audit trail. Regulators may ask: how do you ensure automation is safe?
Refactored scripts with dry-run, logs, and headers are evidence of
governance in action.

AI can help align scripts with these governance requirements, ensuring
safety features are never omitted.

## Beyond EA: Refactoring Across Languages

Although this chapter focuses on EA’s internal scripting, the same
principles apply to external automation. AI can refactor Python scripts
to improve logging, or C# scripts to adopt better patterns. The value of
AI as a refactoring partner extends across the entire EA automation
ecosystem.

## The Cultural Impact of Refactoring with AI

When teams see that AI can quickly improve old scripts, they become more
willing to use and share automation. Instead of hoarding fragile
snippets, they submit them for refactoring. Over time, this raises the
baseline quality of the entire script library.

AI thus plays a cultural role: it makes refactoring less of a chore,
more of a routine practice.

## Examples

### Converting VBScript to JScript

Many older EA repositories contain **VBScript snippets**. These work,
but are verbose and unfamiliar to modern developers. AI can help you
convert them to JScript.

#### Original VBScript

' List all element names in selected package (VBScript)

!INC Local Scripts.EAConstants-VBScript

sub main()

dim pkg

set pkg = Repository.GetTreeSelectedPackage()

if pkg is nothing then

Session.Prompt "Select a package.", promptOK

exit sub

end if

dim els, i

set els = pkg.Elements

for i = 0 to els.Count - 1

Session.Output "Element: " & els.GetAt(i).Name

next

end sub

main

#### AI-Assisted Conversion (Corrected JScript)

// -------------------------------------------------------

// Example 15.1 - ListElements_JS.js – JScript (ES3)

// Purpose: Converted from VBScript using AI refactoring

// Notes: ES3 only, no modern JS features

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) {

Session.Prompt("Select a package.", promptOK);

return;

}

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

Session.Output("Element: " + e.Name);

}

}

main();

### Adding a Structured Header

Scripts often start life as quick hacks. Over time, they become hard to
reuse because they lack documentation. AI can automatically generate a
**structured header** in your house style.

#### Before (minimal)

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) return;

Session.Output("Selected package: " + pkg.Name);

}

main();

#### After (AI-generated header + corrections)

// -------------------------------------------------------

// Example 15.2 - ShowSelectedPackage.js – JScript (ES3)

// Purpose: Output the name of the selected package

// Usage: Select a package in the Project Browser → run script

// Assumptions: User selects a package; ES3 runtime only

// Safety: Read-only, no modifications

// Dependencies: none

// Update history: 1.0 initial

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) {

Session.Prompt("Please select a package.", promptOK);

return;

}

Session.Output("Selected package: " + pkg.Name);

}

main();

### Refactoring for Safety (Add DRY_RUN)

AI can retrofit your script with **dry-run and logging**.

#### Original Script (unsafe)

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

els.GetAt(i).Name = "Test\_" + els.GetAt(i).Name;

els.GetAt(i).Update();

}

Repository.RefreshModelView(pkg.PackageID);

}

main();

#### Refactored with DRY_RUN

// -------------------------------------------------------

// Example 15.3 - SafeRename.js – JScript (ES3)

// Purpose: Prefix all element names with "Test\_"

// Safety: DRY_RUN enabled by default; logs actions

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var DRY_RUN = true;

var PREFIX = "Test\_";

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var changed=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

var newName = PREFIX + e.Name;

Session.Output("Would rename: " + e.Name + " → " + newName);

if (!DRY_RUN) {

e.Name = newName;

e.Update();

changed++;

}

}

if (!DRY_RUN && changed\>0) Repository.RefreshModelView(pkg.PackageID);

Session.Output("Total processed: " + els.Count + ", Changed: " +
changed + ", Dry-run=" + DRY_RUN);

}

main();

### Breaking Down Monoliths

AI can also split a long monolithic script into **functions**, making it
easier to maintain.

#### Before (all inline)

function main() {

var pkg = Repository.GetTreeSelectedPackage();

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Requirement" && e.Notes == "") {

Session.Output("Requirement missing notes: " + e.Name);

}

}

}

main();

#### After (refactored into functions)

// -------------------------------------------------------

// Example 15.4 - CheckMissingNotes.js – JScript (ES3)

// Purpose: Report Requirements without notes

// Refactored to improve maintainability

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = getSelectedPackage();

if (!pkg) return;

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (isRequirementMissingNotes(e)) {

Session.Output("Requirement missing notes: " + e.Name);

}

}

}

// Get the currently selected package, with safety check

function getSelectedPackage() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) {

Session.Prompt("Select a package.", promptOK);

return null;

}

return pkg;

}

// Check if element is a Requirement with empty notes

function isRequirementMissingNotes(e) {

return e.Type == "Requirement" && trim(e.Notes) == "";

}

function trim(str) {

if (str == null) return "";

return String(str).replace(/^\s+\|\s+\$/g, "");

}

main();

## Summary

AI is a powerful refactoring partner:

- **Language conversion**: VBScript → JScript → Python.

- **Documentation**: auto-generate structured headers.

- **Safety**: add DRY_RUN, logs, and RefreshModelView.

- **Maintainability**: break monolithic scripts into functions.

You remain in control: AI does the heavy lifting, but you apply
corrections to keep everything **valid for EA’s JScript ES3 runtime**.

In the next chapter, we’ll explore **Chapter 15 – AI in Daily
Workflow**, showing how to build a *prompt library* and integrate
AI-assisted scripting into your modelling practice.

# Chapter 16: AI in Daily Workflow

By now we have seen how AI can help overcome the blank page problem,
generate patterns, translate between languages, and refactor old scripts
into safer, clearer versions. All of these uses are valuable, but they
still treat AI as something you consult occasionally — a tool you dip
into when you need help. The next step is to make AI part of your
**daily scripting workflow**.

This means integrating AI into how you plan, write, document, and share
scripts. It means building a personal or team “prompt library” that
captures successful ways of asking for code. It means using AI to
generate standard headers or loggers automatically. It means involving
AI in version control, commit messages, and governance checks. When AI
becomes part of your routine, it stops being an add-on and starts being
a multiplier.

This chapter explains what it looks like to work with AI every day as a
script writer or modelling architect. It shows how to build habits and
structures that make AI useful without making you dependent. It also
highlights the risks of over-reliance and the safeguards needed to
maintain trust.

## From Occasional Help to Daily Companion

For most people, the first time they use AI for scripting is when they
are stuck. They don’t know how to write a loop, or they have an old
VBScript to translate, or they need a header quickly. That is a good
start, but it is still **reactive**: AI is only consulted when there is
a problem.

Daily workflow means turning this reactive use into **proactive
integration**. Instead of waiting until you are stuck, you design your
process around AI from the start. For example:

- Every new script begins with an AI-generated header template.

- Every new task begins with a search of your prompt library.

- Every commit is accompanied by an AI-suggested message.

- Every governance run is explained by an AI-drafted summary.

The point is not that AI replaces your work, but that it saves you from
repetitive effort and keeps you moving forward.

## The Role of a Prompt Library

One of the simplest but most effective habits is to maintain a **prompt
library**. This is a set of carefully worded instructions you know
produce reliable code. For example:

- “Write a JScript ES3 script for EA that traverses the selected
  package, loops with .Count/.GetAt(), and logs each element name to the
  Output tab. Include DRY_RUN.”

- “Translate this VBScript into JScript, preserving behaviour, adding
  DRY_RUN and logging.”

- “Refactor this script to use backward deletion loops.”

By reusing these prompts, you reduce the chance of errors and improve
consistency. You also save time: instead of re-explaining EA’s quirks to
AI each time, you paste a standard prompt and focus on the task.

## Automating Boilerplate

A surprising amount of scripting effort goes into **boilerplate**:
headers, loggers, dry-run wrappers, refresh calls. These are necessary
for safety but repetitive to write. AI is very good at generating
boilerplate.

For example, you might ask: *“Generate a standard EA script header with
fields for Purpose, Usage, Assumptions, Safety, Dependencies, and Update
history.”* AI will output a block you can paste at the top of every
script. You can then refine it once and reuse it many times.

Similarly, you can ask AI to insert a standard logging helper or dry-run
guard into existing scripts. Over time, this ensures all your scripts
share a consistent structure.

## AI as a Debugging Partner

Although EA’s scripting environment lacks a debugger, AI can serve as a
**debugging partner**. When you get an error, you can paste the message
and the relevant code into AI and ask: *“Why does this fail in EA
JScript?”*

AI will often spot issues like:

- Using .forEach instead of .GetAt().

- Forgetting .Update().

- Using let or const instead of var.

This is not fool-proof, but it gives you quick feedback, reducing
trial-and-error.

## Integration with Version Control

Many teams now keep their scripts in Git repositories. AI can support
this workflow in several ways:

- **Commit messages**: generate clear, descriptive commit messages
  summarising what changed.

- **Code reviews**: provide first-pass feedback on whether a script
  follows safety conventions.

- **Refactoring suggestions**: highlight duplication across scripts.

For example, you might paste a diff into AI and ask: *“Summarise these
changes in a Git commit message.”* It will return a concise summary you
can tweak.

## Governance and Reporting

AI can also help with governance reporting. After running a governance
script that logs issues to CSV, you can feed the results into AI and ask
for a plain-English summary: *“Explain the key issues found in this log
and suggest actions.”*

This does not replace human judgement, but it makes governance outputs
easier to digest. Stakeholders see not just a list of IDs but an
interpretation.

## Risks of Daily AI Use

Daily use of AI brings its own risks:

- **Complacency**: relying on AI to generate boilerplate without
  understanding it.

- **Over-reliance**: forgetting how to write basic loops yourself.

- **False trust**: assuming AI output is always safe.

- **Data exposure**: pasting sensitive content into AI without
  considering confidentiality.

To mitigate these risks, you should:

- Continue practising core scripting skills.

- Review AI output critically.

- Use internal AI deployments where data sensitivity is an issue.

- Keep your own library of trusted patterns.

## AI as a Team Enabler

AI is not only useful for individuals. Teams can adopt it as a shared
resource. For example:

- Store prompt templates in the same Git repo as scripts.

- Agree on standard AI guardrails (always include DRY_RUN, never use
  direct SQL writes).

- Use AI to explain scripts to non-technical colleagues.

This makes scripting more inclusive. Analysts who cannot code fluently
can still understand and contribute by using AI as an interpreter.

### Building Habits

The key to making AI part of your daily workflow is to build habits:

- Start every new script with an AI-generated header.

- Always run prompts through your standard templates.

- Use AI for documentation and commit messages.

- Review output in dry-run mode before trusting it.

Habits ensure consistency and reduce the cognitive load. You don’t have
to remember every detail — the process takes care of it.

### Build a Prompt Library

When you find a prompt that works, don’t rely on memory — **save it**.
Treat prompts like reusable code snippets. Keep them in a text file, Git
repository, or even within EA as a script comment block.

#### Prompt snippet saved for reuse

Prompt: Write a script for Sparx Enterprise Architect using JScript (ES3
only).

Constraints:

\- Use var (no let/const)

\- EA collections require .Count and .GetAt(i)

\- Use Session.Output (not console.log)

\- Always call Update() after changes

\- Include DRY_RUN flag and verbose comments

Task: List all Requirement names in a selected package.

### Use AI for Boilerplate

Instead of re-typing headers or dry-run scaffolding, ask AI to **insert
the standard structure** for you.

// -------------------------------------------------------

// Example 16.1 - ListRequirements.js

// Purpose: Output names of Requirement elements in a package

// Usage: Select a package in Project Browser → run

// Assumptions: JScript ES3 runtime

// Safety: Read-only

// Dependencies: none

// Update history: 1.0 initial

// -------------------------------------------------------

This header can be generated by AI in seconds and keeps your scripts
consistent.

### Use AI for Daily Queries

You don’t need to remember every API call. Ask AI things like:

- “How do I get all connectors from an element in EA JScript?”

- “Show me how to create a new attribute on a class.”

- “How do I output the selected diagram’s objects?”

AI can provide scaffolding, but you must **correct it for EA’s
environment**.

### Daily Script with AI Template

Suppose you often need to **list tagged values** of selected elements.
Save a reusable script pattern, which AI can adapt for other tasks.

// -------------------------------------------------------

// Example 16.2 - ListTaggedValues.js – JScript (ES3)

// Purpose: Show all tagged values for the selected element

// Usage: Select element in Project Browser → run script

// Safety: Read-only

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var el = Repository.GetTreeSelectedObject();

if (!el \|\| el.ObjectType != otElement) {

Session.Prompt("Select an element first.", promptOK);

return;

}

var tags = el.TaggedValues;

if (tags.Count == 0) {

Session.Output("No tagged values on " + el.Name);

return;

}

for (var i=0; i\<tags.Count; i++) {

var tv = tags.GetAt(i);

Session.Output("Tag: " + tv.Name + " = " + tv.Value);

}

}

main();

When you need a **variation** (e.g. export tags to CSV, update missing
tags), prompt AI with *“adapt ListTaggedValues.js to write tags to a CSV
file, ES3 only”*.

## Git + AI Workflow

Version-control your scripts with Git (or even OneDrive). AI can:

- Generate **commit messages** (“Add dry-run safety to SafeRename
  script”).

- Suggest **code reviews** (“Highlight where Update() is missing”).

- Propose **refactors** across multiple scripts.

### Commit message prompt

Prompt: Write a Git commit message for adding DRY_RUN safety and CSV
logging to BulkPrefixRename.js

## AI-Assisted Governance Check

Daily workflows often involve governance (naming rules, tags,
traceability). Here’s a pattern you can copy, extend, and ask AI to
adapt.

// -------------------------------------------------------

// Example 16.3 - DailyGovernanceCheck.js – JScript (ES3)

// Purpose: Report Requirements missing 'Owner' tag

// Safety: Read-only; logs only

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

var els = pkg.Elements;

var missing=0;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

if (e.Type == "Requirement" && !hasTag(e,"Owner")) {

missing++;

Session.Output("Requirement missing Owner tag: " + e.Name);

}

}

Session.Output("Governance check: " + missing + " missing tags.");

}

function hasTag(e, tagName) {

var tags = e.TaggedValues;

for (var i=0; i\<tags.Count; i++) {

var t = tags.GetAt(i);

if (t.Name == tagName) return true;

}

return false;

}

main();

Tomorrow, you might ask AI:

*“Extend DailyGovernanceCheck.js to add the tag if missing, with default
value ‘ArchitectureTeam’. Keep DRY_RUN enabled.”*

AI can refactor this for you, but you must validate the code against
EA’s constraints.

## Summary

AI becomes part of your **daily workflow** when you:

- Save **prompt libraries** for reuse.

- Use AI to generate **boilerplate headers** and scaffolding.

- Ask natural-language **API queries** instead of memorising details.

- Maintain scripts in **Git**, with AI suggesting commit messages and
  refactors.

- Start from a **daily pattern script** (like tagged value checks), and
  let AI adapt it to new use cases.

The key is consistency: you are the architect, AI is your assistant. By
building repeatable workflows around AI, you gain speed and safety
without losing control.

# Chapter 17: Performance & Scaling

Enterprise Architect is used in contexts that range from small projects
to national architectures. In small repositories with a few hundred
elements, scripting feels instant and forgiving. But as repositories
grow to tens of thousands or even hundreds of thousands of elements,
performance becomes a real concern. A script that works perfectly in a
sandbox may take hours, or even crash EA, when run against an
enterprise-scale repository.

This chapter explores the principles of performance and scaling in EA
scripting. It explains why large repositories behave differently, why
naive loops and excessive logging cause problems, and how to design
scripts that handle scale safely. The goal is not to turn you into a
performance engineer, but to provide practical strategies that let your
scripts run efficiently on real-world repositories.

## Why Performance Matters

At first glance, performance might seem secondary. After all, scripts
are automation — even if they take a few minutes, they still save hours
of manual effort. But in practice, performance is about more than speed.
Poorly written scripts can:

- **Lock up EA’s UI**, frustrating other users.

- **Generate incomplete results**, skipping elements when loops break.

- **Produce overwhelming logs**, flooding the Output tab and crashing
  EA.

- **Time out in enterprise workflows**, failing integration pipelines.

Performance is therefore about reliability as well as speed. Scripts
that scale are scripts that can be trusted.

## Sources of Slowness

There are a few common culprits for slow scripts:

- **UI logging**: Session.Output is surprisingly expensive when called
  thousands of times.

- **Inefficient traversal**: deep recursion or redundant queries slow
  scripts down.

- **Excessive updates**: calling .Update() unnecessarily adds overhead.

- **Unfiltered loops**: traversing everything when only a subset is
  needed.

- **SQL misuse**: failing to use SQL for large reads, or misusing SQL
  for writes.

Understanding these bottlenecks is the first step to avoiding them.

## Measure First

The golden rule of performance is: **measure before you optimise**. In
scripting, this means timing your loops and logging throughput. For
example, processing 10,000 elements in 5 seconds is healthy; in 50
minutes, it is not. By measuring, you can identify where the script
spends most of its time.

In practice, you can use simple timers (Date().getTime() in JScript) to
record how long operations take. Always include performance metrics in
your logs.

## Tips

### SQL for Find, API for Write

One of the most effective performance strategies is:

- **Find with SQL**: use Repository.SQLQuery to locate candidates
  quickly.

- **Write with API**: use EA’s object model for updates, ensuring
  integrity.

SQL queries are far faster than traversing the entire package tree with
.Count/.GetAt(). But writing directly via SQL risks corruption. The
combination of SQL reads and API writes gives the best of both worlds.

### Chunking Updates

Large updates should be chunked. Updating thousands of elements in one
continuous loop can overwhelm EA’s UI and lock it up. Instead, process
in batches — for example, 250 elements at a time — and refresh the model
view between batches.

This chunking approach improves responsiveness and reduces the risk of
EA appearing frozen. It also makes logs easier to review.

### Iterative Traversal

Recursion is elegant but risky in large models. Deep package trees can
hit recursion limits or create excessive stack usage. Iterative
traversal using a queue (breadth-first) is safer and more scalable. It
avoids call-stack overflows and makes the traversal logic clearer.

### Idempotence and Skipping

Performance is not only about speed but also about avoiding unnecessary
work. If an element already has the correct stereotype or tag, there is
no need to update it. Idempotent scripts — those that skip items already
in the correct state — run faster and reduce risk.

### Logging Without Flooding

Logging is vital for safety, but excessive logging kills performance.
Writing 50,000 lines to EA’s Output tab can freeze the tool. The safe
practice is to log **summary to Output** and **details to CSV**. This
gives you transparency without choking the UI.

### External Automation for Heavy Jobs

Sometimes the best way to scale is to move heavy jobs outside EA.
External automation in Python or C# can handle large CSVs, JSON, or
analytics, leaving EA to focus on updates. Splitting work this way makes
scripts leaner and safer.

## Principles

1.  **Measure**: time the script and log throughput (items/sec).

2.  **Reduce UI overhead**: write to a file (CSV) instead of spamming
    Output; refresh UI only once at the end or per large batch.

3.  **Find with SQL, write with API**: SQL is fast for locating
    candidates; API is safe for updates.

4.  **Chunk**: commit changes in batches (e.g., 250); between batches,
    give EA a chance to breathe (optional UI refresh).

5.  **Iterative traversal**: avoid deep recursion; use a queue/stack to
    walk package trees.

6.  **Be idempotent**: skip items already in the desired state.

7.  **No parallelism**: EA’s COM server is single-threaded
    STA—concurrency won’t help.

All examples below are **ES3** and assume no shared helper file; each
script includes its own minimal helpers.

## Examples

### Micro-helpers (copy/paste as needed)

// -------------------------------------------------------

// Example 17.1 - perf_helpers.js (inline for each example)

// -------------------------------------------------------

function nowMs(){ return (new Date()).getTime(); }

function trim(s){ return
s==null?"":String(s).replace(/^\s+\|\s+\$/g,""); }

function equalsIgnoreCase(a,b){ return
String(a\|\|"").toLowerCase()==String(b\|\|"").toLowerCase(); }

function startsWith(s,p){ return String(s\|\|"").indexOf(p)===0; }

// Directory chooser (directory only; no filenames)

function pickFolder(promptText){

var sh = new ActiveXObject("Shell.Application");

var f = sh.BrowseForFolder(0, promptText, 0, 0);

return f ? f.Self.Path : null;

}

// CSV writer (lightweight)

function Csv(path){

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = fso.OpenTextFile(path, 8 /\*Append\*/, true /\*Create\*/);

this.w = function(line){ file.WriteLine(line); };

this.close = function(){ file.Close(); };

}

### Pattern A —Timing Harness & Low-noise Logging

**Goal:** measure total time, throughput, and avoid slow Session.Output
loops.

// -------------------------------------------------------

// Example 17.2 - Perf_TimingHarness.js – JScript (ES3)

// Purpose: Run any loop with minimal UI logging + CSV metrics

// Usage: Select any package (context not required for the demo)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function nowMs(){ return (new Date()).getTime(); }

function pickFolder(t){ var sh=new ActiveXObject("Shell.Application");
var f=sh.BrowseForFolder(0,t,0,0); return f?f.Self.Path:null; }

function Csv(path){ var fso=new
ActiveXObject("Scripting.FileSystemObject"); var
f=fso.OpenTextFile(path,8,true); this.w=function(l){f.WriteLine(l);};
this.close=function(){f.Close();}; }

function main(){

var outDir = pickFolder("Select output folder for perf log");

if(!outDir){ Session.Prompt("Cancelled.", promptOK); return; }

var stamp = (new Date()).getTime();

var csv = new Csv(outDir+"\\perf_metrics\_"+stamp+".csv");

csv.w("Metric,Value");

var T0 = nowMs();

var N = 20000; // simulate 20k lightweight ops (replace with real loop)

var i;

for(i=0;i\<N;i++){

// do nothing (placeholder for your per-item work)

// avoid Session.Output inside hot loops

}

var dt = nowMs()-T0;

var perSec = (N\>0)? Math.round((N\*1000.0)/dt) : 0;

csv.w("Items,"+N);

csv.w("Millis,"+dt);

csv.w("Throughput_items_per_sec,"+perSec);

csv.close();

Session.Output("Done. Items="+N+" Time(ms)="+dt+"
Throughput="+perSec+"/s");

}

main();

Adapt: wrap your actual processing loop and keep Output to a few lines.
For detailed logs, write to CSV instead.

### Pattern B — SQL-Accelerated Find, API-Safe Write (with chunking)

**Use case:** set a stereotype on all **Class** elements missing one,
across the repository.  
**Approach:**

1.  **SQLQuery** all candidate IDs (fast).

2.  Process in **chunks of 250**; call Update() per element, refresh UI
    only per chunk or once at the end.

3.  **DRY_RUN** for safety.

// -------------------------------------------------------

// Example 17.3 - Perf_SqlFind_ApiWrite_Chunked.js – JScript (ES3)

// Purpose: Fast find via SQL, chunked updates via API

// Safety: DRY_RUN = true by default

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function nowMs(){ return (new Date()).getTime(); }

function pickFolder(t){ var sh=new ActiveXObject("Shell.Application");
var f=sh.BrowseForFolder(0,t,0,0); return f?f.Self.Path:null; }

function Csv(path){ var fso=new
ActiveXObject("Scripting.FileSystemObject"); var
f=fso.OpenTextFile(path,8,true); this.w=function(l){f.WriteLine(l);};
this.close=function(){f.Close();}; }

function extractAll(h,openTag,closeTag){

var res=\[\], start=0;

while(true){

var i=h.indexOf(openTag,start); if(i\<0) break;

var j=h.indexOf(closeTag,i+openTag.length); if(j\<0) break;

res.push(h.substring(i+openTag.length,j));

start=j+closeTag.length;

}

return res;

}

function main(){

var DRY_RUN = true;

var TYPE_FILTER = "Class";

var TARGET_STEREO = "DomainObject";

var CHUNK = 250;

var outDir = pickFolder("Select output folder for change log");

if(!outDir){ Session.Prompt("Cancelled.", promptOK); return; }

var stamp=(new Date()).getTime();

var csv=new Csv(outDir+"\\chunked_changes\_"+stamp+".csv");

csv.w("Action,ElementID,Name,OldStereo,NewStereo");

var t0=nowMs();

// 1) fast find: candidates with empty stereotype (rough pre-filter)

var sql="SELECT Object_ID, Name, Stereotype FROM t_object WHERE
Object_Type='"+TYPE_FILTER+"' AND (Stereotype IS NULL OR
Stereotype='')";

var xml=Repository.SQLQuery(sql);

var ids=extractAll(xml,"\<Object_ID\>","\</Object_ID\>");

var count=ids.length;

Session.Output("Candidates: "+count);

var applied=0, batch=0, processed=0;

var i;

for(i=0;i\<count;i++){

var id=parseInt(ids\[i\],10);

var e=Repository.GetElementByID(id);

if(!e) continue;

// double-check to avoid redundant writes

var oldStereo=String(e.Stereotype\|\|"");

if(oldStereo===""){

csv.w((DRY_RUN?"DRY_RUN":"SET") + "," + e.ElementID + "," + e.Name +
"," + oldStereo + "," + TARGET_STEREO);

if(!DRY_RUN){ e.Stereotype = TARGET_STEREO; e.Update(); applied++; }

batch++;

}

processed++;

// chunk boundary

if(batch\>=CHUNK){

// optional: rare refresh so the UI doesn't feel stale

if(!DRY_RUN && applied\>0) Repository.RefreshModelView(0);

batch=0;

}

}

if(!DRY_RUN && applied\>0) Repository.RefreshModelView(0);

csv.close();

var dt=nowMs()-t0;

var rps = processed\>0 ? Math.round(1000.0\*processed/dt) : 0;

Session.Output("Processed="+processed+" Applied="+applied+"
Time(ms)="+dt+" Throughput="+rps+"/s DRY_RUN="+DRY_RUN);

}

main();

**Why it’s fast:** the *find* phase is one SQL call. The *write* phase
avoids extra lookups and refreshes only in large intervals.

### Pattern C — Iterative Package Traversal (no recursion)

Recursive tree walks can hit call-stack limits and are slower than a
simple queue. This **breadth-first** traversal scales better.

// -------------------------------------------------------

// Example 17.4 - Perf_PackageWalk_Iterative.js – JScript (ES3)

// Purpose: Walk an entire package tree without recursion

// Action: Count elements by type (as an example)

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main(){

var pkg = Repository.GetTreeSelectedPackage();

if(!pkg){ Session.Prompt("Select a root package.", promptOK); return; }

var queue=\[pkg\];

var typeCount = {}; // map type -\> number

while(queue.length\>0){

var p = queue.shift();

// enqueue children

var kids = p.Packages;

for(var i=0;i\<kids.Count;i++){ queue.push(kids.GetAt(i)); }

// tally elements

var els = p.Elements;

for(var j=0;j\<els.Count;j++){

var e = els.GetAt(j);

var t = e.Type;

typeCount\[t\] = (typeCount\[t\]\|\|0)+1;

}

}

// low-noise summary output

Session.Output("Element counts by Type:");

var k; for(k in typeCount){ if(typeCount.hasOwnProperty(k)){
Session.Output(" "+k+": "+typeCount\[k\]); } }

}

main();

**Why it’s scalable:** avoids deep call stacks and allocates a tiny
queue instead of many temporary stacks frames.

### Pattern D — Large CSV Apply (streaming + batching)

Reading a giant CSV and applying changes? Keep parsing **simple**, skip
unchanged rows, and batch writes.

// -------------------------------------------------------

// Example 17.5 - Perf_CsvApply_Batched.js – JScript (ES3)

// Purpose: Apply safe updates from a curated CSV with batching

// CSV columns (example): Apply,ElementID,NewStatus

// Safety: Only Apply=YES rows execute; chunk writes; minimal UI refresh

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function trim(s){ return
s==null?"":String(s).replace(/^\s+\|\s+\$/g,""); }

function pickFolder(t){ var sh=new ActiveXObject("Shell.Application");
var f=sh.BrowseForFolder(0,t,0,0); return f?f.Self.Path:null; }

function endsWith(s,suf){ s=String(s\|\|""); var i=s.lastIndexOf(suf);
return i\>=0 && i+suf.length==s.length; }

function main(){

var DRY_RUN = true;

var CHUNK = 250;

var dir = pickFolder("Select folder containing curated CSV");

if(!dir){ Session.Prompt("Cancelled.", promptOK); return; }

// Pick the newest CSV in the folder by a known prefix (customize if
needed)

var fso=new ActiveXObject("Scripting.FileSystemObject");

var folder=fso.GetFolder(dir);

var en=new Enumerator(folder.Files);

var newest=null, t=0;

for(;!en.atEnd(); en.moveNext()){

var f=en.item();

if(endsWith(f.Name.toLowerCase(), ".csv")){

var m=f.DateLastModified.getTime();

if(m\>t){ newest=f; t=m; }

}

}

if(!newest){ Session.Prompt("No CSV found.", promptOK); return; }

var ts=fso.OpenTextFile(newest.Path,1); // ForReading

// header

if(!ts.AtEndOfStream) ts.ReadLine();

var applied=0, considered=0, batch=0;

while(!ts.AtEndOfStream){

var line=ts.ReadLine();

if(trim(line)==="") continue;

// naive split (keep curation fields simple—avoid commas in cells)

var cells=line.split(",");

if(cells.length\<3) continue;

var apply=trim(cells\[0\]);

var eid = parseInt(cells\[1\],10);

var newStatus = trim(cells\[2\]);

considered++;

if(equalsIgnoreCase(apply,"YES") && eid\>0){

var e = Repository.GetElementByID(eid);

if(e && String(e.Status\|\|"") != newStatus){

if(!DRY_RUN){ e.Status=newStatus; e.Update(); applied++; }

batch++;

}

}

if(batch\>=CHUNK){

if(!DRY_RUN && applied\>0) Repository.RefreshModelView(0);

batch=0;

}

}

ts.Close();

if(!DRY_RUN && applied\>0) Repository.RefreshModelView(0);

Session.Output("CSV apply complete. Considered="+considered+"
Applied="+applied+" DRY_RUN="+DRY_RUN);

}

main();

**Why it scales:** minimal parsing, batched writes, rare refreshes, and
no per-row UI logs.

### Pattern E — Repository-wide “Exists?” checks via SQL

Before creating a new element (or relationship), **prove it doesn’t
already exist**—using a quick SQL existence test.

// -------------------------------------------------------

// Example 17.6 - Perf_ExistsCheck_SQL.js – JScript (ES3)

// Purpose: Quick existence test for (Name,Type)

// Note: Adjust SQL for your DB if needed; this is generic enough for
most back-ends

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function esc(s){ return String(s\|\|"").replace(/'/g, "''"); }

function between(h,a,b){ var i=h.indexOf(a); if(i\<0)return""; var
j=h.indexOf(b,i+a.length); return j\<0?"":h.substring(i+a.length,j); }

function existsByNameType(name, type){

var sql="SELECT TOP 1 Object_ID FROM t_object WHERE Name='"+esc(name)+"'
AND Object_Type='"+esc(type)+"'";

var xml=Repository.SQLQuery(sql);

var id=between(xml,"\<Object_ID\>","\</Object_ID\>");

return id!=="";

}

function main(){

var found = existsByNameType("Customer","Class");

Session.Output("Customer/Class exists? "+(found?"YES":"NO"));

}

main();

**Performance tip:** do this **before** expensive creation logic,
especially inside large importers.

### Pattern F — External Python for Heavy Lifting

When processing **very large** updates with lots of text/CSV/JSON
parsing, use Python for the parsing, then EA’s API for the write
boundary. (Bitness note from earlier chapters: use 32-bit Python to
match EA.)

\# -------------------------------------------------------

\# Example 17.7 - perf_apply_large_external.py – Python 3 (pywin32)

\# Purpose: Chunked status updates from a big CSV, with guards

\# Usage: python perf_apply_large_external.py input.csv

\# -------------------------------------------------------

import sys, csv, win32com.client

CHUNK = 500

def main(path):

ea = win32com.client.Dispatch("EA.App")

repo = ea.Repository

applied = 0

batch = 0

with open(path, newline="", encoding="utf-8") as f:

rdr = csv.DictReader(f)

for row in rdr:

if str(row.get("Apply","")).strip().lower() != "yes":

continue

eid = int(row\["ElementID"\])

status = row.get("NewStatus","").strip()

if not status:

continue

e = repo.GetElementByID(eid)

if e and str(e.Status or "") != status:

e.Status = status

e.Update()

applied += 1

batch += 1

if batch \>= CHUNK:

repo.RefreshModelView(0)

batch = 0

if applied:

repo.RefreshModelView(0)

print(f"Applied={applied}")

if \_\_name\_\_ == "\_\_main\_\_":

if len(sys.argv)\<2:

print("Usage: perf_apply_large_external.py \<input.csv\>")

else:

main(sys.argv\[1\])

**Why it’s fast:** Python’s CSV is robust; you perform only the
necessary EA updates, chunked with rare refreshes.

## Dos & Don’ts (cheat-sheet)

- **Do**: SQL for *find*, API for *write*.

- **Do**: Log to file instead of spamming Output.

- **Do**: Refresh UI once (or per big batch).

- **Do**: Short-circuit when the target state is already correct.

- **Don’t**: Recursively walk deep trees—prefer an iterative queue.

- **Don’t**: Multi-thread COM calls to EA—stick to single-threaded.

- **Don’t**: Write via SQL unless you fully understand EA’s schema
  (read-only SQL is fine; writes are risky).

## Putting It Together

For a **large governance fix** (e.g., add missing stereotype on 40k
classes):

1.  **Timing Harness**: wrap the whole run and log metrics.

2.  **SQL Find**: one query for candidate IDs.

3.  **Chunked Apply**: update in batches of ~250–500.

4.  **Low-noise logging**: a single CSV with “what changed.”

5.  **One refresh** at the end (or per batch).

Following these steps keeps your scripts fast enough for
enterprise-scale repositories and safe enough for governance.

# Chapter 18: Integrating with Workflows

Enterprise Architect is a powerful modelling tool, but if kept in
isolation it risks becoming a silo. Models are valuable only when they
connect to the wider enterprise environment — to planning tools,
collaboration platforms, version control systems, registries, and
analytics pipelines. Architects may capture brilliant structures in EA,
but if those structures cannot be accessed by colleagues in Jira, shared
in Confluence, tracked in Git, or exported to analytics platforms, then
their impact is limited.

This chapter explores the role of scripting and automation in
**integrating EA with enterprise workflows**. It explains why
integration matters, what types of systems are typically involved, and
how automation bridges the gap. It also discusses the cultural
implications: how integration makes models more visible, improves
collaboration, and embeds architecture more deeply into organisational
processes.

## Why Integration Matters

In most organisations, EA is not the system of record for requirements,
issues, or tasks. Those live in Jira, Azure DevOps, or ServiceNow. Nor
is EA the publishing platform for architecture views — that role is
filled by Confluence, SharePoint, or custom portals. Nor is EA the
analytics engine — data warehouses and BI tools play that part.

If EA is to have influence, it must connect. Integration ensures that
architecture does not sit in a closed repository but flows into the
daily tools of developers, analysts, managers, and executives. It turns
EA from a specialist tool into part of the wider enterprise nervous
system.

## The Role of Automation in Integration

Manual integration is possible but unsustainable. You could export CSVs
by hand, paste diagrams into Confluence, or retype requirements into
Jira. But these manual steps are slow, error-prone, and quickly
abandoned.

Automation transforms integration into a **repeatable, reliable
process**. Scripts can pull requirements from Jira nightly, export model
summaries to Confluence weekly, or commit EA script libraries into Git
with every change. Automation eliminates the friction that often
prevents integration from sticking.

## Common Integration Targets

The most frequent systems EA needs to connect with are:

- **Jira / Azure DevOps** — for requirements, user stories, and tasks.

- **Confluence / SharePoint** — for publishing models, governance
  reports, and guidance.

- **Git / Version Control** — for managing scripts, MDGs, and sometimes
  even model fragments.

- **Registries / Catalogs** — for synchronising metadata (applications,
  datasets, services).

- **Analytics Platforms** — for reporting, dashboards, and quality
  metrics.

Each of these integrations has different requirements, but the principle
is the same: use scripts to extract, transform, and push or pull data.

## Integration Approaches

### Integration via Exports

The simplest form of integration is export. Scripts can export EA
content to CSV, JSON, or XML, which is then consumed by another system.
For example:

- Exporting all Applications and their Owners to CSV for import into a
  CMDB.

- Exporting requirements to JSON for loading into Jira.

- Exporting governance reports to HTML for Confluence publishing.

Export-based integration is one-way but powerful. It is often the first
step towards tighter two-way sync.

### Integration via APIs

More advanced integration uses APIs. Many enterprise systems (Jira,
Confluence, ServiceNow) expose REST APIs. External EA scripts in Python
or C# can call these APIs to push or pull data in real time. For
example:

- A Python script reads new Jira issues and creates EA Requirements.

- A C# utility pushes EA diagrams as images into Confluence pages.

- A script updates ServiceNow CMDB records based on EA application data.

API integration requires authentication, error handling, and careful
mapping between EA objects and external entities, but it enables true
synchronisation.

### Integration with Git

Although EA itself is not a code repository, scripts and MDG definitions
benefit from version control. Git provides traceability, collaboration,
and rollback. By storing scripts and MDG XML in Git, teams can manage
them like any other software artefact.

Automation helps here too:

- Scripts can export to a file system where Git commits are triggered.

- AI can generate commit messages explaining changes.

- Governance scripts can check that repositories are up to date.

Git integration makes EA scripting part of the DevOps toolchain.

### Integration with Analytics

Another important integration is with analytics platforms. EA contains
rich metadata: numbers of requirements, traceability ratios, coverage
metrics. But EA’s own reporting is limited. Exporting to CSV, JSON, or
direct database queries allows BI tools like Power BI or Tableau to
visualise architecture quality.

Scripting plays a key role here:

- Automating exports to CSV nightly.

- Generating JSON snapshots for ingestion.

- Curating data (e.g., counting orphaned requirements).

This turns architecture from a static document into a measurable
process.

## The Cultural Dimension of Integration

Integration is not only technical; it changes how people perceive
architecture. When requirements flow from Jira into EA automatically,
architects are seen as part of the delivery pipeline, not an
afterthought. When governance reports appear in Confluence every week,
stakeholders see architecture as transparent and accountable. When
scripts push metadata into analytics dashboards, leaders see
architecture as measurable.

In this way, integration changes culture: it makes architecture visible,
relevant, and trusted.

## Risks of Integration

Integration is powerful but risky. Poorly designed integrations can:

- Flood EA with duplicates.

- Overwrite authoritative data incorrectly.

- Expose sensitive data via exports.

- Create brittle dependencies on API versions.

That is why governance principles still apply: dry-run modes, logging,
backups, and version control. Integration scripts should be treated with
the same rigour as any enterprise software.

## Examples

### HTTP from JScript (webhooks & simple POSTs)

EA’s JScript can call HTTP endpoints via **WinHTTP**. That’s enough to
send messages to ChatOps (Teams/Slack) or any webhook.

⚠️ JScript has **no JSON parser**. Prefer “write JSON out; parse/apply
externally.” For push-only notifications, build a small JSON string by
hand.

// -------------------------------------------------------

// Example 18.1 - WebhookNotify.js – JScript (ES3)

// Purpose: Send a simple JSON message to a webhook (e.g.
Teams/Slack/custom)

// Usage: Set WEBHOOK_URL; run to notify about the selected package

// Notes: No JSON.parse; we only build a tiny JSON string

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function main() {

var WEBHOOK_URL = "https://example.webhook/your-token"; // \<-- put your
webhook here

var pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { Session.Prompt("Select a package to announce.", promptOK);
return; }

// Build a tiny JSON body (escape quotes and backslashes)

var body = "{"

\+ "\\title\\:\\EA Notification\\,"

\+ "\\text\\:\\Package '" + jsonEscape(pkg.Name) + "' (ID " +
pkg.PackageID + ") was processed.\\"

\+ "}";

var ok = httpPostJson(WEBHOOK_URL, body, 15000);

Session.Output(ok ? "Webhook sent." : "Webhook failed.");

}

function httpPostJson(url, body, timeoutMs) {

try {

var http = new ActiveXObject("WinHttp.WinHttpRequest.5.1");

http.Open("POST", url, false);

http.SetTimeouts(5000, 5000, timeoutMs\|\|15000, timeoutMs\|\|15000); //
DNS/connect/send/receive

http.SetRequestHeader("Content-Type", "application/json");

http.Send(body);

var status = http.Status;

return status \>= 200 && status \< 300;

} catch(e) {

Session.Output("HTTP error: " + e.message);

return false;

}

}

function jsonEscape(s){ s=String(s\|\|""); return
s.replace(/\\/g,"\\\\").replace(/"/g,'\\"'); }

main();

**When to use:** status pings (“curation ready,” “governance run
finished”), small alerts, pipeline handoffs.

### Jira ⇄ EA (keys as tagged values)

Best practice: **store the Jira issue key on the EA element** (e.g.,
JiraKey tag). Use **external Python** to pull from Jira (robust JSON),
then create/update EA Requirements. This keeps identity stable and
avoids duplicates.

#### Import Jira issues → EA Requirements (external Python)

\# -------------------------------------------------------

\# Example 18.2 - jira_to_ea_import.py – Python 3 (pywin32, requests)

\# Purpose: Query Jira and sync to EA Requirements (store JiraKey as a
tag)

\# Safety: Idempotent by key; only updates when values differ

\# Usage: python jira_to_ea_import.py "https://your-jira" "JQL here"
1234

\# where 1234 is the target PackageID in EA

\# -------------------------------------------------------

import sys, requests, win32com.client

\# --- Config & secrets ---

JIRA_BASE = sys.argv\[1\] \# e.g., "https://yourcompany.atlassian.net"

JQL = sys.argv\[2\] \# e.g., 'project=ARCH AND issuetype=Requirement'

TARGET_PKG = int(sys.argv\[3\])

AUTH_USER = "\<jira_user_email\>" \# store securely in env/secret store
in real use

AUTH_TOKEN = "\<jira_api_token\>" \# never hardcode in production

def ea_get_tag(el, name):

tvs = el.TaggedValues

for i in range(tvs.Count):

tv = tvs.GetAt(i)

if tv.Name == name:

return tv.Value or ""

return ""

def ea_set_tag(el, name, value):

tvs = el.TaggedValues

for i in range(tvs.Count):

tv = tvs.GetAt(i)

if tv.Name == name:

tv.Value = value; tv.Update(); el.Update(); return

nt = tvs.AddNew(name, value)

nt.Update(); el.Update()

def find_by_name(pkg, name):

els = pkg.Elements

for i in range(els.Count):

e = els.GetAt(i)

if e.Name == name and e.Type == "Requirement":

return e

return None

def main():

\# --- Jira query ---

s = requests.Session()

s.auth = (AUTH_USER, AUTH_TOKEN)

s.headers.update({"Accept": "application/json"})

r = s.get(f"{JIRA_BASE}/rest/api/3/search", params={"jql": JQL,
"maxResults": 100})

r.raise_for_status()

issues = r.json()\["issues"\]

\# --- EA attach ---

ea = win32com.client.Dispatch("EA.App")

repo= ea.Repository

pkg = repo.GetPackageByID(TARGET_PKG)

created, updated = 0, 0

for it in issues:

key = it\["key"\]

fields= it\["fields"\]

name = fields.get("summary", key)

notes = fields.get("description") or ""

\# Try match by JiraKey tag first

match = None

els = pkg.Elements

for i in range(els.Count):

e = els.GetAt(i)

if ea_get_tag(e, "JiraKey") == key:

match = e; break

if not match:

\# fallback: by name

match = find_by_name(pkg, name)

if not match:

\# create new

e = pkg.Elements.AddNew(name, "Requirement")

e.Notes = notes

e.Update()

ea_set_tag(e, "JiraKey", key)

created += 1

else:

\# update if changed

dirty = False

if (match.Notes or "") != (notes or ""):

match.Notes = notes; dirty = True

if ea_get_tag(match, "JiraKey") != key:

ea_set_tag(match, "JiraKey", key); dirty = False \# tag helper already
updated

if dirty:

match.Update(); updated += 1

if created or updated:

repo.RefreshModelView(pkg.PackageID)

print(f"Done. Created={created}, Updated={updated}")

if \_\_name\_\_ == "\_\_main\_\_":

if len(sys.argv) \< 4:

print("Usage: python jira_to_ea_import.py \<base\> \<jql\>
\<package_id\>")

else:

main()

## Notes

- Use **API tokens** (don’t embed secrets in scripts; prefer env
  vars/secret stores).

- Maintain a **JiraKey** tag on each synced element.

- Extend mapping easily (priority → Status, components → tagged values,
  etc.).

### Publish to Confluence (page with a live table)

Typical flow: generate HTML/CSV **inside EA**, then **external Python**
updates a Confluence page with the content. Confluence Cloud expects
REST + JSON.

#### Export an HTML table from EA (in-EA)

// -------------------------------------------------------

// Example 18.3 - ExportHTML_Table.js – JScript (ES3)

// Purpose: Export selected package elements as a simple HTML table (for
Confluence)

// Output: Writes .html to chosen folder

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function pickFolder(msg){ var sh=new ActiveXObject("Shell.Application");
var f=sh.BrowseForFolder(0,msg,0,0); return f?f.Self.Path:null; }

function main(){

var pkg = Repository.GetTreeSelectedPackage();

if(!pkg){ Session.Prompt("Select a package.", promptOK); return; }

var dir = pickFolder("Select output folder for HTML");

if(!dir) return;

var fso=new ActiveXObject("Scripting.FileSystemObject");

var stamp=(new Date()).getTime();

var path = dir+"\\ea_table\_"+stamp+".html";

var file = fso.CreateTextFile(path, true);

file.WriteLine("\<table\>");

file.WriteLine("\<tr\>\<th\>ID\</th\>\<th\>Name\</th\>\<th\>Type\</th\>\<th\>Status\</th\>\</tr\>");

var els=pkg.Elements;

for (var i=0;i\<els.Count;i++){

var e=els.GetAt(i);

file.WriteLine("\<tr\>\<td\>"+e.ElementID+"\</td\>\<td\>"+html(e.Name)+"\</td\>\<td\>"+e.Type+"\</td\>\<td\>"+(e.Status\|\|"")+"\</td\>\</tr\>");

}

file.WriteLine("\</table\>");

file.Close();

Session.Output("HTML written → "+path);

}

function html(s){ s=String(s\|\|""); return
s.replace(/&/g,"&amp;").replace(/\</g,"&lt;").replace(/\>/g,"&gt;"); }

main();

#### Update or create a Confluence page (external Python)

\# -------------------------------------------------------

\# Example 18.4 - confluence_publish.py – Python 3 (requests)

\# Purpose: Create/update a Confluence page with HTML body

\# Usage: python confluence_publish.py SPACE PAGE_TITLE
path\to\ea_table.html

\# Notes: Uses "storage" format; increments version when updating

\# -------------------------------------------------------

import sys, requests, json

BASE = "https://your-domain.atlassian.net/wiki"

USER = "\<confluence_user_email\>"

TOKEN = "\<confluence_api_token\>"

def find_page(space, title, sess):

r = sess.get(f"{BASE}/rest/api/content", params={"spaceKey": space,
"title": title})

r.raise_for_status()

results = r.json().get("results", \[\])

return results\[0\] if results else None

def main():

if len(sys.argv) \< 4:

print("Usage: confluence_publish.py \<SPACE\> \<TITLE\> \<HTML_PATH\>")

return

space, title, html_path = sys.argv\[1\], sys.argv\[2\], sys.argv\[3\]

html = open(html_path, "r", encoding="utf-8").read()

s = requests.Session()

s.auth = (USER, TOKEN)

s.headers.update({"Content-Type": "application/json"})

existing = find_page(space, title, s)

if existing:

page_id = existing\["id"\]

ver = existing\["version"\]\["number"\] + 1

payload = {

"id": page_id,

"type": "page",

"title": title,

"version": {"number": ver},

"body": {"storage": {"value": html, "representation": "storage"}}

}

r = s.put(f"{BASE}/rest/api/content/{page_id}",
data=json.dumps(payload))

r.raise_for_status()

print(f"Updated page {title} (id={page_id}) to version {ver}")

else:

payload = {

"type":"page","title":title,"space":{"key":space},

"body":{"storage":{"value":html,"representation":"storage"}}

}

r = s.post(f"{BASE}/rest/api/content", data=json.dumps(payload))

r.raise_for_status()

print(f"Created page {title}")

if \_\_name\_\_ == "\_\_main\_\_":

main()

### Git: version control your exports (and script library)

A simple pattern: export CSV/JSON from EA, then **commit with Git**
using the system’s git CLI.

#### Run git add/commit from EA (JScript)

// -------------------------------------------------------

// Example 18.5 - GitCommit_ExportFolder.js – JScript (ES3)

// Purpose: Run 'git add' and 'git commit' for a chosen folder

// Usage: Prepare your folder as a git repo; run after exports

// Notes: Captures stdout/stderr; commit message is timestamped

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function pickFolder(m){ var sh=new ActiveXObject("Shell.Application");
var f=sh.BrowseForFolder(0,m,0,0); return f?f.Self.Path:null; }

function main(){

var dir = pickFolder("Select folder to commit (must be a git repo)");

if(!dir) return;

var shell = new ActiveXObject("WScript.Shell");

var cmdAdd = 'cmd /c cd /d "' + dir + '" && git add -A';

var cmdCommit = 'cmd /c cd /d "' + dir + '" && git commit -m "EA export
'+(new Date()).toISOString()+'"';

execAndLog(shell, cmdAdd);

execAndLog(shell, cmdCommit);

Session.Output("Git commit attempted. Review output above for
success/errors.");

}

function execAndLog(shell, cmd){

try{

var exec = shell.Exec(cmd);

while(!exec.StdOut.AtEndOfStream){
Session.Output(exec.StdOut.ReadLine()); }

while(!exec.StdErr.AtEndOfStream){ Session.Output("\[ERR\]
"+exec.StdErr.ReadLine()); }

}catch(e){

Session.Output("Exec error: " + e.message);

}

}

main();

Tip: Pair this with the **export scripts** from Chapter 8 to automate a
nightly “export → commit” job.

### Registry/Analytics: push EA metadata downstream

A common requirement is to feed a **registry** (e.g., a catalog or data
platform). Pattern:

1.  **Export** tidy JSON/CSV from EA (in-EA).

2.  **Push** to your API or storage (external Python with requests).

#### Export NDJSON (one JSON per line) inside EA

// -------------------------------------------------------

// Example 18.6 - Export_NDJSON.js – JScript (ES3)

// Purpose: Write NDJSON (line-delimited JSON) for easy ingestion

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function pickFolder(m){ var sh=new ActiveXObject("Shell.Application");
var f=sh.BrowseForFolder(0,m,0,0); return f?f.Self.Path:null; }

function main(){

var pkg = Repository.GetTreeSelectedPackage();

if(!pkg){ Session.Prompt("Select a package.", promptOK); return; }

var dir = pickFolder("Select output folder for NDJSON");

if(!dir) return;

var fso=new ActiveXObject("Scripting.FileSystemObject");

var path=dir+"\\ea_export\_"+(new Date()).getTime()+".ndjson";

var file=fso.CreateTextFile(path, true);

var els=pkg.Elements;

for (var i=0;i\<els.Count;i++){

var e=els.GetAt(i);

var json = "{"

\+ "\\id\\:" + e.ElementID + ","

\+ "\\guid\\:\\" + esc(e.ElementGUID) + "\\,"

\+ "\\name\\:\\" + esc(e.Name) + "\\,"

\+ "\\type\\:\\" + esc(e.Type) + "\\,"

\+ "\\status\\:\\" + esc(String(e.Status\|\|"")) + "\\"

\+ "}";

file.WriteLine(json);

}

file.Close();

Session.Output("NDJSON written → " + path);

}

function esc(s){ s=String(s\|\|""); return
s.replace(/\\/g,"\\\\").replace(/"/g,'\\"'); }

main();

#### Push NDJSON to your registry (external Python)

\# -------------------------------------------------------

\# Example 18.7 - push_ndjson.py – Python 3 (requests)

\# Purpose: Stream NDJSON lines to a registry endpoint

\# Usage: python push_ndjson.py https://registry.example/api/bulk
path\to\file.ndjson

\# -------------------------------------------------------

import sys, requests

def main():

if len(sys.argv) \< 3:

print("Usage: push_ndjson.py \<endpoint\> \<ndjson_path\>")

return

endpoint, path = sys.argv\[1\], sys.argv\[2\]

with open(path, "rb") as f:

r = requests.post(endpoint, data=f,
headers={"Content-Type":"application/x-ndjson"}, timeout=60)

r.raise_for_status()

print("Pushed NDJSON. Server:", r.status_code)

if \_\_name\_\_ == "\_\_main\_\_":

main()

## Secrets, auth & bitness (read this!)

- **Never hardcode secrets** in EA scripts. Use environment variables
  (via WScript.Shell.Environment("PROCESS")) or external secret stores.

- **Use API tokens** (Jira/Confluence) rather than passwords.

- **Bitness must match**: EA is typically **32-bit**; external Python
  should be **32-bit** to attach via COM.

- **Network constraints**: Corporate proxies/firewalls may require proxy
  settings; WinHTTP and requests both support proxies (configure in
  environment or code).

## Putting it together (one realistic flow)

1.  Nightly job (Task Scheduler/CI) runs **Python**:

- Query **Jira** (JQL) → update EA Requirements (store JiraKey).

- Export **HTML** table from EA.

- Update **Confluence** page with the new table.

- Export **NDJSON** and push to registry.

- git add/commit the export folder for traceability.

2.  EA users see fresh data in Confluence; governance can trace elements
    back to Jira; downstream teams ingest NDJSON.

## Troubleshooting quick wins

- **401/403**: bad token or wrong endpoint path/version (/api/2 vs
  /api/3).

- **SSL errors**: corporate MITM certs—install trust chain or use
  verify= with org CA (Python).

- **Timeouts**: increase receive timeout; batch large payloads.

- **Unicode**: prefer UTF-8 in Python; JScript file I/O defaults to
  ANSI—keep payloads simple or generate externally.

## Checklist (cheat-sheet)

- Keep identities in EA via **tagged values** (JiraKey, ExternalID).

- **Write in EA; parse outside** (JSON).

- Dry-run first; log to CSV/HTML for review.

- Use **git** for exported artifacts (history, diffs).

- Make small, composable scripts; orchestrate with Python/CI.

# Chapter 19: Add-ins vs Scripts

Up to this point, we have focused mainly on scripts that live inside
Enterprise Architect or run against it externally through the automation
interface. These approaches are flexible, fast to develop, and ideal for
governance checks, imports and exports, and targeted utilities. But
there comes a point when scripts start to feel limited. You may want
permanent menus, event handlers that react when users create elements,
or deeper integration with EA’s user interface. At this stage, you move
beyond scripts and begin thinking in terms of **Add-ins**.

This chapter explores the boundary between scripts and add-ins. It
explains what each approach is best suited for, why organisations
sometimes make the leap to add-ins, and what the trade-offs are in terms
of power, safety, and maintainability. The aim is not to suggest that
every script should become an add-in, but to show you the decision space
clearly so you can choose the right tool for the job.

## Scripts as the First Line of Automation

Scripts are the natural starting point for automation in EA. They are:

- **Easy to create**: no extra tools beyond EA itself.

- **Portable**: stored in the repository, available to all users.

- **Quick to test**: you can write a script in the morning and run it
  that afternoon.

For governance, imports/exports, and small utilities, scripts are ideal.
They reduce friction, allow experimentation, and empower modellers who
are not professional developers.

However, scripts also have **limitations**:

- They cannot add permanent menus or toolbars.

- They cannot hook into events (e.g. “element created”).

- They are tied to a specific repository rather than installed globally.

- They are confined to JScript or VBScript, with limited libraries.

When you hit these walls, it is time to consider add-ins.

## Add-ins as Compiled Extensions

An **Add-in** is a compiled .NET assembly (usually in C#) that EA loads
at startup. It is registered in the Windows Registry under the EAAddins
key, marked COM-visible, and referenced by EA as if it were part of the
application.

Add-ins can:

- Add menus and toolbars to EA’s UI.

- Respond to events like element creation, diagram opening, or project
  closing.

- Use the full power of .NET libraries, from JSON parsing to REST APIs.

- Provide custom docked windows and richer user interfaces.

In short, add-ins let you extend EA itself, turning one-off utilities
into permanent, user-friendly tools.

## Why Move from Script to Add-in?

Organisations usually move from script to add-in for one or more of
these reasons:

- **Distribution**: a script stored in one repository is not visible in
  another; an add-in installed on all workstations is.

- **Consistency**: add-ins provide the same menus for everyone, ensuring
  a common experience.

- **Events**: only add-ins can react to events (e.g. auto-tag new
  elements).

- **Professionalisation**: mature utilities become part of a toolset
  rather than ad hoc snippets.

- **Integration**: add-ins can use advanced libraries and UI frameworks.

## Trade-offs

The move to add-ins brings benefits, but also costs.

**Advantages of Add-ins:**

- Richer features (menus, events, UI).

- Strong typing (C#, VB.NET).

- Access to modern libraries.

- Professional distribution and versioning.

**Disadvantages of Add-ins:**

- More setup (Visual Studio, COM registration).

- Distribution overhead (must be installed on each machine).

- Debugging complexity (requires attaching to EA process).

- Higher governance burden (DLLs need version control and change
  management).

In other words, add-ins are heavier. They make sense when a solution is
stable and widely used, but they are overkill for experimental or
repository-specific tasks.

## Add-ins and Governance

One of the subtle reasons to move to add-ins is governance. Scripts are
flexible but ephemeral; anyone can change them in the repository.
Add-ins, by contrast, are compiled, versioned, and distributed. This
makes them better suited to regulated environments where tools must be
controlled.

For example, a bank may insist that only signed add-ins are used,
ensuring all automation has passed security checks. Scripts may still
exist for local use, but official tooling is delivered as add-ins.

## The Learning Curve

Writing add-ins requires more development skill than writing scripts.
You need to:

- Set up a Class Library project in Visual Studio.

- Add a reference to Interop.EA.dll.

- Mark the assembly COM-visible.

- Register it with regasm or an installer.

- Implement required methods like EA_Connect, EA_Disconnect,
  EA_GetMenuItems, and EA_MenuClick.

This is more demanding than writing JScript in EA’s built-in editor. But
it opens far greater possibilities.

## A Progressive Path

A useful way to think about the script/add-in distinction is as a path:

- **Scripts** — fast, flexible, repository-bound.

- **External Automation** — Python or C# utilities that integrate EA
  into enterprise workflows.

- **Add-ins** — compiled, distributed, integrated extensions.

Teams often move along this path naturally. A script solves a local
problem. Later it becomes an external utility. Finally, it matures into
an add-in for permanent use. Understanding this path helps you decide
when to invest in the extra effort of an add-in.

## Cultural Impact

The choice between scripts and add-ins also shapes team culture. Scripts
empower modellers; add-ins formalise tools. Too much reliance on add-ins
can discourage experimentation. Too much reliance on scripts can create
chaos. The healthiest culture balances the two: scripts for flexibility,
add-ins for stability.

## Risks of Add-ins

Because add-ins load at EA startup, errors in add-ins can be disruptive.
A badly written add-in may prevent menus from loading, slow down EA, or
crash the application. This risk means testing and version control are
even more critical than for scripts.

## Example

### Minimal C# Add-in

Here’s a **minimal C# Add-in**. It adds a menu under **Specialize →
MyAddin → Hello**. When clicked, it shows a message box.

// -------------------------------------------------------

// Example 19.21 - MyAddin.cs – Minimal EA Add-in

// Purpose: Demonstrate how to build a COM-visible add-in

// Notes:

// - Build as Class Library (.NET Framework, not .NET Core).

// - Mark assembly COM-visible.

// - Register DLL with regasm or installer.

// -------------------------------------------------------

using System;

using System.Runtime.InteropServices;

using EA; // Reference to Interop.EA.dll (from EA install folder)

using System.Windows.Forms;

namespace MyAddin

{

\[ComVisible(true)\] // Required for COM

\[ClassInterface(ClassInterfaceType.None)\]

public class MyAddinClass

{

// EA calls this at connection

public string EA_Connect(Repository Repository)

{

return "a string"; // Reserved, can be anything

}

public void EA_Disconnect()

{

// Cleanup if needed

}

// ---- Menu Integration ----

// Tell EA which menu root to show

public object EA_GetMenuItems(Repository Repository, string Location,
string MenuName)

{

if (MenuName == "")

return "MyAddin"; // Root menu

else if (MenuName == "MyAddin")

return "Hello"; // Submenu item

return "";

}

// Control enabled/disabled state

public bool EA_GetMenuState(Repository Repository, string Location,
string MenuName, string ItemName, ref bool IsEnabled, ref bool
IsChecked)

{

IsEnabled = true; // Always enabled

return true;

}

// Handle click events

public void EA_MenuClick(Repository Repository, string Location, string
MenuName, string ItemName)

{

if (MenuName == "MyAddin" && ItemName == "Hello")

{

MessageBox.Show("Hello from MyAddin!", "EA Add-in");

}

}

}

}

### Build & Register the Add-in

1.  In Visual Studio:

- Create a **Class Library (.NET Framework)** project (e.g., .NET
  Framework 4.7.2).

- Add reference to Interop.EA.dll (found in EA’s install folder).

- Ensure AssemblyInfo.cs has \[assembly: ComVisible(true)\].

2.  Build the DLL.

3.  Register it for COM (run as admin):

4.  regasm MyAddin.dll /codebase

5.  Add registry entry for EA (HKCU or HKLM):

6.  \[HKEY_CURRENT_USER\Software\Sparx Systems\EAAddins\MyAddin\]

7.  @="MyAddin.MyAddinClass"

8.  Restart EA → check **Specialize → Manage Add-ins**. Enable
    **MyAddin**.

## When to Migrate Script → Add-in

Stick with **Scripts** when:

- One-off bulk edits or imports.

- Repository-specific governance checks.

- You don’t need UI menus.

Move to **Add-ins** when:

- You want consistent menu items for all users.

- You need .NET libraries (e.g., JSON.NET, REST SDK).

- You want event handling (e.g., auto-tag new elements).

- Distribution is across many repositories.

## Migration Example

**Governance Script (inside EA)** → “Enforce Owner tag on all
Requirements.”  
When matured into an **Add-in**:

- Provide a permanent menu item *“Governance → Enforce Tags”*.

- Use events: EA_OnElementCreated → auto-add Owner tag.

- Add reporting form with filtering, progress bar, export button.

## Summary

- **Scripts** are lightweight, repository-local, and quick.

- **Add-ins** are heavy-duty, system-wide, and extensible.

- Migration path: prove with scripts → formalise as Add-in when stable.

- Minimal Add-in = COM-visible C# class, a registry key, and menu
  methods.

# Chapter 20: Troubleshooting

Every scripting environment has its quirks, and Enterprise Architect is
no exception. By now, you’ve learned how to navigate the API, use
patterns, enforce governance, and even integrate EA into wider
workflows. Yet no matter how careful you are, you will encounter
frustrating moments where “nothing happens” or “it worked yesterday but
not today.” These issues are not signs of failure — they are a normal
part of scripting EA.

This chapter collects the **most common errors and pitfalls** you will
run into, explains why they occur, and shows how to recognise them
quickly. It is less about teaching new capabilities and more about
providing a troubleshooting handbook. By knowing the usual suspects, you
can save hours of debugging.

## Why Troubleshooting Matters

When a script fails silently, it undermines trust. Users may stop
running governance checks if they think the results are unreliable.
Architects may give up on automation if every export requires trial and
error. Building confidence in scripting requires not only writing good
scripts but also being able to **diagnose problems fast**.

Troubleshooting is also essential for team knowledge transfer. If one
person understands the quirks but others do not, automation becomes
fragile. A shared troubleshooting guide empowers everyone to fix common
issues.

## The Nature of EA’s Quirks

Why does EA feel quirky to script against? A few reasons:

- **COM-based API**: EA exposes its object model through COM, an old but
  powerful technology with idiosyncrasies.

- **Legacy scripting engine**: JScript is stuck at ES3, which means
  modern constructs are missing.

- **UI lag**: EA’s interface does not always refresh automatically when
  the repository changes.

- **Database underpinnings**: EA stores content in relational tables,
  and API calls must keep schema integrity.

These constraints create subtle traps that new script writers fall into
again and again.

## The Usual Suspects

From years of practice and community wisdom, a handful of issues account
for the majority of problems:

- Forgetting Update() after setting a property.

- Forgetting RefreshModelView() after a bulk change.

- Confusing Stereotype with StereotypeEx.

- Treating EA collections as arrays (forEach instead of .GetAt()).

- Forward-deleting instead of backward-deleting.

- Misusing SQL (writing instead of reading).

- Encoding errors when exporting text.

- Failing to check ObjectType before casting.

These “usual suspects” are the core of this chapter.

### Silent Failures

One of the most frustrating experiences in EA scripting is the silent
failure: your script runs, no errors are thrown, but nothing changes. In
almost all cases, the culprit is forgetting Update(). EA only persists
changes when you explicitly call Update(). Without it, modifications
stay in memory and are discarded.

Another form of silent failure is forgetting to refresh the UI. Changes
exist in the database but are invisible until you call
Repository.RefreshModelView(). Recognising these two patterns will
resolve half your troubleshooting cases.

### Collection Confusion

Another common cause of errors is treating EA collections like standard
arrays. They are not. They only support .Count and .GetAt(). Any attempt
to use forEach, map, or array indexing will fail. Scripts that AI
generates often stumble here, which is why human review is essential.

### Deletion Pitfalls

Deleting items is particularly risky. Forward loops that delete as they
go will skip elements because the index shifts. The safe pattern is
always to delete backwards: from the last index down to zero. Forgetting
this leads to half-deleted collections or inconsistent states.

### SQL Misuse

EA allows direct SQL queries via Repository.SQLQuery() and
Repository.Execute(). The former is safe (read-only), the latter
dangerous (write). Beginners sometimes attempt to UPDATE directly via
SQL, bypassing the API. This risks corrupting the repository because the
API enforces consistency.

The safe rule is: **SQL for find, API for write**. Never write to the
database directly unless you absolutely understand the schema and
consequences.

### Encoding Problems

Because JScript’s FileSystemObject writes files in ANSI encoding,
exports often lose special characters (e.g. accented letters, non-Latin
scripts). This leads to CSVs with “???” instead of correct text. The fix
is to use external automation (Python, C#) for UTF-8 output. Inside EA,
the workaround is to stick to ASCII.

### ObjectType Confusion

Scripts often fail because the developer assumes a selected object is a
package or element, but the user actually selected a diagram or
attribute. The solution is always to check ObjectType before acting.
This prevents runtime errors and makes scripts more robust.

## The Value of Defensive Patterns

The best way to avoid troubleshooting later is to adopt defensive coding
patterns now:

- Wrap every modification in if (!DRY_RUN).

- Always check ObjectType.

- Use backward deletion.

- Always Update() and RefreshModelView().

- Validate stereotypes with StereotypeEx.

By embedding these patterns, you avoid the majority of common errors.

## Troubleshooting as a Team Resource

Troubleshooting knowledge should be shared, not hoarded. Teams benefit
from keeping a living “troubleshooting wiki” that documents issues
encountered and solutions. AI can also play a role: paste an error into
AI and ask for explanations. But the foundation is a shared
understanding of EA’s quirks, documented and available to all.

### Update() Forgotten

**Symptom**: You change an element property, run the script, and nothing
changes in EA.

**Cause**: EA requires Update() on nearly every object after
modification. Without it, changes stay in memory only.

#### Wrong

// ❌ Forgets Update()

var e = Repository.GetTreeSelectedObject();

e.Name = "NewName"; // appears to succeed, but won’t persist

// no e.Update()

#### Fixed

// ✅ Always call Update()

var e = Repository.GetTreeSelectedObject();

e.Name = "NewName";

e.Update(); // persist to repository

### RefreshModelView() Missing

**Symptom**: The change *did* persist (e.g., new name), but you don’t
see it in the Project Browser until you close/reopen EA.

**Cause**: EA’s UI cache isn’t automatically updated. Call
Repository.RefreshModelView() to refresh.

#### Fixed

var pkg = Repository.GetTreeSelectedPackage();

var e = pkg.Elements.AddNew("TempClass", "Class");

e.Update();

// Refresh the package tree so the user sees the new class

Repository.RefreshModelView(pkg.PackageID);

#### Wrong Method Name

**Symptom**: AI-generated code crashes with “function not defined.”

**Cause**: Different EA versions expose slightly different casing
(GetElementByGuid vs GetElementByGUID).

### Fix with wrapper

// ✅ Compatibility wrapper

function getElementByGuidSafe(guid) {

try { return Repository.GetElementByGuid(guid); }

catch(e) {

try { return Repository.GetElementByGUID(guid); }

catch(e2) { return null; }

}

}

### Collections Misused

**Symptom**: “Object doesn’t support property or method ‘forEach’” or
“undefined.”

**Cause**: EA collections are COM objects, not JS arrays. You must use
.Count and .GetAt(i).

#### Wrong

// ❌ This will fail

pkg.Elements.forEach(function(e){ Session.Output(e.Name); });

#### Fixed

// ✅ Correct

var els = pkg.Elements;

for (var i=0; i\<els.Count; i++) {

var e = els.GetAt(i);

Session.Output(e.Name);

}

### Delete Without Backwards Iteration

**Symptom**: Some elements are skipped when deleting in loops.

**Cause**: Deleting while looping forward shifts indices.

#### Wrong

// ❌ Deletes only half

for (var i=0; i\<pkg.Elements.Count; i++) {

pkg.Elements.DeleteAt(i, false);

}

#### Fixed

// ✅ Loop backwards

for (var i=pkg.Elements.Count-1; i\>=0; i--) {

pkg.Elements.DeleteAt(i, false);

}

Repository.RefreshModelView(pkg.PackageID);

### Unicode / Encoding Headaches

**Symptom**: Exported CSV shows “???” instead of accented characters.

**Cause**: EA’s JScript FileSystemObject writes in ANSI by default.

**Workaround:**

- Keep exports simple (ASCII where possible).

- If you need UTF-8: use external automation (Python/C#).

### External Python for UTF-8 CSV

\# utf8_export.py

import win32com.client, csv

ea = win32com.client.Dispatch("EA.App")

repo = ea.Repository

pkg = repo.GetTreeSelectedPackage()

with open("export.csv","w",newline="",encoding="utf-8") as f:

wr = csv.writer(f)

wr.writerow(\["ID","Name"\])

for i in range(pkg.Elements.Count):

e = pkg.Elements.GetAt(i)

wr.writerow(\[e.ElementID, e.Name\])

### Misusing Session.Output (too much logging)

**Symptom**: Script becomes slow or EA hangs.

**Cause**: Printing thousands of lines to EA’s Output tab is slow.

**Fix:**

- Use CSV/file logging for detail.

- Use Session.Output only for summary.

### API vs Direct SQL Write

**Symptom**: Repository corrupted or constraints broken.

**Cause**: Direct Repository.Execute("UPDATE…") writes to EA tables skip
API integrity.

**Rule**:

- Use Repository.SQLQuery() for *read-only*.

- Use object API (.Update()) for writes.

- Only use direct SQL writes if you fully understand EA’s schema (rare).

### ObjectType Confusion

**Symptom**: Code assumes everything from GetTreeSelectedObject() is an
element, but sometimes it’s a package or diagram.

**Fix**: Always check ObjectType.

#### Example

var obj = Repository.GetTreeSelectedObject();

if (obj.ObjectType == otPackage) {

Session.Output("Selected a package: " + obj.Name);

} else if (obj.ObjectType == otElement) {

Session.Output("Selected element: " + obj.Name);

} else {

Session.Output("Unsupported object type.");

}

## Safe Patterns Recap

- **Always Update()** after modifying objects.

- **Always RefreshModelView()** after changes if you want UI sync.

- **Loop with .Count / .GetAt(i)**, not forEach.

- **Delete backwards**.

- **Don’t rely on names alone**: use GUIDs or IDs.

- **Prefer API writes** over SQL.

- **Minimise Session.Output** inside large loops.

- **Check ObjectType** before casting.

- **Expect case differences** in API (GUID vs Guid).

- **Export UTF-8 externally** if needed.

# Chapter 21: Reference 

This section is your **desk-side companion**. It gathers the essentials
you’ll need regularly: the EA object hierarchy, quick SQL snippets, a
reusable script header template, and a logging helper you can drop into
any script.

## EA Object Model Map (Condensed)

EA’s Automation API is huge, but most scripts use a handful of objects.

> **Repository**
>
> **├─ Models (Collection of Package)**
>
> **│ └─ Package**
>
> **│ ├─ Packages (child packages)**
>
> **│ ├─ Elements**
>
> **│ │ └─ Element**
>
> **│ │ ├─ Attributes**
>
> **│ │ ├─ Methods**
>
> **│ │ ├─ Connectors**
>
> **│ │ └─ TaggedValues**
>
> **│ └─ Diagrams**
>
> **│ └─ Diagram**
>
> **│ └─ DiagramObjects**
>
> **└─ Methods**
>
> **├─ GetTreeSelectedPackage()**
>
> **├─ GetTreeSelectedObject()**
>
> **├─ GetElementByID(id)**
>
> **├─ GetElementByGUID(guid)**
>
> **├─ SQLQuery(sql)**
>
> **└─ RefreshModelView(id)**

**Key points**

- Everything starts with Repository.

- Package.Elements gives semantic content.

- Element.Connectors gives relationships.

- Diagram.DiagramObjects gives *visual instances*, not the element
  itself.

- Always Update() after modification.

- Use RefreshModelView() for UI sync.

## SQL Cheat-Sheet (Read-only)

EA stores models in tables. Use **Repository.SQLQuery()** (safe,
read-only) to fetch information quickly. It returns XML you parse with
string functions.

// -------------------------------------------------------

// Example 21.1 - SQLQuery_Classes.js – JScript (ES3)

// Purpose: Query DB for all Class names

// -------------------------------------------------------

!INC Local Scripts.EAConstants-JScript

function between(h,a,b){

var i=h.indexOf(a); if(i\<0)return"";

var j=h.indexOf(b,i+a.length); if(j\<0)return"";

return h.substring(i+a.length,j);

}

function main(){

var sql = "SELECT Name FROM t_object WHERE Object_Type='Class'";

var xml = Repository.SQLQuery(sql);

var rows = xml.split("\<Row\>");

for (var i=1;i\<rows.length;i++){

var nm = between(rows\[i\],"\<Name\>","\</Name\>");

Session.Output("Class: "+nm);

}

}

main();

### Count Requirements

var sql = "SELECT COUNT(\*) AS CNT FROM t_object WHERE
Object_Type='Requirement'";

var xml = Repository.SQLQuery(sql);

Session.Output("Requirement count =
"+between(xml,"\<CNT\>","\</CNT\>"));

**Tips**

- Table t_object → elements.

- Table t_package → packages.

- Table t_connector → relationships.

- Use Repository.SQLQuery only; avoid Repository.Execute for writes
  (unsafe).

## Standard Script Header Template

Consistency makes scripts maintainable. Always include a header like
this:

// -------------------------------------------------------

// Script Name: \[NameHere\]

// Purpose: \[What the script does in plain language\]

// Usage: \[How to run it; context required\]

// Assumptions: \[What must be selected; ES3 runtime only\]

// Safety: \[Read-only / DRY_RUN / destructive with caution\]

// Dependencies: \[Shared helpers, external tools\]

// Update history:

// v1.0 (2025-08-26) – Initial

// v1.1 (2025-09-01) – Added dry-run flag

// -------------------------------------------------------

## Logging Helper Snippet

Logging is essential for dry-run, auditing, and governance. Use a helper
that writes both to Output and CSV.

// -------------------------------------------------------

// Logger.js – reusable helper

// Purpose: Write logs both to Output tab and CSV

// -------------------------------------------------------

function Logger(tabName, filePath){

this.tab = tabName;

Repository.CreateOutputTab(tabName);

Repository.ClearOutput(tabName);

var fso = new ActiveXObject("Scripting.FileSystemObject");

var file = fso.OpenTextFile(filePath, 8 /\*append\*/, true
/\*create\*/);

this.log = function(msg){

Session.Output(msg);

file.WriteLine(msg);

};

this.close = function(){ file.Close(); };

}

// Usage example:

function main(){

var log = new Logger("MyScript","C:\\temp\\myscript.log");

log.log("Script started.");

// ... your logic ...

log.close();

}

## Common ObjectType Values

When checking what the user has selected:

- otElement (4) — an element (Class, Requirement, etc.).

- otPackage (5) — a package.

- otDiagram (8) — a diagram.

- otAttribute (9) — a class attribute.

- otMethod (10) — a method.

**Pattern**

var obj = Repository.GetTreeSelectedObject();

if (obj.ObjectType == otPackage) {

Session.Output("Package: " + obj.Name);

} else if (obj.ObjectType == otElement) {

Session.Output("Element: " + obj.Name);

}

## Common Errors Quick Table

| Symptom | Likely Cause | Fix |
|----|----|----|
| Change not saved | Forgot .Update() | Always call Update() |
| Change saved but not visible | Forgot RefreshModelView() | Refresh at end of script |
| “Object doesn’t support forEach” | Tried JS array methods on collections | Use .Count / .GetAt(i) |
| Deletes skip items | Looping forward while deleting | Loop backwards |
| Characters “???” in export | ANSI encoding in JScript FSO | Use Python/C# for UTF-8 |

# 

## Quick Reuse Snippets

### Safe delete loop

for (var i=col.Count-1; i\>=0; i--) col.DeleteAt(i,false);

### DRY_RUN guard

if (!DRY_RUN) { e.Update(); }

### String trim

function trim(s){return
s==null?"":String(s).replace(/^\s+\|\s+\$/g,"");}

## Summary

This reference chapter gives you the **essentials at a glance**:

- The object model map.

- SQL query patterns.

- Standard headers.

- Logging helper.

- Common ObjectTypes and errors.

Keep it open as your **daily cheat-sheet**: it saves time, avoids
mistakes, and makes your scripts consistent.**  **

Appendices

# Appendix A: Scripting Constraints

These are the **house rules** for safe scripting in Sparx EA, based on
your *Sparx scripting constraints.txt* and reinforced by experience.

## A.1 Language Constraints

- EA’s internal scripting engine supports VBScript, JScript (Microsoft
  JScript, ES3), and JavaScript (recent builds).

- Always assume ES3:

  - Use var (no let/const).

  - No arrow functions (()=\>).

  - No forEach/map (EA collections are COM, not arrays).

  - No JSON.parse/stringify (manual or external only).

## A.2 Object Handling

- EA collections → .Count and .GetAt(i).

- Always .Update() after modifying an object.

- Always Repository.RefreshModelView() to sync UI.

- Delete loops → iterate backwards.

- Check ObjectType before assuming Package/Element.

## A.3 File I/O

- JScript’s FileSystemObject writes ANSI only.

- For **UTF-8**, use external automation (Python/C#).

- Always select an **output directory**, not a filename; filenames must
  be auto-derived by script.

## A.4 Safety Rules

- Every modifying script must include a DRY_RUN flag, default true.

- Every modifying script must log actions (at least to Output tab;
  ideally to CSV).

- All scripts must start with a **verbose header** (purpose, usage,
  assumptions, safety, dependencies, update history).

# Appendix B: External Automation

Sometimes EA’s internal scripting isn’t enough. That’s when you use
**COM automation** from languages like **Python, C#, Java**.

## B.1 Attaching Externally

- Launch EA first, or start via COM.

- Use the EA.App ProgID:

> import win32com.client
>
> ea = win32com.client.Dispatch("EA.App")
>
> repo = ea.Repository

- In C#, add reference to Interop.EA.dll (from EA install folder).

## B.2 When to Go External

- You need **UTF-8 I/O** (CSV/JSON).

- You need **HTTP/REST APIs** (Jira, Confluence, registries).

- You need **better libraries** (Python csv, json; C# Newtonsoft.Json).

- You want CI/CD automation or Git integration.

## B.3 Bitness

- EA is typically **32-bit**.

- Python/C# must match bitness (32-bit Python to attach via COM).

- Check Interop.EA.dll reference matches installed EA.

## B.4 Add-ins

- C# Class Library DLL, COM-visible, registry entry under EAAddins.

- EA calls known methods: EA_Connect, EA_GetMenuItems, EA_MenuClick,
  etc.

- Use Add-ins when you need: permanent menus, event handling, richer UI.

# Appendix C: Glossary of Terms

**Add-in** — A COM-visible DLL (C# or VB.NET) that EA loads at startup,
adding menus, toolbars, and event handlers.

**API (Automation Interface)** — The COM object model exposed by EA
(Repository, Package, Element, Connector, etc.).

**Attribute** — A property of a Class element; accessed via
Element.Attributes.

**Connector** — A relationship between elements (e.g., Association,
Realisation). Access via Element.Connectors.

**DiagramObject** — A visual instance of an element on a diagram; stores
coordinates and style, not semantics.

**Dry Run (DRY_RUN)** — A safety flag in scripts: simulate changes and
log, but don’t commit updates.

**Element** — A modelled item (Class, Requirement, UseCase, Component,
etc.).

**GUID** — Global Unique Identifier string assigned to every element,
connector, and package. Prefer GUIDs for stable identification.

**MDG Technology** — A profile/extension package for EA (stereotypes,
tagged values, toolboxes, etc.). Scripts must use StereotypeEx for full
qualified stereotypes (profile::stereo).

**ObjectType** — Integer enum identifying what an object is (otElement,
otPackage, otDiagram, etc.).

**Package** — Container for elements, diagrams, and child packages.

**Repository** — Root of the automation API; represents the current EA
model (QEA/EAP file or DB connection).

**SQLQuery** — Repository.SQLQuery(sql) executes a SQL SELECT against
EA’s database and returns XML. Use only for *reads*.

**Update()** — Method to persist changes to database; required after
modifying any object.

**WinHTTP** — Windows COM object (WinHttp.WinHttpRequest.5.1) usable
from JScript for basic HTTP requests.

# Appendix D: Quick Reference

| Error Symptom | Likely Cause | Fix |
|----|----|----|
| Change not saved | Forgot .Update() | Always update objects |
| Change not visible until restart | Forgot Repository.RefreshModelView() | Refresh after updates |
| “forEach is not a function” | Used JS array method on EA collection | Use .Count/.GetAt(i) |
| Deletes skip items | Forward loop while deleting | Loop backwards |
| UTF-8 characters become “???” | FSO writes ANSI only | Use external Python/C# |
| “Method not found: GetElementByGUID” | API casing differences | Use safe wrapper (Guid/GUID) |
| Object type mismatch | Assumed element, got package/diagram | Always check ObjectType |

# Appendix E: External Automation Setup

This appendix provides the reusable EAConnect helper class plus the
configuration details required to build external automation tools
against Enterprise Architect (EA). It is intended as the “plumbing”
layer behind the example in **Chapter 6 – External Automation**.

## E.1 Purpose

The EAConnect helper abstracts the complexities of EA’s COM interface
and standardises safety practices:

- Attaching to or launching EA consistently

- Waiting for the Repository to become available

- Opening models automatically if needed

- Handling bitness and Interop.EA.dll

- Providing safe wrappers for common tasks (find package, add element,
  add tagged value)

- Enforcing **dry-run by default**

- Writing CSV audit logs with auto-derived filenames

- Refreshing EA’s UI at sensible points

With this helper, your utilities focus on intent rather than
boilerplate.

## E.2 Usage

A minimal program using the helper:

using System;

using EA;

using EA.Automation; // the helper namespace

class Program

{

\[STAThread\]

static void Main(string\[\] args)

{

using var ea = EAConnect.AttachOrLaunch(new EAConnect.Options { ShowUI =
true });

Package pkg = ea.GetSelectedPackageOrRoot();

var result = EAConnect.AddElement(ea.Repo, pkg, "DemoClass", "Class",

"Created by EAConnect.", dryRun: true);

Console.WriteLine(result.Summary);

}

}

This pattern keeps the Program.cs short and declarative. All detailed
logic resides in the helper.

## E.3 The EAConnect Helper Class

//
=======================================================================

// File: EAConnect.cs

// Project: EA Automation Helper

// Author: \<Your Name\>

// Created: 2025-08-31

// Last Update: 2025-08-31

//

// PURPOSE

// -------

// Provides a safe, reusable abstraction over EA’s COM automation API.

// Handles: attach/launch, repository polling, model open, package

// resolution,

// element creation, tagged value creation, CSV logging, and UI refresh.

//

// USAGE

// -----

// using var ea = EAConnect.AttachOrLaunch(new EAConnect.Options {

// ShowUI = true });

// var pkg = ea.GetSelectedPackageOrRoot();

// var result = EAConnect.AddElement(ea.Repo, pkg, "NewClass", "Class",

// "Notes", true);

// Console.WriteLine(result.Summary);

//

// ASSUMPTIONS

// -----------

// - EA is installed and COM-registered (ProgID = "EA.App").

// - Interop.EA.dll referenced (from EA install folder).

// - Bitness of project matches EA (x64 for EA 64-bit; x86 for 32-bit).

// - .NET project marked \[STAThread\] on entry point.

//

// SAFETY

// ------

// - Dry-run enabled by default in sample programs.

// - CSV audit logging for all writes.

// - UI refresh at batch boundaries only.

//

// DEPENDENCIES

// ------------

// - System.Runtime.InteropServices (Marshal.GetActiveObject).

// - Interop.EA.dll.

//

// UPDATE HISTORY

// --------------

// - 2025-08-31: Initial helper version.

//
=======================================================================

using System;

using System.IO;

using System.Runtime.InteropServices;

using EA;

namespace EA.Automation

{

public static class EAConnect

{

// Encapsulates a connected EA session

public sealed class Session : IDisposable

{

public EA.App App { get; }

public EA.Repository Repo { get; }

internal Session(EA.App app, EA.Repository repo)

{

App = app;

Repo = repo;

}

public Package GetSelectedPackageOrRoot()

{

Package? pkg = Repo.GetTreeSelectedPackage();

if (pkg != null) return pkg;

if (Repo.Models.Count \> 0) return

> (Package)Repo.Models.GetAt(0);

throw new InvalidOperationException(

> "No package available in repository.");

}

public void Dispose()

{

// Release COM references cleanly

Marshal.ReleaseComObject(Repo);

Marshal.ReleaseComObject(App);

}

}

// Options for attaching or launching EA

public sealed class Options

{

public bool PreferAttach { get; set; } = true;

public bool LaunchIfNotRunning { get; set; } = true;

public string? ModelPath { get; set; }

public bool ShowUI { get; set; } = true;

public int StartupWaitMs { get; set; } = 1500;

public int RepoPollMs { get; set; } = 100;

public int RepoPollMax { get; set; } = 50;

}

// Attach to EA or launch new instance

public static Session AttachOrLaunch(Options? options = null)

{

options ??= new Options();

EA.App? app = null;

if (options.PreferAttach)

{

try { app = (EA.App)Marshal.GetActiveObject("EA.App"); }

catch { /\* none running \*/ }

}

if (app == null && options.LaunchIfNotRunning)

{

> Type t = Type.GetTypeFromProgID("EA.App") ?? throw new
>
> InvalidOperationException("EA not installed.");

app = (EA.App)Activator.CreateInstance(t)!;

if (!options.ShowUI) app.Visible = false;

System.Threading.Thread.Sleep(options.StartupWaitMs);

}

if (app == null) throw new InvalidOperationException(

> "Unable to connect to EA.");

EA.Repository repo = app.Repository;

// Poll until repository becomes available

int polls = 0;

while (repo == null && polls \< options.RepoPollMax)

{

System.Threading.Thread.Sleep(options.RepoPollMs);

repo = app.Repository;

polls++;

}

if (repo == null) throw new InvalidOperationException("

> EA.Repository did not initialise.");

if (!string.IsNullOrWhiteSpace(options.ModelPath) &&

> string.IsNullOrWhiteSpace(repo.ConnectionString))

repo.OpenFile(options.ModelPath);

return new Session(app, repo);

}

// Result container

public sealed class Result

{

public int UpdatedCount { get; init; }

public string Summary { get; init; } = "";

public string? LogPath { get; init; }

public string? ElementGuid { get; init; }

}

// Add a new element safely

public static Result AddElement(Repository repo,

> Package targetPackage,
>
> string name,
>
> string type,
>
> string? notes, bool dryRun = true, CsvLogger? logger = null)

{

var el = (Element)targetPackage.Elements.AddNew(name, type);

if (!string.IsNullOrWhiteSpace(notes)) el.Notes = notes;

if (dryRun)

{

logger?.WriteRow(DateTime.Now, "DRYRUN",

> targetPackage.PackageID,
>
> "", name, type, notes ?? "");

return new Result { UpdatedCount = 0,

> Summary = \$"\[DRYRUN\] Would create: {name} ({type})" };

}

if (!el.Update())

throw new InvalidOperationException(

> "Element.Update() failed.");

repo.RefreshModelView(targetPackage.PackageID);

logger?.WriteRow(DateTime.Now, "CREATE",

> targetPackage.PackageID,
>
> el.ElementGUID, name, type, notes ?? "");

return new Result

{

UpdatedCount = 1,

Summary = \$"Created element: {name} ({type})",

ElementGuid = el.ElementGUID,

LogPath = logger?.Path

};

}

// CSV logger

public sealed class CsvLogger : IDisposable

{

private readonly StreamWriter \_writer;

public string Path { get; }

private CsvLogger(string path)

{

Path = path;

\_writer = new StreamWriter(path, append: false,

> System.Text.Encoding.UTF8);

}

public static CsvLogger Open(string path) =\>

> new CsvLogger(path);

public void WriteHeader(string header) =\>

\_writer.WriteLine(header);

public void WriteRow(params object?\[\] cols)

=\> \_writer.WriteLine(string.Join(",",

> Array.ConvertAll(cols, c =\> c?.ToString() ?? "")));

public void Close() =\> \_writer.Flush();

public void Dispose() =\> \_writer.Dispose();

}

}

}

## E.4 Configuration & Setup

### Bitness

- EA 16+ is usually **64-bit**.

- Match your project’s \<PlatformTarget\> to EA’s bitness (x64 or x86).

### Interop.EA.dll

- Found in EA install folder.

- Add as a reference in your .NET project.

### STAThread

- COM automation requires \[STAThread\] on your entry point.

### Model Files

- Use .qea / .qeax / .eapx.

- Options.ModelPath can auto-open a file if none is open.

### Dry Run & Logging

- Always start in dryRun = true.

- Review the generated CSV log before committing real updates.

### Distribution

- Package as a console utility or integrate into CI/CD.

- Keep EAConnect.cs in a shared library for consistency.

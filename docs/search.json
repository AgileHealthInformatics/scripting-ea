[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Scripting Sparx Enterprise Architect: A Practical Handbook",
    "section": "",
    "text": "Scripting Sparx Enterprise Architect\nSparx Enterprise Architect is widely used as a modelling tool.\nThis handbook shows how to turn it into a scripting-enabled modelling environment that is disciplined, repeatable, and integrated with the wider lifecycle of your organisation.\nIt is written for practitioners who already use EA in anger and want to go further: automating routine tasks, enforcing modelling standards, and treating scripts as first-class architectural artefacts rather than throwaway experiments.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Scripting Sparx Enterprise Architect</span>"
    ]
  },
  {
    "objectID": "index.html#how-to-use-this-book",
    "href": "index.html#how-to-use-this-book",
    "title": "Scripting Sparx Enterprise Architect: A Practical Handbook",
    "section": "How to use this book",
    "text": "How to use this book\nYou can navigate through the rest of the chapters using the menu on the left. All code examples are available as text within the book, and you are encouraged to copy, adapt, and extend them for your own work.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Scripting Sparx Enterprise Architect</span>"
    ]
  },
  {
    "objectID": "01-Preface.html",
    "href": "01-Preface.html",
    "title": "Preface",
    "section": "",
    "text": "Scripting in Sparx Enterprise Architect (EA) has always been both an art and a science.\nMost modellers discover the scripting window by accident, write a few lines of JScript or VBScript, and quickly realise that the possibilities extend far beyond simple automation.\nA well-structured script can transform EA from a drawing tool into a complete modelling environment—one that enforces standards, generates documentation, and maintains semantic consistency across large repositories.\nThis handbook was written for practitioners who have reached that moment of discovery and want to go further.\nIt assumes you already understand EA’s modelling concepts but want to learn how to harness its automation interface responsibly and effectively.\nEach chapter builds practical skills through worked examples, annotated listings, and clear explanations of what is happening behind the scenes.\nThe code examples use a deliberately verbose commenting style.\nThis reflects the author’s conviction that scripts in EA are not disposable experiments but integral parts of the architectural record.\nA script that can explain itself is a script that can be maintained, audited, and reused.\nYou will encounter snippets written in JScript, VBScript, and Python, each chosen for a particular purpose.\nJScript remains the most widely used within EA because of its direct integration and immediate execution.\nVBScript appears in legacy environments and in examples where readability or COM automation syntax is clearer.\nPython is included to illustrate how EA can be automated externally through its COM interface, opening the door to advanced analytics, testing, and integration pipelines.\nBeyond code, this book emphasises discipline.\nAutomation without discipline quickly becomes chaos.\nBy treating scripts as first-class architectural artefacts—version-controlled, documented, and tested—you build confidence not only in your tools but in the models that depend on them.\nThe examples that follow have been developed and refined through real-world use across government, healthcare, and defence projects.\nThey are designed to be copied, adapted, and improved.\nEach one begins with a clear purpose, a short description of assumptions, and a structured header that records when and why it was written.\nTogether they form a working library that you can evolve to suit your own organisation.\nMy hope is that this book helps you move from drawing diagrams to engineering models—from manipulating shapes on a screen to crafting automated reasoning tools that truly represent the systems you design.\nIf it inspires you to share your own scripts, extend these techniques, or simply think differently about what EA can become, it will have achieved its purpose.\nTito Castillo\nLondon, 2025",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html",
    "href": "02-System.Object[].html",
    "title": "Chapter 1: Why Script EA?",
    "section": "",
    "text": "Benefits of Automation in Modelling\nEnterprise Architect is a powerful modelling environment out of the box. You can draw diagrams, generate documentation, and configure Model Driven Generation (MDG) technologies without touching a single line of code. So why would anyone want to add scripting on top?\nThe answer is the same in modelling as it is in software engineering: automation saves time, reduces errors, and enforces consistency. Every modeller has encountered repetitive or fiddly tasks that drag attention away from design thinking. With scripting, you can let the tool do the heavy lifting.\nScripting opens up the underlying API of EA. That API gives you programmatic access to repositories, packages, elements, connectors, attributes, tagged values, and diagrams. With it you can:\nAutomation is not about doing something new, but about doing the same things faster, more reliably, and at greater scale.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#benefits-of-automation-in-modelling",
    "href": "02-System.Object[].html#benefits-of-automation-in-modelling",
    "title": "Chapter 1: Why Script EA?",
    "section": "",
    "text": "Eliminate repetition. Instead of manually renaming hundreds of elements, you can script a simple loop that applies a naming rule across the entire model.\nStandardise quality. Governance checks, linting rules, and model “smell” detection can run in seconds rather than hours of manual review.\nAccelerate integration. Exports to CSV, JSON, or XML can be automated. You can generate reports in custom formats, or sync model content with Jira, Confluence, or Git.\nBoost productivity. What once took hours of manual clicking can be done in minutes — freeing modellers to focus on architecture, not administration.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#typical-use-cases",
    "href": "02-System.Object[].html#typical-use-cases",
    "title": "Chapter 1: Why Script EA?",
    "section": "Typical Use Cases",
    "text": "Typical Use Cases\nSome of the most common applications of EA scripting include:\n\nBulk editing. Update tagged values, stereotypes, or connector types across entire packages.\nModel hygiene. Detect and fix duplicates, missing names, or invalid references.\nData imports. Read CSV or Excel files and convert them into EA elements automatically.\nRound-tripping. Export a model to JSON or Excel, allow external review, and then re-import changes.\nGovernance and QA. Apply rules such as “all classes must have documentation” or “all business processes must trace to capabilities.”\nIntegration. Connect EA to external tools — e.g. push backlog items into Jira, or register metadata in a catalogue.\n\nEach of these tasks is achievable through EA’s menus, but scripting transforms them from manual chores into repeatable processes.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#when-not-to-script",
    "href": "02-System.Object[].html#when-not-to-script",
    "title": "Chapter 1: Why Script EA?",
    "section": "When Not to Script",
    "text": "When Not to Script\nNot everything benefits from automation. EA already has built-in features that solve common problems. Before reaching for the scripting console, ask:\n\nIs there a native feature? Diagram filters, search definitions, model validation, and MDG profiles often cover the same ground.\nIs the effort justified? Writing, testing, and maintaining scripts takes time. A one-off change to five elements is faster by hand.\nCould it cause damage? Poorly written scripts can corrupt a model — deleting content, overwriting GUIDs, or applying unintended changes at scale.\n\nThe golden rule: script only when the benefit outweighs the risk and effort.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#why-scripting-matters-for-governance",
    "href": "02-System.Object[].html#why-scripting-matters-for-governance",
    "title": "Chapter 1: Why Script EA?",
    "section": "Why Scripting Matters for Governance",
    "text": "Why Scripting Matters for Governance\nBeyond productivity, scripting is one of the strongest tools for governance. A script does not forget the rules. It applies the same checks the same way every time. That makes it a reliable companion in quality assurance, regulatory compliance, or enterprise standards adoption.\nFor example, a governance script can enforce naming conventions or ensure that all system components are linked to business capabilities. This kind of automation embeds policy into practice — turning guidelines into enforceable, repeatable checks.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#your-first-hello-ea-script",
    "href": "02-System.Object[].html#your-first-hello-ea-script",
    "title": "Chapter 1: Why Script EA?",
    "section": "Your First “Hello EA” Script",
    "text": "Your First “Hello EA” Script\nBefore diving into the technicalities of scripting languages and APIs in Chapter 2, it is worth seeing what a minimal script looks like. The following example is deliberately simple: it retrieves the package currently selected in the Project Browser and lists all the elements it contains.\n\n\nExample 1.1 - HelloEA\n\n//\n// -----------------------------------------------------------------\n// Example 1.1 – HelloEA\n// Purpose: Output the names of all elements in the selected package\n// -----------------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() \n  {\n  var package = Repository.GetTreeSelectedPackage();\n  if (!package) \n    {\n    Session.Prompt(\"Please select a package in the Project Browser.\", promptOK);\n    return;\n    }\n\n  var elements = package.Elements;\n  for (var i = 0; i &lt; elements.Count; i++) \n    {\n    var element = elements.GetAt(i);\n    Session.Output(\"Element: \" + element.Name);\n    }\n  }\nmain();\n\nRun this script from the Scripts window after selecting a package in the Project Browser. The output window will list the names of each element in that package. It may not look impressive, but this is the scripting equivalent of “Hello World.” It proves the loop works, the API responds, and you are in control.\nThis tiny fragment also illustrates some key rules that will come up repeatedly in later chapters:\n\nEA collections (like package.Elements) are not arrays, so you use .Count and .GetAt(i).\nUpdate() is required after any change to persist modifications.\nSession.Output() is your friend when debugging.\n\nWith this in place, you have taken the first step from manual modeller to toolsmith — someone who bends the tool to fit the workflow, rather than the other way round.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#safe-practice-the-dry-run-principle",
    "href": "02-System.Object[].html#safe-practice-the-dry-run-principle",
    "title": "Chapter 1: Why Script EA?",
    "section": "Safe Practice: The Dry Run Principle",
    "text": "Safe Practice: The Dry Run Principle\nThroughout this handbook, you will notice a recurring pattern: every modifying script begins with a line like var DRY_RUN = true;. This is not cosmetic. It is the single most important safety feature in EA scripting. A dry run means the script logs what it would do, but does not commit changes. Only once the log looks correct do you flip DRY_RUN = false and let the script update the repository.\nThis principle is vital because EA does not have a transaction rollback. Once you delete, it is gone. Once you rename, it sticks. Scripts without dry-run mode are dangerous. Scripts with dry-run mode are tools of governance.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#a-different-way-of-modelling",
    "href": "02-System.Object[].html#a-different-way-of-modelling",
    "title": "Chapter 1: Why Script EA?",
    "section": "A Different Way of Modelling",
    "text": "A Different Way of Modelling\nScripting changes the way you think about modelling. Instead of asking “what diagram should I draw?” you begin to ask “what structure should I generate?”. You start to see the repository as data, not just pictures. A model becomes a dataset: a structured set of packages, elements, and relationships. Scripting makes it possible to treat modelling as data curation: build, transform, export, integrate.\nThis shift is liberating. It allows architects to keep models aligned with fast-moving environments, to connect architecture with delivery tools, and to maintain integrity at scale.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#preparing-for-the-examples",
    "href": "02-System.Object[].html#preparing-for-the-examples",
    "title": "Chapter 1: Why Script EA?",
    "section": "Preparing for the Examples",
    "text": "Preparing for the Examples\nThe rest of this chapter (and indeed this book) is practical. We will show code snippets that run inside EA, fully commented so you understand every line. They start simple (“Hello World”), then build into patterns for traversal, creation, updating, deleting, and exporting.\nBefore diving into the examples, remember the key lessons of this introduction:\n\nScript when scale, consistency, integration, or governance require it.\nDon’t script when EA has a built-in feature that meets your need.\nAlways script safely: dry-run, backup, and log.\nTreat the model as a dataset, not just diagrams.\n\nWith these principles, you are ready to move from being a modeller who only draws diagrams to an architect who shapes models programmatically.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "02-System.Object[].html#looking-ahead",
    "href": "02-System.Object[].html#looking-ahead",
    "title": "Chapter 1: Why Script EA?",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nThis chapter has introduced the “why” of scripting, and given you a working starter example. The chapters that follow explain the “how.” We will explore the scripting engines available in EA, the core API, and the safe patterns you should follow to avoid breaking your model. Later parts of this book will offer a cookbook of practical examples, patterns for common tasks, and even ways of using AI assistants to accelerate script development.\nBy the end, you should have the confidence to create scripts that save time, improve quality, and make Enterprise Architect work for you, not the other way around.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 1: Why Script EA?</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html",
    "href": "03-System.Object[].html",
    "title": "Chapter 2: Automation Landscape",
    "section": "",
    "text": "Built-In Script Engine\nBefore you can write useful scripts, you need to understand the landscape. Enterprise Architect gives you several ways to automate its behaviour, both from within the tool and from the outside. Each option comes with strengths and limitations. Choosing the right one depends on your goals, your tolerance for risk, and the skills of your team.\nEnterprise Architect includes a scripting window where you can create, edit, and run scripts directly inside the repository. These scripts are stored with the model and organised into groups. They can be invoked from menus or context menus, which makes them perfect for quick automation tasks or shared governance checks.\nThe scripting window offers three “languages”: VBScript, JScript, and JavaScript. At first glance this looks like a generous choice. In practice, all three map back to Microsoft’s legacy scripting engines — which means you are working with very old language runtimes.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#scripting-options",
    "href": "03-System.Object[].html#scripting-options",
    "title": "Chapter 2: Automation Landscape",
    "section": "Scripting options",
    "text": "Scripting options\nWhen creating a script in EA you are prompted to select one of the following:\nVBScript\n\nMicrosoft Visual Basic Scripting Edition.\nLooks and feels like writing macros in Excel or classic Visual Basic.\nVerbose but accessible to non-developers.\nStill supported inside EA, but deprecated by Microsoft in Windows.\nWeak library support; relies heavily on the EA API and ActiveX.\n\nJScript\n\nMicrosoft’s implementation of ECMAScript 3 (1999).\nVery similar to early JavaScript, but locked at that level.\nNo modern JavaScript features: no let, const, arrow functions, JSON libraries, or array helpers such as map or filter.\nRequires “old school” loops and helper functions for common tasks.\nThis is EA’s most commonly used internal scripting option.\n\nJavaScript (as labelled in EA)\n\nMisleading. Selecting “JavaScript” in EA simply invokes the same JScript engine.\nNo ES5/ES6+ features, despite the familiar name.\nTreat “JavaScript” and “JScript” as identical inside EA.\n\nIn short: inside EA you are working with either VBScript or JScript (ES3). If you want modern features, you need to step outside.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#external-automation",
    "href": "03-System.Object[].html#external-automation",
    "title": "Chapter 2: Automation Landscape",
    "section": "External Automation",
    "text": "External Automation\nYou are not limited to the internal scripting engine. EA exposes its entire object model through a COM interface. Any COM-aware language can connect and manipulate the repository. This makes it possible to use modern languages with modern tooling.\nTypical external options include:\n\nC# (the richest support, with type libraries).\nPython via pywin32.\nPowerShell, Perl, Java, and others via COM bridges.\n\nExternal automation runs outside EA and does not live in the repository. It is well-suited to integration with CI/CD pipelines, registries, Jira, Confluence, or analytics platforms.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#hello-ea-examples",
    "href": "03-System.Object[].html#hello-ea-examples",
    "title": "Chapter 2: Automation Landscape",
    "section": "“Hello EA” Examples",
    "text": "“Hello EA” Examples\nThe following examples illustrate the same simple task: list the names of all elements in the package currently selected in the Project Browser. Seeing the same logic in three languages highlights their differences.\nVBScript (inside EA)\n\n\nExample 2.1 - HelloEA in VBScript\n\n' -------------------------------------------------------\n' Example 2.1 - HelloEA in VBScript\n' Purpose: Output the names of all elements in the\n' selected package in the Project Browser.\n' -------------------------------------------------------\n!INC Local Scripts.EAConstants-VBScript\n\nsub main()\n\n' Get the selected package\ndim package\nset package = Repository.GetTreeSelectedPackage()\nif package is nothing then\nSession.Prompt \"Please select a package in the Project Browser.\",\npromptOK\nexit sub\nend if\n\n' Get the collection of elements in the package\ndim elements\nset elements = package.Elements\n' Loop through the collection\ndim i\nfor i = 0 to elements.Count - 1\ndim element\nset element = elements.GetAt(i) ' EA collections use GetAt()\nSession.Output \"Element: \" & element.Name\nnext\nend sub\n\nmain\n\nJScript (inside EA)\n\n\nExample 2.2 - HelloEA in JScript\n\n// -------------------------------------------------------\n// Example 2.2 - HelloEA in JScript\n// Purpose: Output the names of all elements in the\n// selected package in the Project Browser.\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() \n{\n  // Get the selected package\n  var package = Repository.GetTreeSelectedPackage();\n  if (!package) \n    {\n    Session.Prompt(\"Please select a package in the Project Browser.\",\n    promptOK);\n    return;\n    }\n\n  // Get the collection of elements in the package\n  var elements = package.Elements;\n  \n  // Loop through the collection\n  for (var i = 0; i \\&lt; elements.Count; i++) \n    {\n    var element = elements.GetAt(i); // EA collections are not arrays\n    Session.Output(\"Element: \" + element.Name);\n    }\n}\n\nmain();\n\nPython (external via pywin32)\n\n\nExample 2.3 - HelloEA in Python\n\n# -------------------------------------------------------\n# Example 2.3 - HelloEA in Python\n# Purpose: Output the names of all elements in the\n# selected package in the Project Browser.\n# Notes:\n# - Requires EA to be running.\n# - Requires pywin32 package installed.\n# -------------------------------------------------------\nimport win32com.client\n\n# Connect to the running EA instance\nea = win32com.client.Dispatch(\"EA.App\")\nrepository = ea.Repository\n# Get the currently selected package\npackage = repository.GetTreeSelectedPackage()\nif not package:\nprint(\"Please select a package in the Project Browser.\")\nexit(0)\n\n# Get the collection of elements in the package\nelements = package.Elements\n# Loop through the collection\nfor i in range(elements.Count):\nelement = elements.GetAt(i) \\# EA collections expose GetAt()\nprint(\"Element:\", element.Name)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#comparing-the-three",
    "href": "03-System.Object[].html#comparing-the-three",
    "title": "Chapter 2: Automation Landscape",
    "section": "Comparing the Three",
    "text": "Comparing the Three\n\nVBScript feels like a 1990s macro language. Clear for beginners but verbose.\nJScript is terser, familiar to anyone with Java/C-style backgrounds, but limited to ES3 features.\nPython is modern, expressive, and integrates with rich libraries — but requires external automation and setup.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#the-role-of-com",
    "href": "03-System.Object[].html#the-role-of-com",
    "title": "Chapter 2: Automation Landscape",
    "section": "The Role of COM",
    "text": "The Role of COM\nAt the heart of both external automation and add-ins is COM (Component Object Model). EA exposes its Repository object through COM. This is what allows C#, Python, or Java to talk to EA.\nCOM is old, and sometimes brittle, but it is also the glue that allows EA to integrate with the wider world. The Interop.EA.dll assembly is the .NET wrapper over this COM interface. For Python, pywin32 plays the same role. For Java, jacob or similar libraries provide bindings.\nUnderstanding COM isn’t strictly necessary to write scripts, but it explains why bitness matters (32-bit EA requires 32-bit Python), why registration matters (DLLs must be registered), and why debugging sometimes feels awkward.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#choosing-the-right-tool",
    "href": "03-System.Object[].html#choosing-the-right-tool",
    "title": "Chapter 2: Automation Landscape",
    "section": "Choosing the Right Tool",
    "text": "Choosing the Right Tool\nA simple selection matrix helps:\n\nQuick fixes and governance checks inside EA → JScript.\nFor teams with strong Visual Basic heritage → VBScript.\nFor data-heavy tasks, JSON, or integration pipelines → external automation (Python or C#).\nFor stable, long-lived features → migrate scripts into Add-ins.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#safety-in-each-layer",
    "href": "03-System.Object[].html#safety-in-each-layer",
    "title": "Chapter 2: Automation Landscape",
    "section": "Safety in Each Layer",
    "text": "Safety in Each Layer\nEach automation option carries its own risks:\n\nInternal scripts: no undo, dangerous if dry-run is not used.\nExternal automation: risk of version mismatch (32/64-bit), risk of corrupting repos if SQL writes are used incorrectly.\nAdd-ins: risk of startup errors breaking EA menus; heavier debugging burden.\n\nThe best safety net in all cases is to test on a dummy repository first, use dry-run patterns, and maintain version control for your scripts or add-ins.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#shaping-automation-practice",
    "href": "03-System.Object[].html#shaping-automation-practice",
    "title": "Chapter 2: Automation Landscape",
    "section": "Shaping Automation Practice",
    "text": "Shaping Automation Practice\nFor many organisations, the EA automation landscape evolves in phases:\n\nExploration — a modeller writes small scripts to rename things or export CSV.\nConsolidation — a team shares scripts across repositories, with common helpers.\nIntegration — external automation ties EA to Jira, Confluence, Git.\nProductisation — stable solutions become add-ins with menus and event handlers.\n\nKnowing where you are in this journey helps you decide which option to invest in.\nPreparing for the Examples\nThe rest of this chapter will show practical code samples for each automation mode: internal scripts in JScript, external COM automation in C# and Python, and a glimpse of add-in structure. These examples are fully commented, showing how to set up, how to log safely, and how to use dry-run modes.\nBefore diving into the code, remember:\n\nInternal scripts are your first tool.\nExternal automation connects EA to the wider enterprise.\nAdd-ins formalise solutions into products.\n\nThis layered landscape is what makes EA unusually flexible: it can serve a single modeller working on a small project, or an enterprise team building integrations across systems.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "03-System.Object[].html#looking-ahead",
    "href": "03-System.Object[].html#looking-ahead",
    "title": "Chapter 2: Automation Landscape",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nThe next chapter dives into EA API Essentials. We will explore the 80/20 of the object model: Repository, Package, Element, Connector, Attribute, and TaggedValue. We will also see why methods like Update() and RefreshModelView() are so critical. With this foundation, you will be ready to write scripts that safely and effectively manipulate your models.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2: Automation Landscape</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html",
    "href": "04-System.Object[].html",
    "title": "Chapter 3: Getting Started",
    "section": "",
    "text": "The Importance of Backups\nEvery technical journey begins with first steps, and scripting Enterprise Architect is no exception. After seeing the big picture of why scripting matters (Chapter 1) and the landscape of options available (Chapter 2), it is tempting to jump straight into code. But before you do, there is one critical lesson: safety first.\nScripting in EA is not like writing macros in a spreadsheet where you can undo or close without saving. The EA repository is a live database. Every script you run has the power to add, modify, or delete hundreds or thousands of elements in a matter of seconds. There is no “undo” button for automation. That is why this chapter is dedicated to getting started safely. We will cover the principles and practices that protect your repository, minimise risk, and give you confidence when you begin experimenting with automation.\nThe very first safeguard is backups. EA repositories come in different forms: .qea files, .eapx files, or database connections to SQL Server, Oracle, or PostgreSQL. Regardless of the backend, before you run any script that modifies content, take a backup.\nFor file-based repositories, this can be as simple as copying the file to another folder. For server-based repositories, use database backup routines or export a snapshot to XMI. The principle is the same: always have a way back. If your script misbehaves and wipes out a branch of the model, you need the comfort of knowing you can restore it.\nExperienced script authors often keep a sandbox repository: a copy of the model used only for testing scripts. This lets you experiment freely without fear of damaging the production model. Once your script behaves as expected, you can run it against the real repository.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#the-dry-run-principle",
    "href": "04-System.Object[].html#the-dry-run-principle",
    "title": "Chapter 3: Getting Started",
    "section": "The Dry-Run Principle",
    "text": "The Dry-Run Principle\nPerhaps the single most important safeguard in scripting is the dry-run flag. Every modifying script in this book includes a line near the top:\nvar DRY_RUN = true;\nWhen DRY_RUN is true, the script logs what it would do, but does not commit any changes. Only when you flip it to false will the script actually update the repository. This gives you a rehearsal phase: you see what names would be changed, what tags would be added, what elements would be deleted.\nThis principle of simulation before execution is vital. It is your safety net. Many a modeller has regretted running a bulk update script without such a safeguard. By adopting dry-run as a discipline, you make your scripts trustworthy not only for yourself but also for colleagues who may reuse them.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#logging-and-transparency",
    "href": "04-System.Object[].html#logging-and-transparency",
    "title": "Chapter 3: Getting Started",
    "section": "Logging and Transparency",
    "text": "Logging and Transparency\nLogging is your second line of defence. A script that silently modifies hundreds of elements without telling you what it did is dangerous. A safe script always logs its actions, either to EA’s Output tab, to a CSV file, or both.\nLogging serves three purposes:\n\nFeedback — you see what the script is doing in real time.\nAudit — you can review afterwards which elements were touched.\nDebugging — if something goes wrong, logs help you trace the problem.\n\nGood practice is to log to CSV, with columns such as ElementID, Name, OldValue, NewValue, Action. That way you can filter and analyse in Excel or share the log with others.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#understanding-the-repository-structure",
    "href": "04-System.Object[].html#understanding-the-repository-structure",
    "title": "Chapter 3: Getting Started",
    "section": "Understanding the Repository Structure",
    "text": "Understanding the Repository Structure\nBefore you can script safely, you must understand the structure you are scripting against. EA is more than diagrams. At the top is the Repository object. Inside are Models (also known as root packages). Each model contains Packages, and packages contain Elements and Diagrams.\nThink of it as a tree:\n\n\nEA Repository object model\n\nRepository\n├─ Model (root package)\n│ ├─ Package\n│ │ ├─ Elements\n│ │ ├─ Diagrams\n│ │ └─ Sub-packages\n│ └─ Package\n└─ Other models\n\nAt the element level, you have properties (name, type, status) and collections (attributes, methods, connectors, tagged values). Connectors link elements together. Diagrams show visual instances of elements.\nUnderstanding this hierarchy is essential because every script you write will involve traversing these structures. A safe script is one that navigates correctly: it knows when it is handling a package versus an element, and it never assumes without checking ObjectType.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#update-and-refresh",
    "href": "04-System.Object[].html#update-and-refresh",
    "title": "Chapter 3: Getting Started",
    "section": "Update and Refresh",
    "text": "Update and Refresh\nAnother foundational safety concept is the difference between Update() and RefreshModelView().\n\nUpdate() commits your change to the repository. Without it, the change is lost.\nRefreshModelView() tells EA’s user interface to reload content. Without it, the change may be invisible until you close and reopen EA.\n\nMany beginners forget one or the other. Forgetting Update() means the script appears to work but nothing actually changes. Forgetting RefreshModelView() means the script did work but you can’t see the result.\nThe safe pattern is:\n\nModify the object.\nCall .Update().\nAt the end of the script (or per batch), call Repository.RefreshModelView().",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#avoiding-dangerous-patterns",
    "href": "04-System.Object[].html#avoiding-dangerous-patterns",
    "title": "Chapter 3: Getting Started",
    "section": "Avoiding Dangerous Patterns",
    "text": "Avoiding Dangerous Patterns\nCertain scripting mistakes are particularly hazardous:\n\nForward deletion loops: deleting items in a forward loop causes index shifts, skipping items. Always delete backwards.\nAssuming selection type: don’t assume the user has selected a package; they may have selected a diagram or element. Always check ObjectType.\nUsing names as keys: element names are not unique. Use GUIDs or IDs for identification.\nDirect SQL writes: avoid Repository.Execute(“UPDATE…”). This bypasses EA’s business rules and can corrupt the repository. Use SQL only for reading (SQLQuery), never for writing.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#testing-on-small-sets",
    "href": "04-System.Object[].html#testing-on-small-sets",
    "title": "Chapter 3: Getting Started",
    "section": "Testing on Small Sets",
    "text": "Testing on Small Sets\nBefore applying a script to thousands of elements, test it on a small package with a handful of items. This lets you confirm behaviour without risking widespread impact. A safe workflow is:\n\nCopy a few elements into a test package.\nRun the script with DRY_RUN = true.\nCheck the log output.\nSwitch to DRY_RUN = false and run.\nVerify the changes.\nOnly then apply to the full repository.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#cultural-safety",
    "href": "04-System.Object[].html#cultural-safety",
    "title": "Chapter 3: Getting Started",
    "section": "Cultural Safety",
    "text": "Cultural Safety\nSafety is not just technical; it is cultural. Teams should adopt norms:\n\nNever run destructive scripts in production without dry-run first.\nAlways share logs of what was changed.\nKeep a shared script library under version control (Git).\nReview scripts with peers before first run.\n\nThese norms build trust. Architects and modellers become more willing to use automation when they know safeguards are built in.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "04-System.Object[].html#building-the-right-habits",
    "href": "04-System.Object[].html#building-the-right-habits",
    "title": "Chapter 3: Getting Started",
    "section": "Building the Right Habits",
    "text": "Building the Right Habits\nThe purpose of this chapter is not to scare you, but to build the right habits from the start. If you learn to always include a dry-run flag, always log, always test on small sets, and always backup, then scripting EA becomes an empowering tool rather than a risky gamble.\nThink of it like climbing: the harness, helmet, and rope may feel restrictive at first, but they enable you to climb higher with confidence. In the same way, scripting safety patterns may feel like overhead at first, but they let you automate more ambitious tasks without fear.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Chapter 3: Getting Started</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html",
    "href": "05-System.Object[].html",
    "title": "Chapter 4: API Essentials",
    "section": "",
    "text": "Why Understand the API?\nEnterprise Architect is first and foremost a modelling tool. But beneath its diagrams, toolboxes, and properties windows lies a structured object model — a formal API (Application Programming Interface) that represents everything you see in the repository. Packages, elements, connectors, diagrams, attributes, tagged values: all are exposed as objects with properties and methods.\nThe EA Automation API can feel intimidating at first. It includes dozens of classes, hundreds of properties, and subtle rules about when you must call Update() or RefreshModelView(). But in practice, you do not need the whole surface of the API to be productive. In fact, like many large systems, EA’s object model follows the 80/20 rule: about 20% of the classes and methods cover 80% of what you will ever need.\nThis chapter focuses on that 20%. It introduces the core objects — Repository, Package, Element, Connector, Attribute, and TaggedValue — and explains their roles in the automation model. It also explains how to navigate between them, when to use the object API and when to use SQL, and the importance of persisting changes. By the end of this introduction, you will understand the “grammar” of the EA API, which will make the worked examples far easier to follow.\nIt might seem obvious: if you are going to script EA, you need to know the API. But there is a deeper point. Many beginners approach scripting by copying and pasting snippets without understanding what is happening. This can work for small tasks, but it is risky at scale. Without a mental model of the API, you may accidentally treat an EA collection like a JavaScript array, or forget to call Update(), or misinterpret a connector direction.\nUnderstanding the API means you can reason about scripts. You can predict what a script will do, debug why something didn’t work, and design new scripts with confidence. It is the difference between following recipes and actually knowing how to cook.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#the-object-model",
    "href": "05-System.Object[].html#the-object-model",
    "title": "Chapter 4: API Essentials",
    "section": "The Object Model",
    "text": "The Object Model\nThe EA API follows the structure of the tool itself:\n\nRepository — the root object, representing the entire open model.\nPackage — a container for elements, diagrams, and sub-packages.\nElement — a UML element (class, component, use case, capability, etc.).\nConnector — a relationship between elements (association, dependency, trace, etc.).\nAttribute / Operation — members inside an element.\nTaggedValue — metadata attached to an element or connector.\n\nAlmost every script you write will start with the Repository object and work downwards.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#repository",
    "href": "05-System.Object[].html#repository",
    "title": "Chapter 4: API Essentials",
    "section": "Repository",
    "text": "Repository\nEverything begins with the Repository object. This represents the currently open EA project — whether it is a .qea file, a database, or a shared repository. From Repository, you can access root models (Repository.Models), query by SQL (Repository.SQLQuery), retrieve selected objects (GetTreeSelectedPackage, GetTreeSelectedObject), or refresh the UI (RefreshModelView).\nThink of the Repository as your gateway. You cannot script without it, because it is the only object that is always available.\nThe Repository object is provided automatically when running a script inside EA. It represents the current model. From it you can query packages, elements, and diagrams, or run SQL directly.\n\n\nExample 4.1 – Output repository name\n\n// -------------------------------------------------------\n// Example 4.1 – Output repository name\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    // The Repository object is available by default\n    var modelName = Repository.ConnectionString;\n    Session.Output(\"Connected to: \" + modelName);\n}\n\nmain();\n\nRepository.ConnectionString tells you the path or database connection for the open model.\nUse Session.Output instead of console.log — EA doesn’t know what a console is.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#packages",
    "href": "05-System.Object[].html#packages",
    "title": "Chapter 4: API Essentials",
    "section": "Packages",
    "text": "Packages\nThe next level down is the Package. Packages are containers. They hold elements, diagrams, and child packages. Traversing the model usually means starting at a package and working your way down through its sub-packages and elements.\nA key safety note: don’t assume a user has selected a package. Always check the object type. If you write a script that expects a package but gets a diagram, you will get confusing errors.\n\n\nExample 4.2 – Traverse top-level packages\n\n// -------------------------------------------------------\n// Example 4.2 – Traverse top-level packages\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var models = Repository.Models;  // Collection of root packages\n    for (var i = 0; i &lt; models.Count; i++) {\n        var model = models.GetAt(i);\n        Session.Output(\"Root package: \" + model.Name);\n    }\n}\n\nmain();\n\nKey notes:\n\nEA collections use .Count and .GetAt(i).\nRoot packages are accessed through Repository.Models.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#elements",
    "href": "05-System.Object[].html#elements",
    "title": "Chapter 4: API Essentials",
    "section": "Elements",
    "text": "Elements\nThe Element is the heart of the EA API. Every class, requirement, actor, capability, or component is an Element. Elements have properties (Name, Type, Notes, Status), collections (Attributes, Methods, Connectors, TaggedValues), and behaviours (scenarios, responsibilities).\nIf you learn to script elements, you unlock most of EA’s power. The most common tasks involve creating elements, updating their properties, and traversing their relationships.\n\n\nExample 4.3 – List all elements in selected package\n\n// -------------------------------------------------------\n// Example 4.3 – List all elements in selected package\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var package = Repository.GetTreeSelectedPackage();\n    if (!package) {\n        Session.Prompt(\"Please select a package in the Project Browser.\", promptOK);\n        return;\n    }\n\n    var elements = package.Elements;\n    for (var i = 0; i &lt; elements.Count; i++) {\n        var element = elements.GetAt(i);\n        Session.Output(\"Element: \" + element.Name + \" (Type: \" + element.Type + \")\");\n    }\n}\n\nmain();\n\nNotes:\n\nAlways check for null — if nothing is selected, GetTreeSelectedPackage() returns null.\nelement.Type returns the UML type (e.g. Class, Requirement, Activity).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#connectors",
    "href": "05-System.Object[].html#connectors",
    "title": "Chapter 4: API Essentials",
    "section": "Connectors",
    "text": "Connectors\nArchitecture is about relationships. In EA, those are represented by Connectors. An element’s Connectors collection lists all relationships where that element is either client or supplier. A connector has a Type (“Association,” “Dependency,” “Realisation”), plus source and target IDs.\nA common beginner’s mistake is to assume connectors are directional in a UML sense. In practice, EA stores them with ClientID and SupplierID, and the interpretation depends on connector type. Scripts must take care to assign the correct ends.\n\n\nExample 4.4 – Show connectors from a selected element\n\n// -------------------------------------------------------\n// Example 4.4 – Show connectors from a selected element\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var element as EA.Element;\n    element = Repository.GetTreeSelectedObject();\n    if (!element || element.ObjectType != otElement) {\n        Session.Prompt(\"Please select an element in the Project Browser.\", promptOK);\n        return;\n    }\n\n    var connectors = element.Connectors;\n    for (var i = 0; i &lt; connectors.Count; i++) {\n        var conn = connectors.GetAt(i);\n        Session.Output(\"Connector: \" + conn.Type + \n                       \" from \" + conn.ClientID + \n                       \" to \" + conn.SupplierID);\n    }\n}\n\nmain();\n\nNotes:\n\nConnectors is a collection of relationships.\nClientID and SupplierID are IDs of the connected elements. You can resolve them with Repository.GetElementByID().",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#attribute-and-method-details-of-elements",
    "href": "05-System.Object[].html#attribute-and-method-details-of-elements",
    "title": "Chapter 4: API Essentials",
    "section": "Attribute and Method: Details of Elements",
    "text": "Attribute and Method: Details of Elements\nAttributes and methods live inside elements. They are relevant mostly for data models and software design. If you are modelling business capabilities or processes, you may never touch them. But for class modelling, they are essential. The API treats them like small objects with Name, Type, Notes, and collections of tagged values.\n\n\nExample 4.5 – Add Attribute and Method\n\n// -------------------------------------------------------\n// Example 4.5 – Add Attribute and Method\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var el = Repository.GetTreeSelectedObject();\n    if (el.ObjectType != otElement || el.Type != \"Class\") {\n        Session.Prompt(\"Select a Class element first.\", promptOK);\n        return;\n    }\n\n    // List existing attributes and methods\n    for (var i = 0; i &lt; el.Attributes.Count; i++)\n        Session.Output(\"Attribute: \" + el.Attributes.GetAt(i).Name);\n    for (var j = 0; j &lt; el.Methods.Count; j++)\n        Session.Output(\"Method: \" + el.Methods.GetAt(j).Name + \"()\");\n\n    // Add one of each\n    el.Attributes.AddNew(\"exampleAttr\", \"String\").Update();\n    el.Methods.AddNew(\"exampleMethod\", \"\").Update();\n    el.Update();\n    Repository.RefreshModelView(el.PackageID);\n    Session.Output(\"Added exampleAttr and exampleMethod.\");\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#tagged-values",
    "href": "05-System.Object[].html#tagged-values",
    "title": "Chapter 4: API Essentials",
    "section": "Tagged Values",
    "text": "Tagged Values\nPerhaps the most important part of the API for governance is Tagged Values. Tagged values let you attach metadata to elements, connectors, attributes, and more. They are the bridge between generic modelling and your organisation’s specific needs. For example, you can tag every application with “Owner” or every requirement with “Source System.”\nIn scripts, tagged values are indispensable. They let you propagate metadata, check for compliance, and integrate with external registries.\n\n\nExample 4.6 – Read and update tagged values\n\n// -------------------------------------------------------\n// Example 4.6 – Read and update tagged values\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var element = Repository.GetTreeSelectedObject();\n    if (!element || element.ObjectType != otElement) {\n        Session.Prompt(\"Please select an element.\", promptOK);\n        return;\n    }\n\n    var tags = element.TaggedValues;\n    for (var i = 0; i &lt; tags.Count; i++) {\n        var tag = tags.GetAt(i);\n        Session.Output(\"Tag: \" + tag.Name + \" = \" + tag.Value);\n    }\n\n    // Add or update a tagged value\n    var newTag = element.TaggedValues.AddNew(\"Status\", \"Draft\");\n    newTag.Update();\n\n    // Remember to call Update() on the element itself\n    element.Update();\n    Session.Output(\"Tagged value added/updated.\");\n}\n\nmain();\n\nKey rules:\n\nTagged values are stored as a collection on the element.\nAfter modifying, call Update() to persist.\nAlways refresh the model view if you want changes to show immediately.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#sql-vs-api",
    "href": "05-System.Object[].html#sql-vs-api",
    "title": "Chapter 4: API Essentials",
    "section": "SQL vs API",
    "text": "SQL vs API\nEA exposes its data model both as an object API and as a database schema. You can query directly with Repository.SQLQuery(sql), which returns XML. This is often faster for reads, especially when you need thousands of rows. But you should never write to the database directly. The object API enforces rules, cascades updates, and ensures integrity.\nThe safe pattern is: SQL for read, API for write. Query with SQL, act with API.\n\n\nExample 4.7 – Use SQLQuery for performance\n\n// -------------------------------------------------------\n// Example 4.7 – Use SQLQuery for performance\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    // Simple SQL query – always returns XML\n    var result = Repository.SQLQuery(\n        \"SELECT Name FROM t_object WHERE Object_Type='Class'\"\n        );\n    Session.Output(\"Result XML: \" + result);\n}\n\nmain();\n\n\nSQL queries return XML, not rows. You must parse the XML manually.\nSQL is much faster for bulk queries but dangerous if you don’t understand EA’s schema.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#update-and-refreshmodelview",
    "href": "05-System.Object[].html#update-and-refreshmodelview",
    "title": "Chapter 4: API Essentials",
    "section": "Update and RefreshModelView",
    "text": "Update and RefreshModelView\nIf there is one golden rule in the EA API, it is this: nothing changes until you call Update(). Setting element.Name = “X” does nothing unless you follow with element.Update(). Forget this, and you will wonder why your script “didn’t work.”\nThe second golden rule is: the UI doesn’t refresh automatically. After bulk changes, call Repository.RefreshModelView() to force the Project Browser to update. Without it, changes may exist in the database but remain invisible until EA is restarted.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#the-8020-principle-in-practice",
    "href": "05-System.Object[].html#the-8020-principle-in-practice",
    "title": "Chapter 4: API Essentials",
    "section": "The 80/20 Principle in Practice",
    "text": "The 80/20 Principle in Practice\nAlthough EA has many more objects — Diagrams, DiagramObjects, Scenarios, Issues, Tests — most automation tasks use the same handful: Repository, Package, Element, Connector, Attribute, TaggedValue. Master these, and you can already do 80% of practical scripting.\nThe rest of the API is there for advanced needs. You don’t need to learn it all at once. By focusing on the essentials, you avoid overwhelm and build confidence quickly.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#learning-through-patterns",
    "href": "05-System.Object[].html#learning-through-patterns",
    "title": "Chapter 4: API Essentials",
    "section": "Learning Through Patterns",
    "text": "Learning Through Patterns\nThe examples later in this chapter illustrate common patterns:\n\nTraversal (loop through all elements in a package).\nCreation (add a new element and update).\nRelationship management (add connectors).\nMetadata (set tagged values).\nSQL vs object trade-offs (query then act).\n\nThese patterns recur constantly. Once you know them, you can adapt them to almost any task.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#common-pitfalls",
    "href": "05-System.Object[].html#common-pitfalls",
    "title": "Chapter 4: API Essentials",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\nEven at the API essentials level, there are traps:\n\nMisusing EA collections (they are not arrays).\nForgetting Update() or RefreshModelView().\nConfusing stereotype with StereotypeEx (use the latter for profile-qualified stereotypes).\nAssuming element names are unique (they are not; always prefer GUID or ID).\nOverusing Session.Output in large loops (slow).\n\nThese pitfalls are avoidable once you internalise the essentials.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "05-System.Object[].html#looking-ahead",
    "href": "05-System.Object[].html#looking-ahead",
    "title": "Chapter 4: API Essentials",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nThis chapter covered the essentials: Repository, Package, Element, Connector, and TaggedValue. You now know how to retrieve, inspect, and modify them. In the next chapter we will look at working inside EA with JScript, including common pitfalls, utility functions, and debugging strategies.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Chapter 4: API Essentials</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html",
    "href": "06-System.Object[].html",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "",
    "text": "The Language Landscape\nThe previous chapters have explained why you would script Enterprise Architect (EA), how automation fits into the overall landscape, and which core objects form the backbone of the API. Now it is time to get specific about the scripting language you will actually use inside EA.\nEA provides three options in its built-in scripting window: VBScript, JScript, and in newer versions, JavaScript. Each of these has its own history, syntax, and quirks. For most users today, the best balance of accessibility, capability, and long-term viability is found in JavaScript — or more accurately, in Microsoft’s JScript engine, which is EA’s internal implementation of ECMAScript 3.\nThis chapter explores what it means to work inside EA with JavaScript/JScript. It explains the constraints of the runtime, the pitfalls of assuming modern ECMAScript features, and the techniques that make the language usable for practical automation. It also sets expectations: you will not be writing modern Node.js code, but you can still achieve powerful results with a lean, disciplined subset of JavaScript.\nWhy does EA support these languages? The answer lies in its history. In the early 2000s, Windows scripting was dominated by VBScript and JScript, both hosted by the Windows Script Host. They were the default scripting choices for automation in Microsoft Office and many other applications. EA adopted them as its embedded scripting languages.\nVBScript is verbose, procedural, and feels like a cousin of Visual Basic for Applications (VBA). JScript is Microsoft’s implementation of ECMAScript 3 (ES3), roughly equivalent to JavaScript as it existed in Internet Explorer 6.\nMore recently, Sparx Systems added support for JavaScript labelled as such, but under the hood it is still the JScript ES3 runtime. That means many of the features you may expect from modern JavaScript — let, const, arrow functions, array methods like forEach, JSON parsing — are missing. If you try to use them, your script will fail.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html#javascript-or-jscript",
    "href": "06-System.Object[].html#javascript-or-jscript",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "JavaScript or JScript?",
    "text": "JavaScript or JScript?\nGiven these limitations, why choose JavaScript over VBScript? There are several reasons:\n\nFamiliarity: even with its older syntax, JavaScript feels more familiar to today’s developers and architects than VBScript.\nReadability: JScript code tends to be shorter and cleaner than equivalent VBScript.\nLongevity: while VBScript has been officially deprecated by Microsoft, JavaScript remains the world’s most widely used language. Even if EA lags in its runtime, the language concepts remain transferable.\nTransition potential: once you know how to script EA in JScript, moving to external JavaScript (Node.js, modern ES) or Python is easier.\n\nFor these reasons, this book assumes you will primarily use JScript/JavaScript as your internal scripting language. VBScript examples are included occasionally for reference, but JScript is the pragmatic choice going forward.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html#the-constraints-of-jscript-es3",
    "href": "06-System.Object[].html#the-constraints-of-jscript-es3",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "The Constraints of JScript ES3",
    "text": "The Constraints of JScript ES3\nThe most important thing to understand is what you cannot do in EA’s JScript engine. Here are the key constraints:\n\nNo modern declarations: only var is allowed; let and const are not recognised.\nNo arrow functions: ()=&gt; syntax is invalid. Use function() instead.\nNo array helpers: methods like forEach, map, filter, reduce do not exist.\nNo JSON methods: JSON.parse and JSON.stringify are not available. If you need JSON, you must parse manually or use external automation.\nNo promises or async/await: everything is synchronous.\nString handling: only basic functions like indexOf, substring, replace are available.\n\nThis feels restrictive, especially if you come from modern JavaScript. But it is enough for the kinds of tasks EA scripting requires: traversing collections, setting properties, logging, and basic string manipulation.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html#scripting-tips",
    "href": "06-System.Object[].html#scripting-tips",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "Scripting Tips",
    "text": "Scripting Tips\n\nAdapting to EA Collections\nOne of the most common mistakes beginners make is assuming EA’s collections behave like JavaScript arrays. They do not. EA’s collections are COM objects. They expose only two members: .Count and .GetAt(index).\nThat means you must loop with a standard for loop:\nvar els = pkg.Elements;\nfor (var i = 0; i &lt; els.Count; i++) {\n    var e = els.GetAt(i);\n    Session.Output(e.Name);\n}\nTry to call els.forEach(…) and you will get an error. Understanding this quirk is half the battle of learning EA scripting.\n\n\nLogging with Session.Output\nAnother adaptation is how you print feedback. There is no console.log. Instead, EA provides Session.Output, which writes to the Output tab. For example:\nSession.Output(“Hello from EA!”);\nFor large operations, use file logging instead (via FileSystemObject), because thousands of lines in the Output tab will slow EA down.\n\n\nDry-Run and Logging Discipline\nThe limitations of the language make discipline even more important. That is why this book insists on starting every modifying script with a DRY_RUN flag and embedding structured logging. Because there is no undo, and because the debugging tools are limited, you must build safety into your scripts from the start.\n\n\nThe Benefits of Simplicity\nThere is a positive side to JScript’s limitations: it forces you to keep scripts simple and focused. Each script should do one thing well — rename elements, export to CSV, check for missing tags. You won’t be tempted to over-engineer or add unnecessary abstractions.\nFor larger tasks, the advice is clear: use external automation in Python or C#. Internal JScript is for sharp, focused tools that run close to the model.\n\n\nThinking Like a Modeller\nIt is worth remembering that most EA users are not professional programmers. They are architects, analysts, engineers — people who need automation to support modelling, not to build software products. JScript inside EA is perfectly suited to this audience. It lets you express simple logic in a few lines. It integrates directly with the repository. It is always available without external setup.\nThis chapter is therefore less about writing elegant JavaScript and more about thinking like a modeller who scripts. The aim is clarity, safety, and repeatability.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html#a-progressive-learning-curve",
    "href": "06-System.Object[].html#a-progressive-learning-curve",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "A Progressive Learning Curve",
    "text": "A Progressive Learning Curve\nThe examples in this chapter begin simple — how to add an element, set a tagged value, or traverse a package tree. They then build toward more practical utilities: bulk renaming, enforcing conventions, exporting tagged values. Each example is fully commented so you see not only the syntax but also the reasoning.\nAs you practice, you will find that most tasks follow similar patterns:\n\nFind a package.\nLoop through elements.\nCheck a property.\nModify or log as needed.\nCall Update().\nRefresh the view.\n\nThis pattern is so common it becomes second nature. Once you see it a few times, you can adapt it to almost anything.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html#preparing-for-the-examples",
    "href": "06-System.Object[].html#preparing-for-the-examples",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "Preparing for the Examples",
    "text": "Preparing for the Examples\nThe worked examples that follow this introduction will show how to:\n\nCreate elements inside a package.\nSet stereotypes and tagged values.\nTraverse package hierarchies.\nSafely update and refresh content.\n\nRemember as you study them:\n\nJScript is old, but it works.\nStick to ES3 constructs (var, for, function).\nTreat EA collections as COM objects, not arrays.\nUse Session.Output for small logs, CSV files for large ones.\nAlways keep DRY_RUN = true until you are certain.\n\nMastering these basics will make you comfortable in EA’s scripting environment, ready to explore external automation and add-ins later.\n\n\nSafe Variable Declarations\n\n\nExample 5.1 – Safe variable declarations in JScript\n\n// -------------------------------------------------------\n// Example 5.1 - Safe variable declarations in JScript\n// -------------------------------------------------------\n\n// ❌ Wrong (not supported in JScript)\n// let x = 10;\n// const y = 20;\n\n// ✅ Correct\nvar x = 10;\nvar y = 20;\n\n// Variables declared inside blocks are still visible outside\nif (true) {\n    var z = 30;   // visible outside the if block\n}\n\nSession.Output(\"x=\" + x + \", y=\" + y + \", z=\" + z);\n\n\n\nUtility Functions\nSince JScript lacks many string and array helpers, you should include utility functions in most scripts.\n\n\nExample 5.2 – Common utility functions for JScript\n\n// -------------------------------------------------------\n// Example 5.2 - Common utility functions for JScript\n// -------------------------------------------------------\n\n// Trim whitespace\nfunction trim(str) {\n    if (str == null || str == undefined) return \"\";\n    return String(str).replace(/^\\s+|\\s+$/g, \"\");\n}\n\n// Case-insensitive string comparison\nfunction safeCompare(str1, str2) {\n    return String(str1 || \"\").toLowerCase() === String(str2 || \"\").toLowerCase();\n}\n\n// Check if string starts with a prefix\nfunction startsWith(str, prefix) {\n    return String(str || \"\").indexOf(prefix) === 0;\n}\n\n// Check if string contains substring\nfunction contains(str, substring) {\n    return String(str || \"\").indexOf(substring) !== -1;\n}\n\n// Demonstration\nSession.Output(\"Trimmed: '\" + trim(\"   hello  \") + \"'\");\nSession.Output(\"Compare: \" + safeCompare(\"Test\",\"test\"));\nSession.Output(\"StartsWith: \" + startsWith(\"Enterprise Architect\",\"Enter\"));\nSession.Output(\"Contains: \" + contains(\"Enterprise Architect\",\"Architect\"));\n\n\n\nIterating EA Collections\nEA collections are not JavaScript arrays.\n\n\nExample 5.3 – Iterating through EA collections\n\n// -------------------------------------------------------\n// Example 5.3 - Iterating through EA collections\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var package = Repository.GetTreeSelectedPackage();\n    if (!package) {\n        Session.Prompt(\"Please select a package.\", promptOK);\n        return;\n    }\n\n    var elements = package.Elements;\n\n    // ❌ Wrong – this will fail\n    // elements.forEach(function(e) { ... });\n\n    // ✅ Correct – use Count and GetAt()\n    for (var i = 0; i &lt; elements.Count; i++) {\n        var element = elements.GetAt(i);\n        Session.Output(\"Element: \" + element.Name);\n    }\n}\n\nmain();\n\n\n\nFile I/O with ActiveX\nIf you need to read or write files, use the Windows FileSystemObject.\n\n\nExample 5.4 – Reading a text file in JScript\n\n// -------------------------------------------------------\n// Example 5.4 - Reading a text file in JScript\n// -------------------------------------------------------\n\nfunction readFile(filePath) {\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var file = fso.OpenTextFile(filePath, 1);  // 1 = ForReading\n    var content = file.ReadAll();\n    file.Close();\n    return content;\n}\n\nfunction main() {\n    try {\n        var text = readFile(\"C:\\\\temp\\\\example.txt\");\n        Session.Output(\"File contents: \" + text);\n    } catch(e) {\n        Session.Output(\"Error: \" + e.message);\n    }\n}\n\nmain();\n\n\n\nDebugging with Session.Output\nUnlike modern environments, you don’t have a console. Use Session.Output() to print values and track progress.\n\n\nExample 5.5 – Debugging with Session.Output\n\n// -------------------------------------------------------\n// Example 5.5 - Debugging with Session.Output\n// -------------------------------------------------------\n\nfunction main() {\n    Session.Output(\"Debugging start...\");\n\n    var package = Repository.GetTreeSelectedPackage();\n    if (!package) {\n        Session.Output(\"No package selected.\");\n        return;\n    }\n\n    Session.Output(\"Selected package: \" + package.Name);\n\n    var elements = package.Elements;\n    Session.Output(\"Element count: \" + elements.Count);\n\n    for (var i = 0; i &lt; elements.Count; i++) {\n        var element = elements.GetAt(i);\n        Session.Output(\"Element[\" + i + \"]: \" + element.Name);\n    }\n\n    Session.Output(\"Debugging finished.\");\n}\n\nmain();\n\n\n\nError Handling\nJScript supports try–catch, but exceptions are limited.\n\n\nExample 5.6 – Error handling in JScript\n\n// -------------------------------------------------------\n// Example 5.6 - Error handling in JScript\n// -------------------------------------------------------\n\nfunction main() {\n    try {\n        var result = 10 / 0;  // Still valid, result = Infinity\n        Session.Output(\"Result: \" + result);\n\n        // Force an error by calling undefined function\n        undefinedFunction();\n    } catch (e) {\n        // e.message is usually the only useful property\n        Session.Output(\"Caught error: \" + e.message);\n    }\n}\n\nmain();\n\n\n\nPutting It All Together\nBy combining these patterns, you can write safe, predictable scripts inside EA:\n\nAlways use var for variables.\nInclude helper functions for missing features.\nLoop over collections with .Count and .GetAt(i).\nUse Update() to persist changes and RefreshModelView() to update the UI.\nUse Session.Output() for debugging.\nUse try–catch, but don’t expect detailed stack traces.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "06-System.Object[].html#looking-ahead",
    "href": "06-System.Object[].html#looking-ahead",
    "title": "Chapter 5: Inside EA with JScript",
    "section": "Looking Ahead",
    "text": "Looking Ahead\nThis chapter has focused on the quirks of JScript inside EA. With this knowledge, you can write safe, basic scripts without falling into the traps of modern JavaScript expectations. In the next chapter we move to external automation, where Python, C#, and other modern languages open up much more powerful possibilities for integration and data processing.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Chapter 5: Inside EA with JScript</span>"
    ]
  },
  {
    "objectID": "07-System.Object[].html",
    "href": "07-System.Object[].html",
    "title": "Chapter 6: External Automation",
    "section": "",
    "text": "Why external automation?\nInternal scripts in Enterprise Architect (EA) are perfect for quick utilities, governance checks, and tidy-ups that live with the repository. Sometimes you need more. Integrations with registries and backlog tools, JSON-heavy exports, analytics over thousands of elements, CI/CD checks, and richer UX all benefit from external automation.\nExternal automation means driving EA from a separate program (e.g., C#/.NET, Python) via EA’s COM interface. Your program attaches to (or launches) EA, grabs the same Repository object you use inside scripts, and then performs work — with modern language ecosystems, logging, tests, packaging, and debugging.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 6: External Automation</span>"
    ]
  },
  {
    "objectID": "07-System.Object[].html#why-external-automation",
    "href": "07-System.Object[].html#why-external-automation",
    "title": "Chapter 6: External Automation",
    "section": "",
    "text": "Modern capabilities: async, structured logging, JSON, LINQ/pandas.\nEcosystem: proper source control, CI, test frameworks, packaging.\nIntegration: REST/Graph APIs, registries, issue trackers, data platforms.\nMaintainability: clearer separation of concerns and deployable tools.\nScale: process large repositories, batch operations, pipelines.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 6: External Automation</span>"
    ]
  },
  {
    "objectID": "07-System.Object[].html#how-it-works-at-a-glance",
    "href": "07-System.Object[].html#how-it-works-at-a-glance",
    "title": "Chapter 6: External Automation",
    "section": "How it works (at a glance)",
    "text": "How it works (at a glance)\nEA registers a COM server (EA.App). Your tool attaches (or launches), obtains EA.App.Repository, and then uses the familiar API for packages, elements, connectors, diagrams, SQL reads, and so on — just from outside EA.\n\nExample 6.1 — End-to-End External Automation with EAConnect\nThe example below shows a practical, fully-commented C# console utility that:\n\nConnects to EA (attach or launch)\nEnsures a model is open (optionally open a specified file)\nFinds a working package (selected in UI or falls back to first root)\nCreates a new Element in that package\nPersists and refreshes the UI so the change is immediately visible\n\nThe EAConnect helper (namespace EA.Automation) centralises COM wiring, timing/polling, and small UX conveniences. The full helper implementation and setup guidance live in Appendix A – EAConnect Helper & Setup.\n\n\nExample 6.1 - EA Automation – Example Utility\n\n// =============================================================================================\n// Example 6.1\n// File:        Program.cs\n// Project:     EA Automation – Example Utility\n// Author:      &lt;Your Name&gt;\n//\n// Created:     2025-08-31\n// Last Update: 2025-08-31\n//\n// PURPOSE\n// -------\n// Demonstrates a practical end-to-end EA automation task using the EAConnect helper:\n//   1) Connect to Enterprise Architect (attach or launch)\n//   2) Ensure a model is open (optionally open a specified .qea/.qeax/.eapx)\n//   3) Identify a target package (selected in the UI or fallback to the first root)\n//   4) Create a new Element in that package\n//   5) Persist and refresh the UI so the user immediately sees the change\n//\n// USAGE\n// -----\n//   From a developer console (matching EA bitness):\n//   MyEaTool.exe \"New Class Name\" \"Class\" \"Optional notes\"\n//   \"OptionalProfile::OptionalStereotype\"\n//\n//   Arguments (all optional; sensible defaults provided):\n//     [0] name : Element name (default: \"New Class\")\n//     [1] type : Element type (default: \"Class\"; e.g., \"Component\", \"Requirement\", \"UseCase\")\n//     [2] notes: Notes/description (default: \"Created by example utility.\")\n//     [3] stereotypeEx : Fully qualified stereotype (default: none; e.g., \"BPMN2.0::Task\")\n//\n// PRE-REQUISITES\n// --------------\n// - Windows + .NET 8 (Windows)\n// - &lt;TargetFramework&gt;net8.0-windows&lt;/TargetFramework&gt;\n// - &lt;PlatformTarget&gt;x64&lt;/PlatformTarget&gt; (for EA 64-bit) or x86 for 32-bit EA\n// - Reference Interop.EA.dll from your EA installation\n// - Entry point marked [STAThread]\n//\n// NOTES\n// -----\n// If nothing is selected in EA’s Project Browser, we default to the first root package.\n// After creating the element, call element.Update() to persist and then refresh the model view.\n// We also advise EA’s UI that the element changed to update open diagrams.\n//\n// UPDATE HISTORY\n// --------------\n// - 2025-08-31: Initial illustrative example.\n// ==============================================================================================\n\n#nullable enable\nusing System;\nusing EA;\nusing EA.Automation;  // EAConnect helper\n\ninternal static class Program\n{\n    [STAThread] // EA COM automation expects an STA thread\n    private static void Main(string[] args)\n    {\n// --------------------------------------------\n// 0) Parse command-line args with safe defaults\n// --------------------------------------------\n        string name = args.Length &gt; 0 ? args[0] : \"New Class\";\n        string type = args.Length &gt; 1 ? args[1] : \"Class\";\n        string notes = args.Length &gt; 2 ? args[2] : \"Created by example utility.\";\n        string? stereotype = args.Length &gt; 3 ? args[3] : null;\n\n// Optional: set this if you want to force-opening a specific model file when none is open.\n// If you’re writing a general utility, you might leave it null and let the user open/select.\n        string? modelPath = null;\n// Example:\n// modelPath = @\"C:\\Users\\Public\\Documents\\Sparx Systems\\EA\\EA Example.qea\";\n\n        Console.WriteLine(\"EA Automation Example – Add Element to Package\");\n        Console.WriteLine($\"Requested element: Name='{name}', Type='{type}', StereotypeEx='{stereotype ?? \"(none)\"}'\");\n\n        try\n        {\n            // ------------------------------------------------------------\n            // 1) Connect to EA, ensure a model is open, and show the UI\n            // ------------------------------------------------------------\n            using var ea = EAConnect.AttachOrLaunch(new EAConnect.Options\n            {\n                PreferAttach = true,        // attach to a running EA if possible\n                LaunchIfNotRunning = true,        // otherwise launch a new EA instance\n                ModelPath = modelPath,   // open a known model if none is open\n                ShowUI = true,        // show EA UI so user sees what happens\n                StartupWaitMs = 1500,        // small settle time after opening/launching\n                RepoPollMs = 100,         // poll interval for App.Repository\n                RepoPollMax = 50           // up to 5 seconds for Repo to appear\n            });\n\n            // -----------------------------------------------------------------------\n            // 2) Find the working package: selected package or fallback to root[0]\n            // -----------------------------------------------------------------------\n            Package pkg = ea.GetSelectedPackageOrRoot();\n            Console.WriteLine($\"Target package: {pkg.Name} (ID={pkg.PackageID})\");\n\n            // --------------------------------------------------------\n            // 3) Create a new element inside that package (core steps)\n            //    - AddNew(name, type)\n            //    - Set optional properties (Notes, StereotypeEx)\n            //    - Update() to persist changes\n            // --------------------------------------------------------\n            Element el = (Element)pkg.Elements.AddNew(name, type);\n\n            if (!string.IsNullOrEmpty(stereotype))\n            {\n                // For MDG types, you can set fully qualified stereotype (e.g., \"BPMN2.0::Task\")\n                el.StereotypeEx = stereotype;\n            }\n\n            if (!string.IsNullOrWhiteSpace(notes))\n                el.Notes = notes;\n\n            // Persist the new element into the repository\n            if (!el.Update())\n            {\n                // If Update() returns false, EA has an error you can read via\n                // repo.GetLastError()\n                throw new InvalidOperationException(\"Element.Update() failed.\");\n            }\n\n            // ------------------------------------------------------------------------\n            // 4) Refresh EA’s UI so the user immediately sees the new element appear\n            // ------------------------------------------------------------------------\n            // - AdviseElementChange: tells EA something changed – updates any open diagrams\n            // - RefreshModelView   : reloads the package in the Project Browser\n            ea.Repo.AdviseElementChange(el.ElementID);\n            ea.Repo.RefreshModelView(pkg.PackageID);\n\n            Console.WriteLine($\"Created: {el.Name} [{el.Type}]\");\n            Console.WriteLine($\"GUID   : {el.ElementGUID}\");\n\n            // -----------------------------------------\n            // 5) Bonus: enumerate elements in the pkg\n            // -----------------------------------------\n            Console.WriteLine();\n            Console.WriteLine(\"Elements now present in package:\");\n            short count = pkg.Elements.Count;\n            for (short i = 0; i &lt; count; i++)\n            {\n                var existing = (Element)pkg.Elements.GetAt(i);\n                Console.WriteLine($\"  - {existing.Name} ({existing.Type})\");\n            }\n\n            Console.WriteLine();\n            Console.WriteLine(\"Done. Press any key to exit.\");\n            Console.ReadKey();\n        }\n        catch (Exception ex)\n        {\n// In production tools you might log the stack. For a book example, keep output readable.\n            Console.WriteLine();\n            Console.WriteLine(\"ERROR:\");\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(\"Tip: Ensure EA is installed (matching x64/x86), Interop.EA.dll is referenced,\");\n            Console.WriteLine(\"     and that a model is open or ModelPath is set.\");\n            Console.WriteLine(\"Press any key to exit.\");\n            Console.ReadKey();\n        }\n    }\n}",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 6: External Automation</span>"
    ]
  },
  {
    "objectID": "07-System.Object[].html#trade-offs",
    "href": "07-System.Object[].html#trade-offs",
    "title": "Chapter 6: External Automation",
    "section": "Trade-offs",
    "text": "Trade-offs\nPros\n\nModern language, logging, testing, and packaging.\nClear separation from the model repository.\nWorks well for integrations, analytics, and pipelines.\nEasier to scale and maintain over time.\n\nCons\n\nRequires setup (Interop reference, bitness alignment, COM availability).\nWindows/COM dependency.\nDistribution/versioning outside the model.\nSpeed + power mean mistakes propagate quickly if you skip safety.\n\nSafety still matters\n\nPrefer dry-run patterns and audit logs for batch updates.\nUse SQL-find + API-write for scale (helper provides this).\nTest on sandbox repositories first.\nBatch writes and refresh the UI once per operation.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 6: External Automation</span>"
    ]
  },
  {
    "objectID": "07-System.Object[].html#where-this-goes-next",
    "href": "07-System.Object[].html#where-this-goes-next",
    "title": "Chapter 6: External Automation",
    "section": "Where this goes next",
    "text": "Where this goes next\nMost teams adopt a blended approach: internal scripts for quick hygiene; external utilities for integrations and heavy lifting; add-ins for stable, menu-driven capabilities. With EAConnect, you keep examples concise while centralising boilerplate and sharp edges in one place.\nSee Appendix A – EAConnect Helper & Setup for the full helper class (verbose header, usage, assumptions, dependencies, and update history), plus environment notes (Interop.EA.dll, bitness, COM), optional “directory-only” output pickers, CSV logging utilities, a curate-then-apply pipeline, and the SQL-accelerated find / API-safe write pattern.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Chapter 6: External Automation</span>"
    ]
  },
  {
    "objectID": "08-System.Object[].html",
    "href": "08-System.Object[].html",
    "title": "Chapter 7: Script Design Patterns",
    "section": "",
    "text": "Why Patterns Matter\nWhen you first begin scripting in Enterprise Architect, the process feels like a series of one-off solutions. You need to rename a batch of elements, so you write a loop. You want to add a tagged value everywhere, so you copy and tweak the loop. You need to enforce a naming convention, so you adjust the loop again. Each script solves the immediate problem but looks and feels slightly different from the last. After a while, you realise you are writing the same structural code over and over, just with small changes in logic.\nThis is not accidental. EA scripting tasks fall into recurring shapes. Recognising these shapes and naming them as design patterns gives you a powerful advantage. Instead of starting from scratch each time, you select the right pattern and plug in your task-specific logic. Patterns make scripts shorter, safer, and more consistent. They also make it easier to share code with colleagues, because everyone recognises the pattern being used.\nThis chapter introduces a handful of design patterns that cover the majority of practical EA scripting needs. They are not patterns in the object-oriented sense of Singleton or Observer, but scripting patterns tuned to the EA environment. Each one addresses a class of problems — traversing and filtering elements, applying changes in two phases, propagating metadata, checking quality. Once you master them, scripting EA becomes less about inventing and more about assembling known patterns into solutions.\nThe first reason to adopt patterns is safety. Many script errors arise because someone hand-coded a loop in haste, forgot to check ObjectType, or failed to include Update(). A pattern encapsulates safe practices — dry-run flags, logging, backwards deletion, UI refreshes — so you don’t have to remember them each time.\nThe second reason is productivity. A good pattern reduces boilerplate. You can focus on what the script should do, rather than how to set up the loop. For example, the Find/Filter/Apply pattern sets up traversal for you; you just provide the filter condition and the apply logic.\nThe third reason is communication. When you share a script with a colleague and they see it follows a known pattern, they can understand it quickly. It creates a shared vocabulary: “oh, this is a Curate-then-Write script” means more than “this is some code that loops twice.”",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 7: Script Design Patterns</span>"
    ]
  },
  {
    "objectID": "08-System.Object[].html#examples",
    "href": "08-System.Object[].html#examples",
    "title": "Chapter 7: Script Design Patterns",
    "section": "Examples",
    "text": "Examples\n\nShared Helper\nDrop this small helper library in your script group (e.g., “\\_Common\\Helpers.js”) and !INC it from each script.\n\n\nExample 7.1 - Helpers.js (JScript ES3) – Common utility helpers\n\n// -------------------------------------------------------\n// Example 7.1 - Helpers.js (JScript ES3) – Common utility helpers\n// Purpose: Logging, safety utilities, folder picker, CSV writer\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n\n// ---- Safety & string helpers (ES3) ----\nfunction isNil(x) { return x === null || x === undefined; }\nfunction trim(s) { return isNil(s) ? \"\" : String(s).replace(/^\\s+|\\s+$/g, \"\"); }\nfunction equalsIgnoreCase(a, b) { return String(a||\"\").toLowerCase() == String(b||\"\").toLowerCase(); }\nfunction startsWith(s, p) { return String(s||\"\").indexOf(p) === 0; }\nfunction contains(s, sub) { return String(s||\"\").indexOf(sub) !== -1; }\n\n// ---- Output tab management ----\nfunction ensureOutputTab(name) {\n    try { Repository.CreateOutputTab(name); } catch(e) {}\n    try { Repository.ClearOutput(name); } catch(e) {}\n    try { Repository.EnsureOutputVisible(name); } catch(e) {}\n}\nfunction log(tab, msg) { Session.Output(\"[\" + tab + \"] \" + msg); }\n\n// ---- Folder picker (directory only; no file names) ----\nfunction browseForFolder(promptText) {\n    // Shell.BrowseForFolder is reliable and does *directory only*\n    var shell = new ActiveXObject(\"Shell.Application\");\n    var folder = shell.BrowseForFolder(0, promptText, 0, 0);\n    if (!folder) return null;\n    // Ensure plain path (Self.Path)\n    return folder.Self.Path;\n}\n\n// ---- CSV writer (append; creates file on first write) ----\nfunction CsvWriter(path) {\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var file = null;\n    function openAppend() {\n// 8 = ForAppending, 2 = TristateTrue (Unicode); EA often prefers ANSI, so use default\n// (TristateFalse=0)\n// We'll stick with default encoding for broader compatibility.\n        file = fso.OpenTextFile(path, 8, true);\n    }\n    this.writeHeader = function(headerLine) {\n        if (!file) openAppend();\n        file.WriteLine(headerLine);\n    };\n    this.writeRow = function(arr) {\n        if (!file) openAppend();\n        var i, out = \"\";\n        for (i=0; i&lt;arr.length; i++) {\n            var cell = String(arr[i]).replace(/\"/g, '\"\"');   // escape quotes\n            if (contains(cell, \",\") || contains(cell, \"\\\"\") ) {\n                out += \"\\\"\" + cell + \"\\\"\";\n            } else {\n                out += cell;\n            }\n            if (i &lt; arr.length - 1) out += \",\";\n        }\n        file.WriteLine(out);\n    };\n    this.close = function() { if (file) file.Close(); };\n}\n\n// ---- Timing helper ----\nfunction nowMs() { \n  return (new Date()).getTime(); \n  }\n\n\n\nPattern 1 – Find / Filter / Apply\nThe most common pattern in EA scripting is:\n\nFind a collection of items (elements, connectors, diagrams).\nFilter them based on conditions (type, stereotype, missing tag).\nApply an action (rename, add tag, log).\n\nThis pattern underlies most governance checks and batch updates. It is safe, scalable, and easy to extend. You will see many examples in this chapter where the Find/Filter/Apply loop is the skeleton on which the logic hangs.\nWhen to use: bulk changes with clear criteria (e.g. rename, retag, stereotype changes).\nWhy: separates selection from action; an easy, safe mental model.\n\n\nExample 7.2 - Pattern1_FindFilterApply.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 7.2 - Pattern1_FindFilterApply.js – JScript (ES3)\n// Purpose: Demonstrates Find/Filter/Apply on elements in a selected package\n// Usage: Select a package → run script. Uses dry-run by default.\n// Assumptions:\n// - ES3 only; EA collections require Count/GetAt(i)\n// - No modern JS features\n// Parameters: adjust TYPE_FILTER / NAME_PREFIX to your needs\n// Dependencies: Helpers.js (browseForFolder, CsvWriter, logging)\n// Update history: 1.0 initial\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"FindFilterApply\";\n    ensureOutputTab(TAB);\n\n    // ---- Config ----\n    var DRY_RUN = true;                 // switch to false to commit\n    var TYPE_FILTER = \"Class\";          // only operate on these element types (e.g., \"Requirement\", \"Capability\")\n    var NAME_PREFIX = \"ARCH_\";          // example change: ensure name has this prefix\n    var WRITE_CSV = true;\n\n    // ---- Context ----\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Please select a package.\", promptOK); return; }\n\n    log(TAB, \"Selected package: \" + pkg.Name + \" (ID \" + pkg.PackageID + \")\");\n    var t0 = nowMs();\n\n    // ---- CSV setup (directory-only; no filename prompts) ----\n    var csv = null;\n    if (WRITE_CSV) {\n        var dir = browseForFolder(\"Select output folder for log CSV (directory only):\");\n        if (dir) {\n            var stamp = (new Date()).getTime();\n            var outPath = dir + \"\\\\pattern1_find_filter_apply_\" + stamp + \".csv\";\n            csv = new CsvWriter(outPath);\n            csv.writeHeader(\"ElementID,GUID,OldName,NewName,Type,Action\");\n            log(TAB, \"Logging to: \" + outPath);\n        } else {\n            log(TAB, \"No folder selected; CSV logging disabled.\");\n        }\n    }\n\n    // ---- Find & filter ----\n    var targets = [];\n    var elements = pkg.Elements;\n    var i;\n    for (i=0; i&lt;elements.Count; i++) {\n        var el = elements.GetAt(i);\n        if (!equalsIgnoreCase(el.Type, TYPE_FILTER)) continue;\n\n        // Filter condition: name missing prefix\n        var hasPrefix = startsWith(el.Name, NAME_PREFIX);\n        if (!hasPrefix) targets.push(el);\n    }\n    log(TAB, \"Found \" + targets.length + \" target(s).\");\n\n    // ---- Apply ----\n    var changed = 0;\n    for (i=0; i&lt;targets.length; i++) {\n        var e = targets[i];\n        var oldName = e.Name;\n        var newName = NAME_PREFIX + oldName;\n\n        if (csv) csv.writeRow([e.ElementID, e.ElementGUID, oldName, newName, e.Type, (DRY_RUN? \"DRY-RUN\" : \"RENAME\")]);\n\n        if (!DRY_RUN) {\n            e.Name = newName;\n            e.Update(); // persist\n        }\n        changed++;\n    }\n\n    // Refresh UI if we wrote changes\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n\n    var dt = nowMs() - t0;\n    log(TAB, \"Changed \" + changed + \" / \" + targets.length + \" target(s). Dry-run=\" + DRY_RUN + \". Time=\" + dt + \"ms\");\n\n    if (csv) csv.close();\n}\n\nmain();\n\n\n\nPattern 2 – Curate-then-Write (2-Phase Updates)\nSometimes you cannot safely update as you go. Perhaps you want to check what will change before actually changing it. Perhaps you want to let a governance board review the list before updates are applied.\nThe Curate-then-Write pattern solves this by splitting the process into two phases:\n\nCurate — gather and log the items that would be changed (always with DRY_RUN).\nWrite — only later, with approval, run the script again with changes applied.\n\nThis pattern reduces risk and increases confidence. It mirrors the dry-run principle, but formalises it into a workflow.\nWhen to use: risky or large updates. First produce a reviewable CSV, then run again to apply.\nWhy: EA has no transactions; curate first to avoid irreversible bulk mistakes.\n\n\nExample 7.3 - Pattern1_FindFilterApply.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 7.3 - Pattern2_CurateThenWrite.js – JScript (ES3)\n// Purpose: Phase 1 = produce CSV for review; Phase 2 = read curated CSV and apply\n// Usage:\n//  - Phase 1: set MODE=\"export\" → generates CSV with proposed changes\n//  - Review/edit the CSV (approve rows by setting Apply=YES)\n//  - Phase 2: set MODE=\"apply\"  → reads CSV and applies only approved rows\n// Assumptions:\n//  - ES3 only; CSV written in ANSI for broad compatibility\n//  - Directory chooser only (no filename prompts)\n// Dependencies: Helpers.js\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"CurateThenWrite\";\n    ensureOutputTab(TAB);\n\n    // ---- Config ----\n    var MODE = \"export\";          // \"export\" or \"apply\"\n    var TYPE_FILTER = \"Requirement\";\n    var PROPOSED_STATUS = \"Approved\";\n\n    if (MODE == \"export\") return exportPhase(TAB, TYPE_FILTER, PROPOSED_STATUS);\n    if (MODE == \"apply\")  return applyPhase(TAB);\n    Session.Prompt(\"Unknown MODE. Use 'export' or 'apply'.\", promptOK);\n}\n\nfunction exportPhase(TAB, TYPE_FILTER, PROPOSED_STATUS) {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var dir = browseForFolder(\"Select output folder for curation CSV:\");\n    if (!dir) { log(TAB, \"Cancelled.\"); return; }\n\n    var stamp = (new Date()).getTime();\n    var path = dir + \"\\\\pattern2_curate_export_\" + stamp + \".csv\";\n    var csv = new CsvWriter(path);\n    csv.writeHeader(\"Apply,ElementID,GUID,Name,Type,CurrentStatus,ProposedStatus,Notes\");\n\n    var i, elements = pkg.Elements;\n    var exported = 0;\n    for (i=0; i&lt;elements.Count; i++) {\n        var e = elements.GetAt(i);\n        if (!equalsIgnoreCase(e.Type, TYPE_FILTER)) continue;\n        // Propose: set Status to PROPOSED_STATUS\n        csv.writeRow([\"NO\", e.ElementID, e.ElementGUID, e.Name, e.Type, e.Status, PROPOSED_STATUS, \"Set to Approved if meets criteria X\"]);\n        exported++;\n    }\n    csv.close();\n    log(TAB, \"Wrote \" + exported + \" row(s) to \" + path + \". Review and change 'Apply' to YES where appropriate.\");\n}\n\nfunction applyPhase(TAB) {\n    // Directory-only input: we’ll look for a single CSV file in the chosen folder by pattern.\n    var dir = browseForFolder(\"Select folder that contains curated CSV (pattern2_curate_export_*.csv):\");\n    if (!dir) { log(TAB, \"Cancelled.\"); return; }\n\n    // Very simple scan for the newest curated CSV file\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var folder = fso.GetFolder(dir);\n    var en = new Enumerator(folder.Files);\n    var newest = null, newestTime = 0;\n    for (; !en.atEnd(); en.moveNext()) {\n        var file = en.item();\n        if (contains(file.Name, \"pattern2_curate_export_\") && endsWith(file.Name, \".csv\")) {\n            if (file.DateLastModified.getTime() &gt; newestTime) {\n                newest = file; newestTime = file.DateLastModified.getTime();\n            }\n        }\n    }\n    if (!newest) { log(TAB, \"No curated CSV found.\"); return; }\n    log(TAB, \"Applying from: \" + newest.Path);\n\n    // Read CSV line by line (very simple parser; assumes no commas in unquoted cells)\n    var ts = fso.OpenTextFile(newest.Path, 1); // ForReading\n    // Skip header\n    if (!ts.AtEndOfStream) ts.ReadLine();\n\n    var applied = 0, considered = 0;\n    while (!ts.AtEndOfStream) {\n        var line = ts.ReadLine();\n        var cells = line.split(\",\");\n        if (cells.length &lt; 8) continue;\n        var apply = trim(cells[0]);\n        var elementID = parseInt(cells[1], 10);\n        var proposedStatus = trim(cells[6]);\n\n        considered++;\n        if (!equalsIgnoreCase(apply, \"YES\")) continue; // only approved rows\n\n        var e = Repository.GetElementByID(elementID);\n        if (!e) continue;\n        e.Status = proposedStatus;\n        e.Update();\n        applied++;\n    }\n    ts.Close();\n\n    if (applied&gt;0) Repository.RefreshModelView(0);\n    log(TAB, \"Applied \" + applied + \" change(s) out of \" + considered + \" curated row(s).\");\n}\n\n// ES3 helper – endsWith (not natively available)\nfunction endsWith(s, suffix) {\n    s = String(s||\"\");\n    var idx = s.lastIndexOf(suffix);\n    return idx &gt;= 0 && (idx + suffix.length === s.length);\n}\n\nmain();\n\n\n\nPattern 3 – Tag Propagation (Parent → Children)\nAnother frequent need is to ensure that metadata flows correctly between related elements. For example, if a Capability has an Owner tag, then all its linked Requirements should inherit that Owner. Or if a System has a Criticality tag, then its Interfaces should carry the same.\nThe Tag Propagation pattern handles this: traverse a relationship, read a tag from one element, apply it to another, log the change. It enforces consistency and helps maintain traceability.\nWhen to use: enforce a tagged value from a parent element or package onto all contained elements (e.g., Domain=Diabetes).\nOptions: set only if missing, or overwrite.\n\n\nExample 7.4 - Pattern3_TagPropagation.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 7.4 - Pattern3_TagPropagation.js – JScript (ES3)\n// Purpose: Copy a tagged value from a selected *source element*\n//          to all elements in a selected *target package*\n// Usage: Select source element → run; then select target package → run\n// Assumptions: source has TagName present; target elements may or may not\n// Safety: DRY_RUN = true by default\n// Dependencies: Helpers.js\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"TagPropagation\";\n    ensureOutputTab(TAB);\n\n    // ---- Config ----\n    var DRY_RUN = true;\n    var TAG_NAME = \"Domain\";\n    var OVERWRITE = false;  // false = set only if missing\n\n    // ---- Step 1: obtain source tag from selected element ----\n    var src = Repository.GetTreeSelectedObject();\n    if (!src || src.ObjectType != otElement) {\n        Session.Prompt(\"Select the *source element* that contains the tag '\" + TAG_NAME + \"'.\", promptOK);\n        return;\n    }\n    var srcVal = readTag(src, TAG_NAME);\n    if (trim(srcVal) === \"\") {\n        Session.Prompt(\"Source element does not have tag '\" + TAG_NAME + \"'.\", promptOK);\n        return;\n    }\n\n    // ---- Step 2: ask user to select target *package* ----\n    Session.Prompt(\"Now select the *target package* and run the script again to apply propagation.\", promptOK);\n\n    // If you prefer one-run UX: comment out the prompt above and use GetTreeSelectedPackage()\n    // directly\n}\n\nfunction applyToTarget() {\n    var TAB = \"TagPropagation\";\n    ensureOutputTab(TAB);\n\n    var DRY_RUN = true;\n    var TAG_NAME = \"Domain\";\n    var OVERWRITE = false;\n\n    // Re-get source from memory? For simplicity here we re-read it from user:\n    // In practice you might stash it in a temp file or ask user for the value via InputBox.\n    var val = Session.Input(\"Enter value to propagate for tag '\" + TAG_NAME + \"':\", \"\");\n    if (trim(val) === \"\") { log(TAB, \"No value provided; aborting.\"); return; }\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a *target package*.\", promptOK); return; }\n\n    var i, changed=0, elements = pkg.Elements;\n    for (i=0; i&lt;elements.Count; i++) {\n        var e = elements.GetAt(i);\n        var cur = readTag(e, TAG_NAME);\n\n        if (trim(cur) === \"\") {\n            // tag missing → set\n            log(TAB, \"Set \" + TAG_NAME + \" on \" + e.Name + \" → \" + val);\n            if (!DRY_RUN) { writeTag(e, TAG_NAME, val); }\n            changed++;\n        } else if (OVERWRITE && cur != val) {\n            log(TAB, \"Overwrite \" + TAG_NAME + \" on \" + e.Name + \" : \" + cur + \" → \" + val);\n            if (!DRY_RUN) { writeTag(e, TAG_NAME, val); }\n            changed++;\n        }\n    }\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    log(TAB, \"Updated \" + changed + \" element(s). Dry-run=\" + DRY_RUN);\n}\n\n// ---- Tag helpers ----\nfunction readTag(e, name) {\n    var i, tvs = e.TaggedValues;\n    for (i=0; i&lt;tvs.Count; i++) {\n        var tv = tvs.GetAt(i);\n        if (equalsIgnoreCase(tv.Name, name)) return String(tv.Value||\"\");\n    }\n    return \"\";\n}\nfunction writeTag(e, name, value) {\n    var i, tvs = e.TaggedValues;\n    for (i=0; i&lt;tvs.Count; i++) {\n        var tv = tvs.GetAt(i);\n        if (equalsIgnoreCase(tv.Name, name)) {\n            tv.Value = value; tv.Update(); e.Update(); return;\n        }\n    }\n    // add new if not found\n    var ntv = tvs.AddNew(name, String(value));\n    ntv.Update(); e.Update();\n}\n\n// Choose which entry point to bind in EA’s Scripts window:\n// main() for step-by-step or applyToTarget() for one-shot after prompting\n// main();\napplyToTarget();\n\n\n\nPattern 4 – Linting & Quality Gates (Report-Only by Default)\nJust as programmers use “linters” to check code quality, modellers can use scripts to check model quality. The Linting pattern is about scanning the repository for “smells”: missing notes, duplicate names, orphaned elements, inconsistent stereotypes.\nThe script doesn’t necessarily fix the issues. It logs them, creates a report, and highlights what needs attention. This is especially powerful in enterprise settings where governance requires objective evidence of model quality.\nWhen to use: continuous hygiene checks (naming, required tags, required relationships).\nWhy: consistent, repeatable, fast feedback before governance reviews.\n\n\nExample 7.5 - Pattern4_LintQuality.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 7.5 - Pattern4_LintQuality.js – JScript (ES3)\n// Purpose: Report model \"smells\" in selected package (no writes by default)\n// Checks:\n//   - Name not empty\n//   - Required tag exists (e.g., \"Owner\")\n//   - Name matches regex prefix (e.g., \"REQ_\")\n// Output: CSV + Output tab; dry-run concept not needed (read-only)\n// Dependencies: Helpers.js\n// -------------------------------------------------------\n\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"Lint\";\n    ensureOutputTab(TAB);\n\n    // ---- Config ----\n    var REQUIRED_TAG = \"Owner\";\n    var NAME_PREFIX   = \"REQ_\";\n    var WRITE_CSV     = true;\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package to lint.\", promptOK); return; }\n\n    var dir=null, csv=null;\n    if (WRITE_CSV) {\n        dir = browseForFolder(\"Select output folder for lint report:\");\n        if (dir) {\n            var stamp = (new Date()).getTime();\n            var path = dir + \"\\\\pattern4_lint_report_\" + stamp + \".csv\";\n            csv = new CsvWriter(path);\n            csv.writeHeader(\"ElementID,GUID,Name,Type,Issue,Details\");\n            log(TAB, \"Logging to: \" + path);\n        }\n    }\n\n    var i, issues=0, elements = pkg.Elements;\n    for (i=0; i&lt;elements.Count; i++) {\n        var e = elements.GetAt(i);\n\n        // Check 1: name present\n        if (trim(e.Name) === \"\") {\n            issues += emit(csv, e, \"MissingName\", \"Element has no name\");\n        }\n\n        // Check 2: required tag exists\n        if (trim(readTag(e, REQUIRED_TAG)) === \"\") {\n            issues += emit(csv, e, \"MissingTag\", \"Required tag '\"+REQUIRED_TAG+\"' is missing or empty\");\n        }\n\n        // Check 3: naming convention\n        if (!startsWith(e.Name, NAME_PREFIX)) {\n            issues += emit(csv, e, \"NamePrefix\", \"Expected prefix '\" + NAME_PREFIX + \"'\");\n        }\n    }\n\n    if (csv) csv.close();\n    log(TAB, \"Lint finished. Issues found: \" + issues);\n}\n\nfunction emit(csv, e, issue, details) {\n    var line = e.ElementID + \" \" + e.Name + \" – \" + issue + \" : \" + details;\n    log(\"Lint\", line);\n    if (csv) csv.writeRow([e.ElementID, e.ElementGUID, e.Name, e.Type, issue, details]);\n    return 1;\n}\n\nfunction readTag(e, name) {\n    var i, tvs = e.TaggedValues;\n    for (i=0; i&lt;tvs.Count; i++) {\n        var tv = tvs.GetAt(i);\n        if (equalsIgnoreCase(tv.Name, name)) return String(tv.Value||\"\");\n    }\n    return \"\";\n}\n\nmain();\n\n\n\nPattern 5 – SQL-Accelerated Find, API-Safe Write (Hybrid)\nOne of the most effective ways to balance speed with safety in EA scripting is the hybrid pattern: use SQL to locate candidates, but rely on the API to perform updates.\n\nWhen to use: this approach shines when you need to identify thousands of elements quickly — for example, all Requirements missing an Owner tag, or all Components in a given layer. Traversing entire package trees with .Count and .GetAt() can be slow; SQL queries are much faster.\nWhy not just update with SQL? Because direct database updates bypass EA’s business rules and can corrupt the repository. That’s why writes must still go through the API.\n\nThe idea is simple:\n\nUse Repository.SQLQuery() with a SELECT statement to pull back the candidate IDs.\nParse the XML result to extract element IDs or GUIDs.\nLoop over those IDs, load each object via the API, and apply updates safely (Update() + RefreshModelView()).\n\nThis hybrid approach gives you the best of both worlds:\n\nFast selection (SQL can scan tens of thousands of rows in seconds).\nSafe updates (API ensures model integrity).\n\nIt is one of the most important performance patterns for large repositories.\nWhen to use: you need to find thousands of items quickly, but still want safe updates via the API (not raw SQL writes).\nIdea: use Repository.SQLQuery() to select candidates (fast), parse the XML result to get IDs, then loop via API for writes (safe).\n\n\nExample 7.6 - Pattern5_SqlFind_ApiWrite.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 7.6. - Pattern5_SqlFind_ApiWrite.js – JScript (ES3)\n// Purpose: Fast \"find\" via SQLQuery, then safe writes via API\n// Usage: Select any package (context not required for SQL); DRY_RUN=true by default\n// Dependencies: Helpers.js\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"SqlFindApiWrite\";\n    ensureOutputTab(TAB);\n\n    var DRY_RUN = true;\n    var TYPE_FILTER = \"Class\";\n    var STEREOTYPE_TO_SET = \"DomainObject\";\n\n    // 1) SQL find (XML result)\n    var sql = \"SELECT Object_ID, ea_guid, Name FROM t_object WHERE Object_Type='\" + TYPE_FILTER + \"' AND Stereotype IS NULL\";\n    var xml = Repository.SQLQuery(sql);\n\n    // 2) Parse minimal XML (very simple string parsing; robust XML parser not available in ES3)\n    //    Expect rows like: &lt;Row&gt;&lt;Object_ID&gt;123&lt;/Object_ID&gt;&lt;ea_guid&gt;{...}&lt;/ea_guid&gt;&lt;Name&gt;Foo&lt;/Name&gt;&lt;/Row&gt;\n    var ids = extractAll(xml, \"&lt;Object_ID&gt;\", \"&lt;/Object_ID&gt;\");\n\n    var i, changed=0;\n    log(TAB, \"Candidates: \" + ids.length);\n\n    for (i=0; i&lt;ids.length; i++) {\n        var id = parseInt(trim(ids[i]), 10);\n        var e = Repository.GetElementByID(id);\n        if (!e) continue;\n\n        // Only set stereotype if empty (defensive sanity)\n        if (trim(e.Stereotype) === \"\") {\n            log(TAB, \"Set stereotype on \" + e.Name + \" → \" + STEREOTYPE_TO_SET);\n            if (!DRY_RUN) {\n                e.Stereotype = STEREOTYPE_TO_SET;\n                e.Update();\n            }\n            changed++;\n        }\n    }\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(0);\n    log(TAB, \"Changed \" + changed + \" element(s). Dry-run=\" + DRY_RUN);\n}\n\n// Minimal XML extraction helpers (no DOM available in ES3)\nfunction extractAll(hay, openTag, closeTag) {\n    var res = [], start=0;\n    while (true) {\n        var i = hay.indexOf(openTag, start);\n        if (i &lt; 0) break;\n        var j = hay.indexOf(closeTag, i + openTag.length);\n        if (j &lt; 0) break;\n        var val = hay.substring(i + openTag.length, j);\n        res.push(val);\n        start = j + closeTag.length;\n    }\n    return res;\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 7: Script Design Patterns</span>"
    ]
  },
  {
    "objectID": "08-System.Object[].html#pattern-handling",
    "href": "08-System.Object[].html#pattern-handling",
    "title": "Chapter 7: Script Design Patterns",
    "section": "Pattern Handling",
    "text": "Pattern Handling\n\nPatterns as a Library\nThe beauty of patterns is that they can be turned into a script library. Instead of writing bespoke code, you start from a template:\n\n\nExample 7.7 - findFilteredApply\n\n// -------------------------------------------------------------------------------------------\n// Example 7.7 - findFilteredApply\n// -------------------------------------------------------------------------------------------\nfunction findFilterApply(pkg, filterFn, applyFn) {\n    var els = pkg.Elements;\n    for (var i = 0; i &lt; els.Count; i++) {\n        var e = els.GetAt(i);\n        if (filterFn(e)) {\n            applyFn(e);\n        }\n    }\n}\n\nWith such a template, your script becomes simply the filter and apply functions. The boilerplate is taken care of. Even within EA’s limited JScript environment, this approach saves effort and reduces bugs.\n\n\nPatterns and Governance\nOne of the most important applications of patterns is governance. Large organisations rely on consistent models for reporting, compliance, and decision-making. Manual governance is too slow. Patterns like Find/Filter/Apply and Linting turn governance into a repeatable, automated process.\nFor example, you can script a governance check that every Requirement must have an Owner tag. The script follows the Find/Filter/Apply pattern, filters Requirements, checks tags, and logs violations. By running it regularly, you maintain model hygiene.\n\n\nPatterns Across Languages\nAlthough the examples in this chapter are in JScript, the patterns themselves are language-agnostic. If you later write external automation in Python or C#, the same patterns apply. A Find/Filter/Apply loop in Python looks slightly different, but the structure is identical. This makes patterns a great way to transfer knowledge across teams and technologies.\n\n\nThe Safety Net of Patterns\nPatterns also act as a safety net against AI hallucinations. As we saw earlier, AI can generate starter scripts but often introduces unsupported syntax. If you know the underlying pattern, you can spot and correct mistakes quickly. For example, if AI gives you a forEach, you know the pattern requires a .Count/.GetAt() loop, and you can adjust accordingly.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 7: Script Design Patterns</span>"
    ]
  },
  {
    "objectID": "08-System.Object[].html#performance-safety-notes",
    "href": "08-System.Object[].html#performance-safety-notes",
    "title": "Chapter 7: Script Design Patterns",
    "section": "Performance & Safety Notes",
    "text": "Performance & Safety Notes\n\nPrefer Find/Filter/Apply for clarity; switch to SQL-accelerated find when scale demands it.\nKeep DRY_RUN = true until you’ve inspected CSV logs.\nCall Update() after modifications, then RefreshModelView() for UI.\nFor very large sets, consider chunking (operate in batches of, say, 250 items) and pausing UI updates:\n// Pseudocode – EA may ignore UI flag in some contexts; rely on batching regardless\n// Repository.EnableUIUpdates = false; // not always honoured\n// …do batches…\n// Repository.EnableUIUpdates = true;\n// Repository.RefreshModelView(0);",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 7: Script Design Patterns</span>"
    ]
  },
  {
    "objectID": "08-System.Object[].html#bonus-python-curate-apply-pipeline",
    "href": "08-System.Object[].html#bonus-python-curate-apply-pipeline",
    "title": "Chapter 7: Script Design Patterns",
    "section": "Bonus: Python “Curate → Apply” Pipeline",
    "text": "Bonus: Python “Curate → Apply” Pipeline\nUse this when CSV shaping, validation or integration (e.g., SharePoint, Jira) is easier outside EA.\n\n\nExample 7.8 - pattern6_curate_apply_external.py – Python 3 (pywin32)\n\n# -------------------------------------------------------\n# Example 7.8 - pattern6_curate_apply_external.py – Python 3 (pywin32)\n# Purpose: Read a curated CSV of element updates and apply via EA API\n# Safety: Only rows with Apply=YES are executed\n# -------------------------------------------------------\nimport csv, win32com.client\n\ndef main(csv_path):\n    ea = win32com.client.Dispatch(\"EA.App\")\n    repo = ea.Repository\n\n    changes = 0\n    with open(csv_path, \"r\") as f:\n        rdr = csv.DictReader(f)\n        for row in rdr:\n            if str(row.get(\"Apply\",\"\")).strip().lower() != \"yes\":\n                continue\n            eid = int(row[\"ElementID\"])\n            new_status = row[\"ProposedStatus\"]\n\n            e = repo.GetElementByID(eid)\n            if e:\n                e.Status = new_status\n                e.Update()\n                changes += 1\n\n    if changes:\n        repo.RefreshModelView(0)\n    print(f\"Applied {changes} curated change(s).\")\n\nif __name__ == \"__main__\":\n    main(r\"C:\\path\\to\\pattern2_curate_export_123.csv\")",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 7: Script Design Patterns</span>"
    ]
  },
  {
    "objectID": "08-System.Object[].html#what-to-use-when-cheat-sheet",
    "href": "08-System.Object[].html#what-to-use-when-cheat-sheet",
    "title": "Chapter 7: Script Design Patterns",
    "section": "What to Use When (cheat-sheet)",
    "text": "What to Use When (cheat-sheet)\n\nSmall, safe rename/retag → Pattern 1 (Find/Filter/Apply).\nRisky/wide updates → Pattern 2 (Curate-then-Write).\nSet common metadata → Pattern 3 (Tag Propagation).\nGovernance checks → Pattern 4 (Linting & Quality Gates).\nHuge models → Pattern 5 (SQL-find, API-write).\nPipelines & integrations → Python external bonus.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Chapter 7: Script Design Patterns</span>"
    ]
  },
  {
    "objectID": "09-System.Object[].html",
    "href": "09-System.Object[].html",
    "title": "Chapter 8: Object Details",
    "section": "",
    "text": "Sparx EA Objects\nEnterprise Architect’s automation interface exposes a large number of objects, each representing some aspect of the model: repositories, packages, elements, connectors, attributes, tagged values, and many more. The official Sparx documentation lists these objects, but it can be terse and difficult to map back to day-to-day modelling tasks.\nThis chapter bridges that gap: it introduces the most common objects in the API, explains how to use their attributes and collections, and provides fully commented JScript examples you can run directly in EA.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 8: Object Details</span>"
    ]
  },
  {
    "objectID": "09-System.Object[].html#sparx-ea-objects",
    "href": "09-System.Object[].html#sparx-ea-objects",
    "title": "Chapter 8: Object Details",
    "section": "",
    "text": "Repository\nThe Repository is always your starting point. It represents the currently open EA project file (EAP, QEA, or DBMS connection).\n\n\nExample 8.1 - RepoInfo\n\n// ----------------------------------------------------------------------------------------\n// Example 8.1 - RepoInfo\n// Purpose: Demonstrates key Repository properties\n// Author: Handbook\n// Date: 2025-08-26\n// ----------------------------------------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    // The Repository object is always available inside EA scripts\n    var repo = Repository;\n\n    // Connection string: file path or DB connection string\n    Session.Output(\"Connection: \" + repo.ConnectionString);\n\n    // Root models\n    var models = repo.Models;\n    Session.Output(\"Root packages count: \" + models.Count);\n\n    // Security\n    Session.Output(\"Security enabled: \" + repo.IsSecurityEnabled);\n\n    // Current EA Edition\n    Session.Output(\"Edition: \" + repo.EAEdition);\n}\n\nmain();\n\n\n\nPackage\nA Package is a container for elements, diagrams, and child packages.\n\n\nExample 8.2 - PackageTraverse\n\n// ----------------------------------------------------------------------------------------\n// Example 8.2 PackageTraverse\n// Purpose: List all child packages and their elements\n// ----------------------------------------------------------------------------------------\n\n!INC Local Scripts.EAConstants-Jscript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) {\n        Session.Prompt(\"Select a package in the browser.\", promptOK);\n        return;\n    }\n\n    Session.Output(\"Package: \" + pkg.Name);\n\n    // Loop child packages\n    var childPkgs = pkg.Packages;\n    for (var i = 0; i &lt; childPkgs.Count; i++) {\n        var child = childPkgs.GetAt(i);\n        Session.Output(\"  Child package: \" + child.Name);\n    }\n\n    // Loop elements in this package\n    var elements = pkg.Elements;\n    for (var j = 0; j &lt; elements.Count; j++) {\n        var el = elements.GetAt(j);\n        Session.Output(\"  Element: \" + el.Name + \" (\" + el.Type + \")\");\n    }\n}\n\nmain();\n\n\n\nElement\nAn Element is any model item (Class, Requirement, Component, Actor, etc.).\n\n\nExample 8.3 - ElementCreate\n\n// ----------------------------------------------------------------------------------------\n// Example 8.3 - ElementCreate\n// Purpose: Add a new class to a selected package\n// ----------------------------------------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    // Add a new Class element\n    var el = pkg.Elements.AddNew(\"NewClass\", \"Class\");\n    el.Notes = \"This class was created by script.\";\n    el.Update(); // Always update to persist\n\n    // Refresh UI so user sees it\n    Repository.RefreshModelView(pkg.PackageID);\n\n    Session.Output(\"Created class: \" + el.Name);\n}\n\nmain();\n\n\n\nConnector\nA Connector represents a relationship between two elements.\n\n\nExample 8.4 - ConnectorCreate\n\n// ----------------------------------------------------------------------------------------\n// Example 8.4 - ConnectorCreate\n// Purpose: Create a dependency between two selected elements\n// ----------------------------------------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\n\nfunction main() {\n    // Assumes two elements are selected in a diagram\n    var diagram = Repository.GetCurrentDiagram();\n    if (!diagram) { Session.Prompt(\"Open a diagram and select two elements.\", promptOK); return; }\n\n    if (diagram.SelectedObjects.Count != 2) {\n        Session.Prompt(\"Select exactly two elements.\", promptOK);\n        return;\n    }\n\n    var el1 = Repository.GetElementByID(diagram.SelectedObjects.GetAt(0).ElementID);\n    var el2 = Repository.GetElementByID(diagram.SelectedObjects.GetAt(1).ElementID);\n\n    // Create dependency\n    var conn = el1.Connectors.AddNew(\"\", \"Dependency\");\n    conn.SupplierID = el2.ElementID;\n    conn.Update();\n\n    Repository.RefreshModelView(el1.PackageID);\n    Session.Output(\"Created dependency: \" + el1.Name + \" → \" + el2.Name);\n}\n\nmain();\n\n\n\nAttribute\nAttributes belong to elements (e.g., class fields).\n\n\nExample 8.5 - AddAttributes\n\n// ----------------------------------------------------------------------------------------\n// Example 8.5 - AddAttributes\n// Purpose: Add attributes to a selected class\n// ----------------------------------------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\n\nfunction main() {\n    var el = Repository.GetTreeSelectedObject();\n    if (!el || el.ObjectType != otElement) {\n        Session.Prompt(\"Select a class element.\", promptOK);\n        return;\n    }\n    if (el.Type != \"Class\") {\n        Session.Prompt(\"Element is not a class.\", promptOK);\n        return;\n    }\n\n    // Add attribute\n    var attr = el.Attributes.AddNew(\"id\", \"int\");\n    attr.Notes = \"Primary key\";\n    attr.Update();\n\n    el.Update();\n    Session.Output(\"Added attribute 'id:int' to \" + el.Name);\n}\n\nmain();\n\n\n\nTagged Values\nTagged Values extend elements and connectors with metadata.\n\n\nExample 8.6 - TagValuesDemo\n\n// ----------------------------------------------------------------------------------------\n// Example 8.6 - TagValuesDemo\n// Purpose: Add or update tagged values\n// ----------------------------------------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\n\nfunction main() {\n    var el = Repository.GetTreeSelectedObject();\n    if (!el || el.ObjectType != otElement) {\n        Session.Prompt(\"Select an element.\", promptOK);\n        return;\n    }\n\n    // Add new tag\n    var tag = el.TaggedValues.AddNew(\"Owner\", \"ArchitectureTeam\");\n    tag.Update();\n\n    // Update element after tag change\n    el.Update();\n\n    Session.Output(\"Tagged value 'Owner=ArchitectureTeam' set on \" + el.Name);\n}\n\nmain();\n\n\n\nDiagram Objects\nDiagram objects are visual instances of elements. They store coordinates, styles, and appearance, not the semantic content.\n\n\nExample 8.7 - DiagramObjectStyle\n\n// ----------------------------------------------------------------------------------------\n// Example 8.7 - DiagramObjectStyle\n// Purpose: Change fill color of selected diagram object\n// ----------------------------------------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\n\nfunction main() {\n    var dia = Repository.GetCurrentDiagram();\n    if (!dia) { Session.Prompt(\"Open a diagram.\", promptOK); return; }\n\n    if (dia.SelectedObjects.Count == 0) {\n        Session.Prompt(\"Select at least one element on the diagram.\", promptOK);\n        return;\n    }\n\n    var dobj = dia.SelectedObjects.GetAt(0);\n    dobj.BackgroundColor = 16777215; // White\n    dobj.Update();\n\n    Repository.ReloadDiagram(dia.DiagramID);\n    Session.Output(\"Updated background color for object ID \" + dobj.InstanceID);\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 8: Object Details</span>"
    ]
  },
  {
    "objectID": "09-System.Object[].html#summary",
    "href": "09-System.Object[].html#summary",
    "title": "Chapter 8: Object Details",
    "section": "Summary",
    "text": "Summary\nThis chapter covered the most important objects in EA’s automation model: Repository, Package, Element, Connector, Attribute, TaggedValue, and DiagramObject. Each has specific rules:\n\nAlways call Update() to persist changes.\nUse .Count and .GetAt(i) for collections (they are not arrays).\nRefresh the model or diagram to see changes in the UI.\nBe cautious with null values (names, tags).",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Chapter 8: Object Details</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html",
    "href": "10-System.Object[].html",
    "title": "Chapter 9: Imports & Exports",
    "section": "",
    "text": "Why Imports Matter\nOne of the first serious challenges you encounter when scripting Enterprise Architect is how to move data in and out of the repository. A model is rarely a self-contained island. Requirements may start life in Jira or Excel. Application inventories may be stored in a CMDB. Metadata may need to be exported to registries or analytics platforms. Architects frequently face the practical need to import content into EA or export content from EA to other systems.\nThis chapter focuses on imports and exports — arguably the most common automation tasks in EA. At first glance, they may seem trivial: read from CSV, create elements, write back. But once you attempt real-world imports and exports, you quickly discover subtle complexities: handling GUIDs, avoiding duplicates, ensuring round-trip consistency, and dealing with encoding.\nUnderstanding these complexities is essential. A poorly designed import script can flood your repository with duplicates. A naïve export may omit critical metadata or lose relationships. The goal of this chapter is to build robust patterns for imports and exports that are safe, repeatable, and auditable.\nImports are the way EA connects to upstream sources of truth. In many organisations, architects are not the ones who originate requirements, applications, or datasets. Those live in other systems. EA is where they are curated, connected, and visualised.\nFor example:\nWithout imports, EA risks becoming a disconnected silo. With imports, it becomes part of the wider enterprise information flow.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#why-imports-matter",
    "href": "10-System.Object[].html#why-imports-matter",
    "title": "Chapter 9: Imports & Exports",
    "section": "",
    "text": "Requirements authored in Jira need to be imported into EA for traceability.\nApplication inventories stored in Excel need to be imported as elements with tagged values.\nData elements defined in a registry need to be imported into EA’s logical data model.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#why-exports-matter",
    "href": "10-System.Object[].html#why-exports-matter",
    "title": "Chapter 9: Imports & Exports",
    "section": "Why Exports Matter",
    "text": "Why Exports Matter\nThe opposite direction is just as important. Many stakeholders do not use EA directly. They expect to see outputs in Excel, JSON, Confluence, or dashboards. Exports make EA’s content consumable.\nFor example:\n\nExporting element inventories to CSV for analysis in Excel.\nExporting model metadata to JSON for loading into a data catalog.\nExporting governance reports to Confluence for project teams.\n\nExports also serve as safety tools: before running a script that modifies content, export a snapshot for comparison.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#the-round-trip-challenge",
    "href": "10-System.Object[].html#the-round-trip-challenge",
    "title": "Chapter 9: Imports & Exports",
    "section": "The Round-Trip Challenge",
    "text": "The Round-Trip Challenge\nIn theory, import and export should be symmetrical: export, modify externally, import back. In practice, this is hard because of identity. How do you know that a row in CSV corresponds to the same element in EA?\nIf you match by name, duplicates are inevitable. If you match by ID, the ID may change across repositories. The robust solution is to use GUIDs. Every element, package, and connector in EA has a GUID. By exporting and re-importing GUIDs, you can round-trip reliably.\nThis chapter emphasises the importance of GUID handling in all import/export scripts.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#common-pitfalls",
    "href": "10-System.Object[].html#common-pitfalls",
    "title": "Chapter 9: Imports & Exports",
    "section": "Common Pitfalls",
    "text": "Common Pitfalls\nBeginners often stumble into a few traps when writing import/export scripts:\n\nDuplicate creation: forgetting to check if an element already exists before creating a new one.\nLost metadata: exporting only names, not tags, stereotypes, or relationships.\nEncoding errors: CSV exports losing accented characters due to ANSI encoding.\nUncontrolled scope: importing thousands of rows without dry-run or logging.\n\nEach of these pitfalls can damage model integrity. The patterns in this chapter address them with checks, dry-runs, and logs.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#choosing-a-format",
    "href": "10-System.Object[].html#choosing-a-format",
    "title": "Chapter 9: Imports & Exports",
    "section": "Choosing a Format",
    "text": "Choosing a Format\nThe two most common formats for imports and exports are CSV and JSON.\n\nCSV is simple, widely supported, and easy to review in Excel. It works best for tabular data: lists of requirements, applications, or tagged values.\nJSON is richer, supporting nested structures and hierarchies. It is more natural for hierarchical data, such as package trees or nested attributes.\n\nEA scripts can handle CSV easily using FileSystemObject. JSON is trickier because JScript lacks a parser, but you can still generate JSON strings. For parsing JSON, external automation (Python, C#) is usually better.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#guids-keys-and-identity",
    "href": "10-System.Object[].html#guids-keys-and-identity",
    "title": "Chapter 9: Imports & Exports",
    "section": "GUIDs, Keys, and Identity",
    "text": "GUIDs, Keys, and Identity\nAs mentioned earlier, GUIDs are the key to round-trip imports/exports. Best practice is:\n\nAlways export the GUID alongside names and types.\nWhen importing, check if the GUID exists in EA. If yes, update. If no, create.\nIf GUIDs are absent (e.g., external system), generate your own external ID tag (e.g., JiraKey). Use this as the round-trip identity.\n\nScripts should never rely on element names alone for identity.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#curated-imports",
    "href": "10-System.Object[].html#curated-imports",
    "title": "Chapter 9: Imports & Exports",
    "section": "Curated Imports",
    "text": "Curated Imports\nAnother best practice is to curate before commit. Instead of blindly importing all rows, first log what would be created or updated. Write the proposed changes to a CSV, review them, then re-run the script with DRY_RUN = false.\nThis two-phase approach mirrors the “Curate-then-Write” pattern described in Chapter 7. It prevents surprises and builds trust in automation.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#safety-in-exports",
    "href": "10-System.Object[].html#safety-in-exports",
    "title": "Chapter 9: Imports & Exports",
    "section": "Safety in Exports",
    "text": "Safety in Exports\nExports may feel safer than imports — after all, they don’t change EA. But they come with their own risks. An incomplete export can give stakeholders a misleading picture. An unfiltered export may expose sensitive data.\nSafe export practices include:\n\nLogging the scope of what was exported.\nIncluding metadata fields like GUIDs, stereotypes, and tags.\nConfirming encoding (e.g., use external Python for UTF-8).",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#integrating-importsexports-into-workflows",
    "href": "10-System.Object[].html#integrating-importsexports-into-workflows",
    "title": "Chapter 9: Imports & Exports",
    "section": "Integrating Imports/Exports into Workflows",
    "text": "Integrating Imports/Exports into Workflows\nImports and exports are rarely ends in themselves. They usually form part of a wider workflow. For example:\n\nExport application inventory from EA to CSV.\nSend CSV to data owners for updates.\nImport CSV back into EA with changes.\n\nOr:\n\nImport requirements from Jira.\nTrace them to capabilities and applications in EA.\nExport traceability report to Confluence.\n\nThinking of imports/exports as workflow steps encourages you to script them with logging, curation, and repeatability.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#what-youll-use",
    "href": "10-System.Object[].html#what-youll-use",
    "title": "Chapter 9: Imports & Exports",
    "section": "What you’ll use",
    "text": "What you’ll use\nInside EA: JScript (ES3), FileSystemObject, Excel.Application (ActiveX), EA API.\nOutside EA: Python (pywin32) for JSON parsing and advanced integrations.\nWe’ll assume you have the Shared Helpers from Chapter 6 (_Common.Helpers) available: ensureOutputTab, browseForFolder, CsvWriter, string helpers, and nowMs().\n\nCSV Round-Trip (in-EA)\nCSV is the simplest review format for non-technical stakeholders. The safest pattern is two-phase: export a proposal → humans curate in Excel → apply only rows marked “YES”.\n\n\nExport elements (recursive) to CSV\n\n\nExample 9.1 - - ExportCSV_PackageRecursive.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 9.1 - ExportCSV_PackageRecursive.js – JScript (ES3)\n// Purpose: Export elements of the selected package (and subpackages) to CSV\n// Usage: Select a package in the Project Browser → run script\n// Output: directory-only chooser; filename auto-derived\n// Assumptions:\n//   - ES3 only; EA collections use Count/GetAt(i)\n//   - Includes key fields for round-trip (IDs, GUIDs, parent package)\n// Dependencies: _Common.Helpers\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"ExportCSV\";\n    ensureOutputTab(TAB);\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package to export.\", promptOK); return; }\n\n    var outDir = browseForFolder(\"Select output folder (CSV)\");\n    if (!outDir) { log(TAB, \"Cancelled.\"); return; }\n\n    var stamp = (new Date()).getTime();\n    var path  = outDir + \"\\\\export_elements_\" + safeName(pkg.Name) + \"_\" + stamp + \".csv\";\n    var csv   = new CsvWriter(path);\n    csv.writeHeader(\"Apply,ElementID,GUID,PackageID,PackageName,Name,Type,Stereotype,Status,Notes\");\n\n    var count = walkPackage(pkg, function(el, p) {\n        csv.writeRow([\n            \"NO\",                    // Apply = NO by default (curate later)\n            el.ElementID,\n            el.ElementGUID,\n            p.PackageID,\n            p.Name,\n            el.Name,\n            el.Type,\n            String(el.Stereotype||\"\"),\n            String(el.Status||\"\"),\n            sanitize(el.Notes)\n        ]);\n    });\n\n    csv.close();\n    log(TAB, \"Exported \" + count + \" element(s) → \" + path);\n}\n\nfunction walkPackage(pkg, onElement) {\n    var n = 0, i;\n    var els = pkg.Elements;\n    for (i=0; i&lt;els.Count; i++) {\n        onElement(els.GetAt(i), pkg); n++;\n    }\n    var kids = pkg.Packages;\n    for (i=0; i&lt;kids.Count; i++) {\n        n += walkPackage(kids.GetAt(i), onElement);\n    }\n    return n;\n}\n\nfunction sanitize(s) {\n    // Compress newlines for CSV readability (optional)\n    s = String(s||\"\");\n    s = s.replace(/\\r\\n/g, \" \").replace(/\\n/g, \" \").replace(/\\r/g, \" \");\n    return s;\n}\nfunction safeName(s) { return String(s||\"\").replace(/[^A-Za-z0-9_]+/g, \"_\"); }\n\nmain();\n\n\n\nApply curated CSV to update elements\nCSV edited by humans is brittle; we keep parsing simple and only support a few controlled changes. We’ll update Name, Stereotype, Status, and optionally one tagged value (e.g., Owner). Only rows with Apply=YES will execute.\n\n\nExample 9.2 - ImportCSV_UpdateElements.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 9.2 - ImportCSV_UpdateElements.js – JScript (ES3)\n// Purpose: Apply curated updates to elements from a CSV (round-trip)\n// Usage: Place curated CSV in a folder → run script → pick folder\n// Safety: Only Apply=YES rows are executed; ElementID/GUID matching\n// Dependencies: _Common.Helpers\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"ImportCSV\";\n    ensureOutputTab(TAB);\n\n    var dir = browseForFolder(\"Select folder containing curated CSV (export_elements_*.csv)\");\n    if (!dir) { log(TAB, \"Cancelled.\"); return; }\n\n    var file = newestCsv(dir, \"export_elements_\");\n    if (!file) { log(TAB, \"No matching CSV found.\"); return; }\n    log(TAB, \"Applying from: \" + file.Path);\n\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var ts  = fso.OpenTextFile(file.Path, 1); // ForReading\n    if (!ts.AtEndOfStream) ts.ReadLine();     // skip header\n\n    var applied=0, considered=0;\n    while (!ts.AtEndOfStream) {\n        var line  = ts.ReadLine();\n        if (trim(line) === \"\") continue;\n        var cells = splitCsvLine(line);       // naive split (works if reviewers avoided stray commas)\n\n        // Expected header: Apply,ElementID,GUID,PackageID,PackageName,Name,Type,Stereotype,Status,Notes\n        var apply    = trim(getCell(cells,0));\n        var elementID= parseInt(getCell(cells,1),10);\n        var guid     = trim(getCell(cells,2));\n        var newName  = trim(getCell(cells,5));\n        var newStereo= trim(getCell(cells,7));\n        var newStatus= trim(getCell(cells,8));\n\n        considered++;\n\n        if (equalsIgnoreCase(apply,\"YES\")) {\n            var el = null;\n            // Prefer GUID match if provided\n            if (guid !== \"\") {\n                el = Repository.GetElementByGuid ? Repository.GetElementByGuid(guid) : Repository.GetElementByGUID(guid);\n            }\n            if (!el && elementID &gt; 0) {\n                el = Repository.GetElementByID(elementID);\n            }\n            if (!el) { log(TAB, \"Row skipped: element not found (GUID=\"+guid+\" ID=\"+elementID+\")\"); continue; }\n\n            var dirty = false;\n            if (newName !== \"\" && el.Name != newName) { el.Name = newName; dirty = true; }\n            if (newStereo !== \"\" && String(el.Stereotype||\"\") != newStereo) { el.Stereotype = newStereo; dirty = true; }\n            if (newStatus !== \"\" && String(el.Status||\"\") != newStatus) { el.Status = newStatus; dirty = true; }\n\n            if (dirty) { el.Update(); applied++; }\n        }\n    }\n    ts.Close();\n\n    if (applied&gt;0) Repository.RefreshModelView(0);\n    log(TAB, \"Applied \" + applied + \" curated change(s) out of \" + considered + \" row(s).\");\n}\n\n// Return newest CSV whose name starts with prefix\nfunction newestCsv(dir, prefix) {\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var folder = fso.GetFolder(dir);\n    var en = new Enumerator(folder.Files);\n    var newest=null, t=0;\n    for (; !en.atEnd(); en.moveNext()) {\n        var f = en.item();\n        if (endsWith(f.Name.toLowerCase(), \".csv\") && startsWith(f.Name, prefix)) {\n            var m = f.DateLastModified.getTime();\n            if (m &gt; t) { newest=f; t=m; }\n        }\n    }\n    return newest;\n}\n\n// Very simple CSV splitting (assumes reviewers didn’t add embedded commas/quotes)\nfunction splitCsvLine(line) { return line.split(\",\"); }\nfunction getCell(arr, idx) { return idx &lt; arr.length ? arr[idx] : \"\"; }\nfunction endsWith(s, suffix){ s=String(s||\"\"); var i=s.lastIndexOf(suffix); return i&gt;=0 && (i+suffix.length===s.length); }\n\nmain();\n\nTip: If you must support commas/quotes in curated text, switch to the external Python importer in §8.4; it uses the csv module to parse safely.\n\n\nExcel via COM (in-EA)\nSometimes you must deliver a real .xlsx instead of a CSV. You can drive Excel via ActiveX.\nExport to Excel (.xlsx)\n\n\nExample 9.3 - ExportExcel_PackageSimple.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 9.3 - ExportExcel_PackageSimple.js – JScript (ES3)\n// Purpose: Write selected package elements to an .xlsx via Excel COM\n// Usage: Select a package → run script → pick output folder\n// Requirements: Microsoft Excel installed (same bitness as EA)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"ExportExcel\";\n    ensureOutputTab(TAB);\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var outDir = browseForFolder(\"Select output folder (.xlsx)\");\n    if (!outDir) { log(TAB, \"Cancelled.\"); return; }\n\n    var stamp = (new Date()).getTime();\n    var filePath = outDir + \"\\\\export_\" + safeName(pkg.Name) + \"_\" + stamp + \".xlsx\";\n\n    var xl = new ActiveXObject(\"Excel.Application\");\n    xl.Visible = false;\n    var wb = xl.Workbooks.Add();\n    var ws = wb.ActiveSheet;\n    ws.Name = \"Elements\";\n\n    // Header\n    ws.Cells(1,1).Value = \"ElementID\";\n    ws.Cells(1,2).Value = \"GUID\";\n    ws.Cells(1,3).Value = \"Name\";\n    ws.Cells(1,4).Value = \"Type\";\n    ws.Cells(1,5).Value = \"Stereotype\";\n\n    var r = 2;\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++, r++) {\n        var e = els.GetAt(i);\n        ws.Cells(r,1).Value = e.ElementID;\n        ws.Cells(r,2).Value = e.ElementGUID;\n        ws.Cells(r,3).Value = e.Name;\n        ws.Cells(r,4).Value = e.Type;\n        ws.Cells(r,5).Value = String(e.Stereotype||\"\");\n    }\n\n    // Autosize\n    ws.Columns.AutoFit();\n\n    // Save and clean up\n    wb.SaveAs(filePath);\n    wb.Close(false);\n    xl.Quit();\n\n    wb = null; ws = null; xl = null; // release COM references\n    log(TAB, \"Excel written → \" + filePath);\n}\nfunction safeName(s){ return String(s||\"\").replace(/[^A-Za-z0-9_]+/g,\"_\"); }\n\nmain();\n\nNote: Reading from Excel in JScript is also possible (open workbook, loop rows until blank). For reliability and parsing complexity, prefer CSV for imports, or use the Python importer below.\n\n\nJSON Pipelines\nWhy JSON? It’s friendly to automation and works nicely in Git. EA’s internal JScript has no JSON parser, so we recommend: export JSON inside EA, import JSON externally (Python).\nExport JSON (simple structure) inside EA\n\n\nExample 9.4 - ExportJSON_Package.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 9.4 - ExportJSON_Package.js – JScript (ES3)\n// Purpose: Export selected package elements to a JSON file\n// Usage: Select a package → run script → pick output folder\n// Notes: JScript has no JSON.stringify, so we build JSON manually.\n//        Keep values escaped and simple.\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"ExportJSON\";\n    ensureOutputTab(TAB);\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var outDir = browseForFolder(\"Select output folder (JSON)\");\n    if (!outDir) { log(TAB, \"Cancelled.\"); return; }\n\n    var stamp = (new Date()).getTime();\n    var path  = outDir + \"\\\\export_\" + safeName(pkg.Name) + \"_\" + stamp + \".json\";\n\n    var fso  = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var file = fso.OpenTextFile(path, 2, true); // 2=ForWriting\n\n    file.WriteLine(\"[\");\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var line = \"  {\" +\n            \"\\\"elementId\\\":\" + e.ElementID + \",\" +\n            \"\\\"guid\\\":\\\"\" + jsonEscape(e.ElementGUID) + \"\\\",\" +\n            \"\\\"name\\\":\\\"\" + jsonEscape(e.Name) + \"\\\",\" +\n            \"\\\"type\\\":\\\"\" + jsonEscape(e.Type) + \"\\\",\" +\n            \"\\\"stereotype\\\":\\\"\" + jsonEscape(String(e.Stereotype||\"\")) + \"\\\"\" +\n        \"}\";\n        if (i &lt; els.Count-1) line += \",\";\n        file.WriteLine(line);\n    }\n    file.WriteLine(\"]\");\n\n    file.Close();\n    log(TAB, \"JSON written → \" + path);\n}\nfunction jsonEscape(s){ s=String(s||\"\"); return s.replace(/\\\\/g,\"\\\\\\\\\").replace(/\"/g,'\\\\\"'); }\nfunction safeName(s){ return String(s||\"\").replace(/[^A-Za-z0-9_]+/g,\"_\"); }\n\nmain();\n\n\n\nImport JSON externally (Python)\nThis importer:\n\nTries GUID first (GetElementByGuid/GetElementByGUID).\nFalls back to name + type within a package (to avoid dupes).\nCreates new elements if missing (note: EA does not let you set GUIDs via API; new elements get new GUIDs—store a mapping if you need cross-walks).\n\n\n\nExample 9.5 - import_json_into_ea.py – Python 3 (pywin32)\n\n# -------------------------------------------------------\n# Example 9.5 - import_json_into_ea.py – Python 3 (pywin32)\n# Purpose: Import elements from JSON into a target package\n# Usage: python import_json_into_ea.py \"C:\\...\\export_Package_123.json\" 1234\n#   where 1234 is the target PackageID in EA\n# Safety:\n#   - Avoid duplicates by GUID first, else by (name,type,package)\n#   - Log new GUIDs so you can maintain a cross-walk\n# -------------------------------------------------------\nimport sys, json, win32com.client\n\ndef find_by_name_type(pkg, name, etype):\n    els = pkg.Elements\n    for i in range(els.Count):\n        e = els.GetAt(i)\n        if e.Name == name and e.Type == etype:\n            return e\n    return None\n\ndef main():\n    if len(sys.argv) &lt; 3:\n        print(\"Usage: import_json_into_ea.py &lt;json_path&gt; &lt;target_package_id&gt;\")\n        return\n\n    json_path = sys.argv[1]\n    target_pkg_id = int(sys.argv[2])\n\n    ea = win32com.client.Dispatch(\"EA.App\")\n    repo = ea.Repository\n    pkg = repo.GetPackageByID(target_pkg_id)\n    if not pkg:\n        print(\"Target package not found:\", target_pkg_id); return\n\n    data = json.load(open(json_path, \"r\"))\n\n    created, updated = 0, 0\n    for item in data:\n        guid = item.get(\"guid\",\"\")\n        name = item.get(\"name\",\"\")\n        etype= item.get(\"type\",\"Class\")\n        stereo=item.get(\"stereotype\",\"\")\n\n        el = None\n        if guid:\n            try:\n                el = repo.GetElementByGuid(guid)  # newer EA\n            except:\n                try:\n                    el = repo.GetElementByGUID(guid)  # older EA\n                except:\n                    el = None\n\n        if not el:\n            el = find_by_name_type(pkg, name, etype)\n\n        if not el:\n            el = pkg.Elements.AddNew(name, etype)\n            el.Stereotype = stereo\n            el.Update()\n            created += 1\n            # NOTE: el.ElementGUID is NEW and cannot be set via API.\n            print(f\"Created: {name} ({etype}) NEW_GUID={el.ElementGUID}\")\n        else:\n            dirty = False\n            if stereo and el.Stereotype != stereo:\n                el.Stereotype = stereo; dirty = True\n            if dirty:\n                el.Update(); updated += 1\n\n    if created or updated:\n        repo.RefreshModelView(pkg.PackageID)\n\n    print(f\"Done. Created={created}, Updated={updated}\")\n\nif __name__ == \"__main__\":\n    main()\n\nGUID reality check: EA’s API exposes ElementGUID but does not let you set it for new elements. If you must preserve GUIDs from an external master, consider XMI import or EA’s native importers. Otherwise, store a cross-walk CSV of {external_id → EA GUID} after creation.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#managing-guids-avoiding-duplicates",
    "href": "10-System.Object[].html#managing-guids-avoiding-duplicates",
    "title": "Chapter 9: Imports & Exports",
    "section": "Managing GUIDs & Avoiding Duplicates",
    "text": "Managing GUIDs & Avoiding Duplicates\nBest-practice order of matching:\n\nGUID (strongest identity) → GetElementByGUID/GetElementByGuid.\nStable external key (your own code) if you maintain one as a tagged value, e.g., ExternalID.\nName + Type + Package (weaker; beware rename collisions).\n\nFor new items:\n\nYou cannot set EA GUIDs via API; EA assigns them.\nImmediately log {externalKey → new EA GUID} to a CSV so future updates can target the same element.\n\nAvoiding duplicates:\n\nBefore creating, search for existing by GUID or external key.\nIf you must use name/type, scope the search to the target package (or run an SQLQuery to check repository-wide).\nBuild imports as two-phase: curate first, then apply, so humans can resolve ambiguous matches.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#scaling-up-performance",
    "href": "10-System.Object[].html#scaling-up-performance",
    "title": "Chapter 9: Imports & Exports",
    "section": "Scaling Up (Performance)",
    "text": "Scaling Up (Performance)\n\nUse SQL for finding, API for writing (Pattern 5 in Chapter 6).\nBatch large updates (e.g., 250 elements) and refresh the UI at the end.\nKeep logs: write a CSV of every change (old → new).\n\nExample: fast existence check before creating\n\n\nExample 9.6 - ExistsByNameType_SQL.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 9.6 - ExistsByNameType_SQL.js – JScript (ES3)\n// Purpose: Repository-wide check if (Name,Type) exists; returns first Object_ID\n// Notes: SQLQuery returns XML; we do a tiny string parse\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction existsByNameType(name, type) {\n    var sql = \"SELECT TOP 1 Object_ID FROM t_object WHERE Name='\" + esc(name) + \"' AND Object_Type='\" + esc(type) + \"'\";\n    var xml = Repository.SQLQuery(sql);\n    var id = between(xml, \"&lt;Object_ID&gt;\", \"&lt;/Object_ID&gt;\");\n    return id ? parseInt(id,10) : 0;\n}\n\nfunction esc(s){ \n  return String(s||\"\").replace(/'/g,\"''\"); \n}\n\nfunction between(h, a, b){ \n  var i=h.indexOf(a); \n  if(i&lt;0) return \"\"; \n  var j=h.indexOf(b,i+a.length); \n  return j&lt;0?\"\":h.substring(i+a.length,j); \n}",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#safety-checklist",
    "href": "10-System.Object[].html#safety-checklist",
    "title": "Chapter 9: Imports & Exports",
    "section": "Safety Checklist",
    "text": "Safety Checklist\n\nDry-run first (or export-curate-apply).\nBack up repositories (or work on a copy).\nLog everything (CSV with old/new values).\nUpdate() every modified object; RefreshModelView() to show changes.\nPrefer CSV/JSON for input, Excel only when required.\nFor rich parsing, do it externally (Python) and keep in-EA scripts small and safe.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "10-System.Object[].html#what-to-use-when",
    "href": "10-System.Object[].html#what-to-use-when",
    "title": "Chapter 9: Imports & Exports",
    "section": "What to use when",
    "text": "What to use when\n\nQuick exports for review → CSV export (8.1.1).\nCurated updates → CSV apply (8.1.2) or Python CSV/JSON importer (8.3.2).\nStakeholder-friendly spreadsheet → Excel export (8.2.1).\nDev pipelines / Git → JSON export (8.3.1) + Python importer (8.3.2).\nStrong identity → prefer GUIDs or your own ExternalID tagged value.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Chapter 9: Imports & Exports</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html",
    "href": "11-System.Object[].html",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "",
    "text": "What Are MDGs?\nBy now, we’ve looked at the essentials of EA scripting, design patterns, and the mechanics of importing and exporting. But Enterprise Architect is more than just a generic UML tool. Its true power lies in MDG Technologies (Model Driven Generation). MDGs extend EA with domain-specific languages, toolboxes, and stereotypes that tailor the tool to specific contexts: ArchiMate, BPMN, SysML, TOGAF, and countless custom frameworks.\nFor script authors, MDGs present both opportunities and challenges. On one hand, they give structure — a controlled set of stereotypes, tagged values, and toolboxes. On the other hand, they introduce complexity — multiple profiles, extended stereotypes, and hidden differences between what the GUI shows and what the API actually stores.\nThis chapter explores how to make your scripts MDG-aware. It explains what MDGs are, how stereotypes and tagged values are defined, why you must use StereotypeEx instead of Stereotype, and how to validate models against MDG definitions. Without MDG awareness, your scripts may appear to work but silently misalign with the modelling framework your organisation depends on. With MDG awareness, your scripts become governance tools that reinforce standards and prevent drift.\nMDG Technologies are EA’s mechanism for packaging modelling extensions. They define:\nAn MDG is essentially a bundle that turns EA from a generic modelling tool into a domain-specific environment.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#what-are-mdgs",
    "href": "11-System.Object[].html#what-are-mdgs",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "",
    "text": "Stereotypes: specialisations of UML element types (e.g., ArchiMate ApplicationComponent).\nToolboxes: palettes of elements and connectors available to modellers.\nTagged Values: metadata fields automatically attached to stereotyped elements.\nProfiles and MetaModels: rules about what elements and connectors can be created.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#why-mdgs-matter-for-scripting",
    "href": "11-System.Object[].html#why-mdgs-matter-for-scripting",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "Why MDGs Matter for Scripting",
    "text": "Why MDGs Matter for Scripting\nWhen you script EA, you are not usually working with plain UML classes or components. You are working with stereotyped elements defined by MDGs. For example, if you are automating ArchiMate models, your script needs to distinguish ApplicationComponents from BusinessActors. If you are automating BPMN, you need to treat Tasks, Gateways, and Events differently.\nScripts that ignore MDGs risk breaking models. A script might rename or move elements without preserving stereotypes. Or it might overwrite a stereotype by writing to Element.Stereotype instead of Element.StereotypeEx. These mistakes create elements that look right in the Project Browser but misbehave in diagrams or reports.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#important-tips",
    "href": "11-System.Object[].html#important-tips",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "Important Tips",
    "text": "Important Tips\n\nThe Stereotype vs. StereotypeEx Trap\nOne of the most notorious pitfalls in EA scripting is the difference between Stereotype and StereotypeEx.\n\nStereotype returns only the primary stereotype string, stripped of profile information.\nStereotypeEx returns the fully qualified stereotype, including the profile (profile::stereotype).\n\nIf you rely on Stereotype, your script may confuse two stereotypes with the same name from different profiles. Worse, if you set Stereotype, you may erase MDG metadata.\nThe safe rule is: always use StereotypeEx when working with MDG stereotypes.\n\n\nTagged Value Definitions\nMDGs often define tagged values that attach automatically to elements with a given stereotype. For example, an ArchiMate ApplicationComponent may come with tagged values like “Layer” or “Technology.”\nScripts must handle these tagged values carefully. You should:\n\nCheck if the tag exists before adding a new one.\nUse the correct tag names from the MDG definition.\nAvoid overwriting tags with unexpected values.\n\nProper handling ensures your automation works with, not against, the MDG.\n\n\nToolboxes and Element Creation\nWhen creating elements via script, it’s important to align with MDG toolboxes. If your organisation uses a custom MDG that defines “Business Capability” as MyProfile::Capability, then your script must create elements with that stereotype. Creating a plain UML Class and renaming it “Capability” will cause confusion.\nThe safe pattern is to:\n\nIdentify the correct stereotype from the MDG.\nUse Elements.AddNew(name, baseType) followed by StereotypeEx = “profile::stereo”.\nCall Update() and RefreshModelView().\n\n\n\nValidating MDG Usage\nMDG-aware scripting isn’t only about creating elements correctly. It’s also about validating existing models. Common checks include:\n\nElements of stereotype X must have certain tagged values populated.\nConnectors of type Y may only connect specific element types.\nPackages must only contain elements from an approved toolbox.\n\nBy writing MDG-aware validation scripts, you can enforce compliance and prevent “model drift” where users create incorrect structures.\n\n\nWhen MDGs Change\nAnother challenge is that MDGs evolve. Stereotypes may be renamed, tagged values may be added, or toolboxes reorganised. Scripts must be robust to such changes. That means:\n\nAvoid hardcoding stereotypes wherever possible — use configuration files or central mappings.\nLog when unknown stereotypes are encountered.\nKeep scripts version-controlled and updated alongside MDG changes.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#mdgs-in-external-automation",
    "href": "11-System.Object[].html#mdgs-in-external-automation",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "MDGs in External Automation",
    "text": "MDGs in External Automation\nEverything we’ve said so far applies inside EA’s scripting engine, but it also applies in external automation. If you are pulling EA content into Python or C#, you still need to handle stereotypes correctly. That means reading StereotypeEx, exporting tagged values, and mapping them to your enterprise data models.\nIn fact, external automation often makes MDG handling easier because you can use richer libraries (YAML, JSON) to store stereotype/tag mappings.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#safety-and-governance",
    "href": "11-System.Object[].html#safety-and-governance",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "Safety and Governance",
    "text": "Safety and Governance\nMDG-aware scripting is not just a technical detail. It is a matter of governance. In large organisations, MDGs embody agreed standards: what modelling constructs are allowed, how they are tagged, and how they interrelate. Scripts that respect MDGs reinforce governance. Scripts that ignore them undermine it.\nBy making scripts MDG-aware, you align automation with enterprise architecture frameworks, regulatory requirements, and industry standards.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#examples",
    "href": "11-System.Object[].html#examples",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "Examples",
    "text": "Examples\n\nStereotypes 101 (MDG-aware)\n\nElement.Stereotype: the “plain” stereotype string (often just the short name).\nElement.StereotypeEx: the fully-qualified list (may contain profile::stereotype, comma-separated).\nMultiple stereotypes: use StereotypeEx.\nBest practice: when working with MDGs, set and test against StereotypeEx with the profile::stereo form.\n\n\n\nExample 10.1 - MDG_ApplyStereotype.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 10.1 - MDG_ApplyStereotype.js – JScript (ES3)\n// Purpose: Ensure elements in the selected package have a specific MDG stereotype\n// Notes:\n//  - Uses profile::stereotype form via StereotypeEx\n//  - Safe by default with DRY_RUN flag\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n\nfunction main() {\n    var TAB = \"MDG_ApplyStereo\";\n    ensureOutputTab(TAB);\n\n    // ---- Config ----\n    var DRY_RUN = true;                        // switch to false to commit\n    var PROFILE = \"MyProfile\";                 // MDG profile name\n    var STEREO  = \"BusinessCapability\";        // Stereotype short name\n    var FQ      = PROFILE + \"::\" + STEREO;     // fully-qualified\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a target package.\", promptOK); return; }\n\n    var els = pkg.Elements, changed = 0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n\n        // Skip non-matching base types if you want (e.g., only Classes)\n        // if (e.Type != \"Class\") continue;\n\n        if (!hasFQStereotype(e, FQ)) {\n            log(TAB, \"Apply stereotype to '\" + e.Name + \"': \" + FQ);\n            if (!DRY_RUN) {\n                // Add (or replace) StereotypeEx preserving any existing ones\n                e.StereotypeEx = addFQStereotype(e.StereotypeEx, FQ);\n                e.Update();\n            }\n            changed++;\n        }\n    }\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    log(TAB, \"Updated \" + changed + \" element(s). Dry-run=\" + DRY_RUN);\n}\n\nfunction hasFQStereotype(e, fq) {\n    var list = String(e.StereotypeEx||\"\");\n    // simple token check; EA uses comma-separated list\n    var items = list.split(\",\");\n    for (var i=0; i&lt;items.length; i++) {\n        if (equalsIgnoreCase(trim(items[i]), fq)) return true;\n    }\n    return false;\n}\nfunction addFQStereotype(current, fq) {\n    current = String(current||\"\").trim();\n    if (current === \"\") return fq;\n    // Avoid dupes\n    var items = current.split(\",\"), i;\n    for (i=0; i&lt;items.length; i++) {\n        if (equalsIgnoreCase(trim(items[i]), fq)) return current;\n    }\n    return current + \",\" + fq;\n}\n\nmain();\n\n\n\nTagged Value Definitions (MDG-driven)\nMDGs typically define tagged value types (lists, refs, memo) and required tags per stereotype. From scripts you usually don’t read MDG metadata directly; instead you encode your project’s rules in a small configuration map and then enforce those rules.\n\n\nExample 10.2 - MDG_Rulebook.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 10.2 - MDG_Rulebook.js – JScript (ES3)\n// Purpose: Central config for your MDG validation/repair scripts\n// Notes: Express stereotypes fully-qualified as PROFILE::STEREO\n// -------------------------------------------------------\nvar MDG_RULES = {\n    \"MyProfile::BusinessCapability\": {\n        baseType: \"Class\",                         // optional; skip other base types\n        requiredTags: [\n            { name: \"Owner\",       defaultValue: \"ArchitectureTeam\" },\n            { name: \"Lifecycle\",   defaultValue: \"Active\" },\n            { name: \"ExternalID\",  defaultValue: \"\" }     // leave blank; must be filled by users/imports\n        ],\n        namePrefix: \"BC_\"                           // optional naming convention\n    },\n    \"MyProfile::ApplicationService\": {\n        baseType: \"Class\",\n        requiredTags: [\n            { name: \"Owner\",      defaultValue: \"AppTeam\" },\n            { name: \"Criticality\", defaultValue: \"Medium\" }\n        ],\n        namePrefix: \"AS_\"\n    }\n};\n\nKeep this in one place (e.g., _Common.MDG_Rulebook) and !INC it in validator and repair scripts.\n\n\nMDG Validator (report-only)\nThis script reports deviations: wrong/missing stereotype, missing tags, blank required values, naming violations. It never writes; use it in governance jobs and daily hygiene.\n\n\nExample 10.3 - MDG_Lint.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 10.3 - MDG_Lint.js – JScript (ES3)\n// Purpose: Report MDG violations for elements in selected package (read-only)\n// Output: Output tab + CSV (directory-only chooser)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n!INC _Common.MDG_Rulebook\n\nfunction main() {\n    var TAB = \"MDG_Lint\";\n    ensureOutputTab(TAB);\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package to lint.\", promptOK); return; }\n\n    var outDir = browseForFolder(\"Select output folder for MDG lint report\");\n    var csv = null;\n    if (outDir) {\n        var stamp = (new Date()).getTime();\n        csv = new CsvWriter(outDir + \"\\\\mdg_lint_\" + stamp + \".csv\");\n        csv.writeHeader(\"ElementID,GUID,Name,Type,AppliedStereotypes,Issue,Details,ExpectedProfileStereo\");\n    }\n\n    var els = pkg.Elements, issues=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var applied = String(e.StereotypeEx||\"\");\n        var expectedFQ = pickRuleKey(e, applied);   // finds the rule, if any\n\n        if (!expectedFQ) continue; // element not in scope of our rulebook\n\n        var rule = MDG_RULES[expectedFQ];\n\n        // 1) Base type check (optional)\n        if (rule.baseType && rule.baseType != e.Type) {\n            issues += emit(csv, e, applied, \"BaseTypeMismatch\", \"Expected base type \"+rule.baseType, expectedFQ);\n            continue; // don’t check tags if base type is wrong\n        }\n\n        // 2) Stereotype check\n        if (!hasFQStereo(applied, expectedFQ)) {\n            issues += emit(csv, e, applied, \"MissingStereotype\", \"Apply \"+expectedFQ, expectedFQ);\n        }\n\n        // 3) Required tags\n        for (var t=0; t&lt;rule.requiredTags.length; t++) {\n            var tn = rule.requiredTags[t].name;\n            var tv = readTag(e, tn);\n            if (trim(tv) === \"\") {\n                issues += emit(csv, e, applied, \"MissingTag\", \"Tag '\"+tn+\"' is required\", expectedFQ);\n            }\n        }\n\n        // 4) Naming convention (optional)\n        if (rule.namePrefix && !startsWith(e.Name, rule.namePrefix)) {\n            issues += emit(csv, e, applied, \"NamePrefix\", \"Should start with '\"+rule.namePrefix+\"'\", expectedFQ);\n        }\n    }\n\n    if (csv) csv.close();\n    log(TAB, \"MDG lint complete. Issues: \" + issues);\n}\n\nfunction pickRuleKey(e, appliedList) {\n    // Strategy:\n    //  - If any rule key is present in StereotypeEx, prefer it.\n    //  - Else if base type matches exactly one rule, use that rule for “expected” check.\n    var keys = keysOf(MDG_RULES);\n    // prefer explicit match\n    for (var i=0; i&lt;keys.length; i++) {\n        if (hasFQStereo(appliedList, keys[i])) return keys[i];\n    }\n    // fallback: base type inference if unambiguous\n    var chosen=null;\n    for (i=0; i&lt;keys.length; i++) {\n        var r = MDG_RULES[keys[i]];\n        if (r.baseType && r.baseType == e.Type) {\n            if (chosen && chosen != keys[i]) return null; // ambiguous\n            chosen = keys[i];\n        }\n    }\n    return chosen;\n}\n\nfunction hasFQStereo(applied, fq) {\n    var items = String(applied||\"\").split(\",\");\n    for (var i=0; i&lt;items.length; i++) {\n        if (equalsIgnoreCase(trim(items[i]), fq)) return true;\n    }\n    return false;\n}\nfunction readTag(e, name) {\n    var tvs = e.TaggedValues;\n    for (var i=0; i&lt;tvs.Count; i++) {\n        var tv = tvs.GetAt(i);\n        if (equalsIgnoreCase(tv.Name, name)) return String(tv.Value||\"\");\n    }\n    return \"\";\n}\nfunction emit(csv, e, applied, issue, details, expected) {\n    var line = e.ElementID + \" \" + e.Name + \" – \" + issue + \": \" + details;\n    log(\"MDG_Lint\", line);\n    if (csv) csv.writeRow([e.ElementID, e.ElementGUID, e.Name, e.Type, applied, issue, details, expected||\"\"]);\n    return 1;\n}\nfunction keysOf(o){ var r=[],k; for(k in o){ if(o.hasOwnProperty(k)) r.push(k);} return r; }\n\nmain();\n\n\n\nMDG Repair (guided and safe)\nThis companion script fixes the issues reported by the linter. It uses a dry-run flag and writes a CSV log of every attempted change.\n\n\nExample 10.4 - MDG_Repair.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 10.4 - MDG_Repair.js – JScript (ES3)\n// Purpose: Apply MDG fixes (stereotype, required tags, naming prefix)\n// Safety: DRY_RUN=true by default; logs every change\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n!INC _Common.MDG_Rulebook\n\nfunction main() {\n    var TAB = \"MDG_Repair\";\n    ensureOutputTab(TAB);\n\n    // ---- Config ----\n    var DRY_RUN = true;\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var outDir = browseForFolder(\"Select output folder for MDG repair log\");\n    var csv = null;\n    if (outDir) {\n        var stamp = (new Date()).getTime();\n        csv = new CsvWriter(outDir + \"\\\\mdg_repair_\" + stamp + \".csv\");\n        csv.writeHeader(\"Action,ElementID,GUID,Name,Details\");\n    }\n\n    var els = pkg.Elements, changed=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var expectedFQ = pickRuleKey(e, String(e.StereotypeEx||\"\"));\n        if (!expectedFQ) continue;\n\n        var rule = MDG_RULES[expectedFQ];\n\n        // 1) Enforce stereotype (fully-qualified)\n        if (!hasFQStereo(String(e.StereotypeEx||\"\"), expectedFQ)) {\n            log(TAB, \"Apply stereotype: \" + expectedFQ + \" on '\" + e.Name + \"'\");\n            if (csv) csv.writeRow([\"ApplyStereo\", e.ElementID, e.ElementGUID, e.Name, expectedFQ]);\n            if (!DRY_RUN) { e.StereotypeEx = addFQStereo(e.StereotypeEx, expectedFQ); e.Update(); changed++; }\n        }\n\n        // 2) Ensure required tags (create if missing, fill default if blank)\n        for (var t=0; t&lt;rule.requiredTags.length; t++) {\n            var tn = rule.requiredTags[t].name;\n            var dv = String(rule.requiredTags[t].defaultValue||\"\");\n            var cur = readTag(e, tn);\n            if (trim(cur) === \"\" && dv !== \"\") {\n                log(TAB, \"Set tag '\" + tn + \"'='\" + dv + \"' on '\" + e.Name + \"'\");\n                if (csv) csv.writeRow([\"SetTag\", e.ElementID, e.ElementGUID, e.Name, tn+\"=\"+dv]);\n                if (!DRY_RUN) { writeTag(e, tn, dv); changed++; }\n            } else if (cur === \"\") {\n                // missing and no default → warn only\n                if (csv) csv.writeRow([\"MissingTag\", e.ElementID, e.ElementGUID, e.Name, tn+\" (no default)\"]);\n            }\n        }\n\n        // 3) Naming prefix (optional)\n        if (rule.namePrefix && !startsWith(e.Name, rule.namePrefix)) {\n            var newName = rule.namePrefix + e.Name;\n            log(TAB, \"Rename '\" + e.Name + \"' → '\" + newName + \"'\");\n            if (csv) csv.writeRow([\"Rename\", e.ElementID, e.ElementGUID, e.Name, \"→ \"+newName]);\n            if (!DRY_RUN) { e.Name = newName; e.Update(); changed++; }\n        }\n    }\n\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    log(TAB, \"Repair complete. Changes=\" + changed + \", Dry-run=\" + DRY_RUN);\n}\n\n// Helpers (subset specialised for this script)\nfunction pickRuleKey(e, applied){ var keys=keysOf(MDG_RULES); var i;\n    for(i=0;i&lt;keys.length;i++) if(hasFQStereo(applied, keys[i])) return keys[i];\n    // optional baseType inference\n    var chosen=null; for(i=0;i&lt;keys.length;i++){ var r=MDG_RULES[keys[i]]; if(r.baseType && r.baseType==e.Type){ if(chosen && chosen!=keys[i]) return null; chosen=keys[i]; } }\n    return chosen;\n}\nfunction hasFQStereo(applied, fq){ var items=String(applied||\"\").split(\",\"); for(var i=0;i&lt;items.length;i++){ if(equalsIgnoreCase(trim(items[i]),fq)) return true; } return false;}\nfunction addFQStereo(current, fq){ current=String(current||\"\").trim(); if(current===\"\") return fq; var items=current.split(\",\"),i; for(i=0;i&lt;items.length;i++){ if(equalsIgnoreCase(trim(items[i]),fq)) return current; } return current + \",\" + fq;}\nfunction readTag(e, name){ var tvs=e.TaggedValues; for(var i=0;i&lt;tvs.Count;i++){ var tv=tvs.GetAt(i); if(equalsIgnoreCase(tv.Name,name)) return String(tv.Value||\"\"); } return \"\"; }\nfunction writeTag(e, name, value){ var tvs=e.TaggedValues, i; for(i=0;i&lt;tvs.Count;i++){ var tv=tvs.GetAt(i); if(equalsIgnoreCase(tv.Name,name)){ tv.Value=String(value); tv.Update(); e.Update(); return; } } var nt=tvs.AddNew(name,String(value)); nt.Update(); e.Update(); }\nfunction keysOf(o){ var r=[],k; for(k in o){ if(o.hasOwnProperty(k)) r.push(k);} return r; }\n\nmain();\n\n\n\nValidating toolbox conformance (lightweight)\nYou usually enforce toolbox usage indirectly:\n\nBase type matches your profile expectation (e.g., Class).\nStereotype is the one from your profile (profile::stereo).\nRequired tags exist (often defined by your MDG).\n\nIf all three pass, the modeller effectively used your toolbox.\nFor stricter checks, you can augment the rulebook with allowed connector types and required relationships per stereotype, then lint them the same way.\n\n\nExample 10.5 - Add to MDG_RULES:\n\n// Example 10.5 - Add to MDG_RULES:\n\"MyProfile::BusinessCapability\": {\n  baseType: \"Class\",\n  requiredTags: [{name:\"Owner\", defaultValue:\"ArchitectureTeam\"}],\n  namePrefix: \"BC_\",\n  requiresOutgoing: [ { type:\"Realization\", toStereo:\"MyProfile::ApplicationService\" } ]\n}\nThen in your linter:\n// After tag checks:\nif (rule.requiresOutgoing) {\n    for (var r=0; r&lt;rule.requiresOutgoing.length; r++) {\n        var req = rule.requiresOutgoing[r];\n        if (!hasOutgoing(e, req.type, req.toStereo)) {\n            issues += emit(csv, e, applied, \"MissingLink\",\n                \"Require outgoing \" + req.type + \" to \" + req.toStereo, expectedFQ);\n        }\n    }\n}\nfunction hasOutgoing(e, connType, toFQStereo){\n    var cons = e.Connectors;\n    for (var i=0; i&lt;cons.Count; i++) {\n        var c = cons.GetAt(i);\n        if (c.Type != connType) continue;\n        var supplier = Repository.GetElementByID(c.SupplierID);\n        if (!supplier) continue;\n        if (hasFQStereo(String(supplier.StereotypeEx||\"\"), toFQStereo)) return true;\n    }\n    return false;\n}\n\n\n\nBulk discovery using SQL (fast find, safe check)\nOn very large repositories, find with SQL then verify via the API.\n\n\nExample 10.6 - MDG_SQL_FindMissingTag.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 10.6 - MDG_SQL_FindMissingTag.js – JScript (ES3)\n// Purpose: Pre-filter candidates with SQL, then verify with API\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n!INC _Common.Helpers\n!INC _Common.MDG_Rulebook\nfunction main() {\n    var TAB=\"MDG_SQL_Find\";\n    ensureOutputTab(TAB);\n\n    var key = \"MyProfile::BusinessCapability\";\n    var rule = MDG_RULES[key];\n    var tagName = \"Owner\";\n\n    // Fast repo-wide prefilter: base type & stereotype absent or wrong (rough)\n    // NOTE: Stereotypes are stored in multiple places; we prefilter by type and post-check StereotypeEx via API.\n    var sql = \"SELECT Object_ID FROM t_object WHERE Object_Type='\" + rule.baseType + \"'\";\n    var xml = Repository.SQLQuery(sql);\n    var ids = extractAll(xml, \"&lt;Object_ID&gt;\", \"&lt;/Object_ID&gt;\");\n    var offenders = 0;\n\n    for (var i=0; i&lt;ids.length; i++) {\n        var el = Repository.GetElementByID(parseInt(ids[i],10));\n        if (!el) continue;\n        if (!hasFQ(String(el.StereotypeEx||\"\"), key)) continue; // truly in scope\n        var tv = readTag(el, tagName);\n        if (trim(tv) === \"\") {\n            offenders++;\n            Session.Output(\"Missing tag '\" + tagName + \"': \" + el.Name + \" (\" + el.ElementID + \")\");\n        }\n    }\n    log(TAB, \"Offenders (missing \"+tagName+\"): \" + offenders);\n}\n\nfunction extractAll(h,a,b){ var r=[],s=0; while(true){ var i=h.indexOf(a,s); if(i&lt;0) break; var j=h.indexOf(b,i+a.length); if(j&lt;0) break; r.push(h.substring(i+a.length,j)); s=j+b.length; } return r; }\nfunction hasFQ(applied,fq){ var arr=String(applied||\"\").split(\",\"); for(var i=0;i&lt;arr.length;i++){ if(equalsIgnoreCase(trim(arr[i]),fq)) return true; } return false; }\nfunction readTag(e,n){ var tvs=e.TaggedValues; for(var i=0;i&lt;tvs.Count;i++){ var t=tvs.GetAt(i); if(equalsIgnoreCase(t.Name,n)) return String(t.Value||\"\"); } return \"\"; }\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#safety-governance-notes",
    "href": "11-System.Object[].html#safety-governance-notes",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "Safety & governance notes",
    "text": "Safety & governance notes\n\nAlways prefer StereotypeEx for MDG accuracy.\nNever raw-update MDG metadata in EA tables unless you absolutely must (and then only when you fully understand the schema).\nCentralise rules in a small “rulebook” map; your linter and repairer both use it.\nDry-run first and log CSVs of changes for audit.\nUse SQL to find, API to fix at scale.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "11-System.Object[].html#what-to-use-when-cheat-sheet",
    "href": "11-System.Object[].html#what-to-use-when-cheat-sheet",
    "title": "Chapter 10: MDG-Aware Scripting",
    "section": "What to use when (cheat-sheet)",
    "text": "What to use when (cheat-sheet)\n\nApply a profile stereotype to many items → Example 9.1.\nReport MDG drift (tags/names/stereos) → Example 9.3 (linter).\nFix drift with defaults and renaming → Example 9.4 (repairer).\nEnforce relationships between MDG types → 9.5 extension.\nHuge repositories → 9.6 SQL pre-filter + API verification.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Chapter 10: MDG-Aware Scripting</span>"
    ]
  },
  {
    "objectID": "12-System.Object[].html",
    "href": "12-System.Object[].html",
    "title": "Chapter 11: Governance Scripts",
    "section": "",
    "text": "Why Governance Matters\nGovernance is one of the most important and least glamorous aspects of modelling. It is the quiet discipline that ensures models remain trustworthy, consistent, and usable over time. Without governance, repositories decay. Naming conventions drift, orphaned elements accumulate, stereotypes are misapplied, and diagrams no longer reflect reality. A model that begins as a clear architectural guide slowly becomes a jungle of inconsistencies, and eventually stakeholders stop trusting it.\nEnterprise Architect provides some built-in validation features, but governance at scale requires automation. This is where governance scripts come in. They act as model guardians: scanning repositories for violations, enforcing standards, and generating objective reports on quality. They take subjective debates about “style” and turn them into automated checks that either pass or fail. In doing so, they transform governance from a painful, manual process into a manageable and repeatable workflow.\nThis chapter introduces the concept of governance scripts. It explains why governance matters, what kinds of issues can be checked, how automation changes the governance process, and why scripting is uniquely suited to this role. It also emphasises the importance of balance: governance should not be punitive or bureaucratic, but enabling — a way to help modellers do good work with confidence.\nModels are living artefacts. They are updated by many people over months or years. Left unchecked, even small deviations accumulate into serious problems:\nGovernance provides the antidote. It ensures the model remains a reliable foundation for decision-making, documentation, and integration with other tools.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chapter 11: Governance Scripts</span>"
    ]
  },
  {
    "objectID": "12-System.Object[].html#why-governance-matters",
    "href": "12-System.Object[].html#why-governance-matters",
    "title": "Chapter 11: Governance Scripts",
    "section": "",
    "text": "Inconsistent naming makes elements hard to find.\nMissing tags leave models unfit for analysis.\nIncorrect connectors break traceability.\nDuplicated elements cause confusion in reports.\nOrphaned elements give the illusion of coverage but no actual linkage.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chapter 11: Governance Scripts</span>"
    ]
  },
  {
    "objectID": "12-System.Object[].html#the-pain-of-manual-governance",
    "href": "12-System.Object[].html#the-pain-of-manual-governance",
    "title": "Chapter 11: Governance Scripts",
    "section": "The Pain of Manual Governance",
    "text": "The Pain of Manual Governance\nTraditionally, governance has been manual: reviewers inspect models, checklists are filled in, and corrective actions assigned. This is slow, subjective, and demoralising. Architects end up spending more time policing modellers than doing architecture. Reviewers argue about style rather than substance. And problems are often caught late, when correcting them is expensive.\nManual governance is also inconsistent. Different reviewers may apply different standards, leading to confusion and resentment. The result is often governance fatigue: modellers stop caring, reviewers stop enforcing, and quality slides.\n\nThe Case for Automation\nScripting changes the dynamic completely. With governance scripts, checks are automated, repeatable, and objective. A script does not get tired, bored, or inconsistent. It simply scans the repository and reports results.\nBenefits include:\n\nSpeed: thousands of elements can be checked in seconds.\nObjectivity: standards are enforced consistently.\nTransparency: logs show exactly what passed and failed.\nScalability: large repositories can be governed without multiplying staff effort.\n\nAutomated governance also changes culture. Instead of governance being seen as policing, it becomes part of normal workflow. Modellers can run scripts themselves before committing changes, catching issues early.\n\n\nWhat Governance Scripts Check\nGovernance scripts can cover many aspects of model quality. Common categories include:\n\nNaming conventions: e.g., requirements must start with REQ_, capabilities with BC_.\nStereotype compliance: only approved stereotypes may be used.\nTagged value completeness: certain tags must exist and be populated.\nConnector rules: e.g., only ApplicationComponents may realise Capabilities.\nModel smells: orphaned elements, duplicate names, unused diagrams.\nCoverage checks: every requirement must trace to a capability, every component to a service.\n\nThese checks can be run as reports or as enforcement scripts that auto-correct issues.\n\n\nFrom Policing to Enablement\nOne danger of governance automation is that it can become heavy-handed: modellers feel constrained and demotivated. The key is to frame governance as enablement, not punishment. Scripts are there to help, not hinder.\nFor example:\n\nA script that renames elements automatically to match conventions saves modellers time.\nA script that adds missing tags reduces manual entry.\nA script that reports orphans gives clear guidance for cleanup.\n\nWhen governance scripts are seen as helpers, adoption increases.\n\n\nGovernance as Quality Assurance\nGovernance is not separate from quality; it is quality assurance for models. Just as code is tested by unit tests and static analysis, models should be tested by governance scripts. This analogy is powerful: modellers begin to see governance not as red tape but as the modelling equivalent of running tests. Passing governance checks means your model is ready for use.\n\n\nLevels of Governance\nGovernance can be applied at different levels:\n\nLocal: a modeller runs a script on their package before publishing.\nTeam: governance scripts are run during reviews or milestones.\nEnterprise: scheduled jobs scan the whole repository and produce dashboards.\n\nScripting supports all three levels. Internal scripts are ideal for local checks. External automation can handle enterprise-wide scans and reporting.\n\n\nReporting and Transparency\nThe value of governance scripts is not only in enforcement but also in reporting. A script that logs issues to CSV can feed dashboards or be shared in review meetings. Reports provide evidence of compliance, useful for audits or regulatory contexts.\nTransparency is key: modellers must be able to see why something failed and how to fix it. A governance report that simply says “non-compliant” is not helpful. A report that lists exactly which elements are missing which tags is actionable.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chapter 11: Governance Scripts</span>"
    ]
  },
  {
    "objectID": "12-System.Object[].html#governance-and-mdgs",
    "href": "12-System.Object[].html#governance-and-mdgs",
    "title": "Chapter 11: Governance Scripts",
    "section": "Governance and MDGs",
    "text": "Governance and MDGs\nAs Chapter 9 explained, MDGs define the modelling language in use. Governance scripts must respect MDGs: checking that stereotypes are used correctly, tags are populated, and connector rules are followed. This alignment ensures that automation reinforces, rather than undermines, the MDG.\nFor example, a governance script for an ArchiMate MDG might check that every ApplicationComponent has a Layer tag and that only ApplicationComponents realise Capabilities.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chapter 11: Governance Scripts</span>"
    ]
  },
  {
    "objectID": "12-System.Object[].html#examples",
    "href": "12-System.Object[].html#examples",
    "title": "Chapter 11: Governance Scripts",
    "section": "Examples",
    "text": "Examples\n\nNaming Conventions\n\n\nExample 11.1 - Gov_NamingConvention.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 11.1 - Gov_NamingConvention.js – JScript (ES3)\n// Purpose: Enforce naming convention \"REQ_\" for Requirement elements\n// Safety: DRY_RUN = true by default\n// Output: Logs violations, optional repair\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction trim(str) {\n    if (str == null || str == undefined) return \"\";\n    return String(str).replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction startsWith(str, prefix) {\n    return String(str||\"\").indexOf(prefix) === 0;\n}\n\nfunction main() {\n    var DRY_RUN = true;\n    var PREFIX  = \"REQ_\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var fixed=0, issues=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Requirement\") {\n            if (!startsWith(e.Name, PREFIX)) {\n                issues++;\n                var newName = PREFIX + trim(e.Name);\n                Session.Output(\"Naming issue: \" + e.Name + \" → \" + newName);\n                if (!DRY_RUN) {\n                    e.Name = newName;\n                    e.Update();\n                    fixed++;\n                }\n            }\n        }\n    }\n    if (!DRY_RUN && fixed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    Session.Output(\"Issues=\" + issues + \" Fixed=\" + fixed + \" Dry-run=\" + DRY_RUN);\n}\n\nmain();\n\n\n\nModel Smells\n\n\nExample 11.1 - Gov_NamingConvention.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 11.2 - Gov_ModelSmells_Orphans.js – JScript (ES3)\n// Purpose: Find elements without any connectors (orphans)\n// Output: Report-only\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var orphans=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Connectors.Count == 0) {\n            orphans++;\n            Session.Output(\"Orphan: \" + e.Name + \" (\" + e.Type + \")\");\n        }\n    }\n    Session.Output(\"Total orphans found: \" + orphans);\n}\n\nmain();\n\n\n\nDuplicate Elements\n\n\nExample 11.3 - Gov_ModelSmells_Duplicates.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 11.3 - Gov_ModelSmells_Duplicates.js – JScript (ES3)\n// Purpose: Report duplicate element names within a package\n// Output: Report-only\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var seen = {};\n    var dups = 0;\n\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var name = String(e.Name||\"\");\n        if (seen[name]) {\n            Session.Output(\"Duplicate name: \" + name + \" (ElementID=\" + e.ElementID + \")\");\n            dups++;\n        } else {\n            seen[name] = true;\n        }\n    }\n    Session.Output(\"Duplicate count: \" + dups);\n}\n\nmain();\n\n\n\nCoverage & Traceability\nTraceability rules ensure that modelled items are linked correctly (e.g., each requirement must trace to at least one capability).\n\n\nExample 11.4 - Gov_Traceability_Check.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 11.4 - Gov_Traceability_Check.js – JScript (ES3)\n// Purpose: Verify every Requirement in a package has at least one Realization link to a Capability\n// Safety: Report-only\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var missing=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Requirement\") {\n            var cons = e.Connectors;\n            var hasTrace = false;\n            for (var j=0; j&lt;cons.Count; j++) {\n                var c = cons.GetAt(j);\n                if (c.Type == \"Realisation\" || c.Type == \"Realization\") {\n                    var target = Repository.GetElementByID(c.SupplierID);\n                    if (target && target.Stereotype == \"Capability\") {\n                        hasTrace = true;\n                        break;\n                    }\n                }\n            }\n            if (!hasTrace) {\n                missing++;\n                Session.Output(\"Requirement without Capability trace: \" + e.Name + \" (ID=\" + e.ElementID + \")\");\n            }\n        }\n    }\n    Session.Output(\"Traceability issues found: \" + missing);\n}\n\nmain();\n\n\n\nGovernance Reports (CSV)\nFor larger models, CSV outputs make governance easier to review.\n\n\nExample 11.5 - Gov_ExportViolations.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 11.5 - Gov_ExportViolations.js – JScript (ES3)\n// Purpose: Collect naming, orphan, and traceability issues into CSV\n// Output: directory-only chooser; filename auto-derived\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction trim(str) {\n    if (str == null || str == undefined) return \"\";\n    return String(str).replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction browseForFolder(promptText) {\n    var shell = new ActiveXObject(\"Shell.Application\");\n    var folder = shell.BrowseForFolder(0, promptText, 0, 0);\n    return folder ? folder.Self.Path : null;\n}\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var outDir = browseForFolder(\"Select output folder for governance CSV\");\n    if (!outDir) return;\n\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var stamp = (new Date()).getTime();\n    var path = outDir + \"\\\\governance_report_\" + stamp + \".csv\";\n    var file = fso.CreateTextFile(path, true);\n\n    file.WriteLine(\"IssueType,ElementID,Name,Details\");\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n\n        // Naming check\n        if (e.Type == \"Requirement\" && !startsWith(e.Name, \"REQ_\")) {\n            file.WriteLine(\"Naming,\"+e.ElementID+\",\"+e.Name+\",Missing REQ_ prefix\");\n        }\n\n        // Orphan check\n        if (e.Connectors.Count == 0) {\n            file.WriteLine(\"Orphan,\"+e.ElementID+\",\"+e.Name+\",No connectors\");\n        }\n\n        // Traceability check\n        if (e.Type == \"Requirement\" && !hasCapabilityTrace(e)) {\n            file.WriteLine(\"Traceability,\"+e.ElementID+\",\"+e.Name+\",No Capability trace\");\n        }\n    }\n\n    file.Close();\n    Session.Output(\"Governance report written → \" + path);\n}\n\nfunction startsWith(str, prefix) {\n    return String(str||\"\").indexOf(prefix) === 0;\n}\nfunction hasCapabilityTrace(e) {\n    var cons = e.Connectors;\n    for (var j=0; j&lt;cons.Count; j++) {\n        var c = cons.GetAt(j);\n        if (c.Type == \"Realisation\" || c.Type == \"Realization\") {\n            var target = Repository.GetElementByID(c.SupplierID);\n            if (target && target.Stereotype == \"Capability\") return true;\n        }\n    }\n    return false;\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chapter 11: Governance Scripts</span>"
    ]
  },
  {
    "objectID": "12-System.Object[].html#summary",
    "href": "12-System.Object[].html#summary",
    "title": "Chapter 11: Governance Scripts",
    "section": "Summary",
    "text": "Summary\nGovernance scripts are simple but powerful. They let you:\n\nEnforce naming standards (Example 10.1).\nDetect structural smells like orphans and duplicates (Examples 10.2 & 10.3).\nCheck coverage and traceability (Example 10.4).\nExport reports for human review (Example 10.5).\n\nTogether, these create a living quality gate for your repository — fast, repeatable, and objective.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Chapter 11: Governance Scripts</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html",
    "href": "13-System.Object[].html",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "",
    "text": "The Value of Worked Examples\nAfter learning the essentials of EA scripting, exploring design patterns, and examining governance automation, you are ready for a different kind of resource: a cookbook. This chapter serves as a library of practical scripts — small, focused recipes that solve common problems.\nWhy a cookbook? Because most architects and modellers do not want to read abstract descriptions of APIs or design principles when they are under pressure to deliver. They want to grab a working example, tweak a few lines, and get results. A cookbook provides exactly that: practical, runnable scripts that cover the typical scenarios you will encounter in everyday work with Enterprise Architect.\nThis introduction explains how to use the cookbook effectively, why examples are powerful learning tools, what safety precautions to take, and how to adapt recipes to your organisation’s context.\nLearning by example is one of the fastest ways to acquire scripting skills. You see the structure of a script, copy it, run it, and modify it. Each time you adapt an example, you internalise a little more of the API. Over time, the examples stop being magic incantations and start becoming familiar patterns.\nThis mirrors how many people learn to cook. Few start by reading chemistry textbooks. They follow recipes, taste the results, and gradually learn to improvise. A scripting cookbook provides the same bridge: from passive reading to active doing.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#the-scope-of-the-cookbook",
    "href": "13-System.Object[].html#the-scope-of-the-cookbook",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "The Scope of the Cookbook",
    "text": "The Scope of the Cookbook\nThe examples in this chapter span a wide range of tasks:\n\nSimple utilities (rename elements, list tagged values).\nGovernance checks (enforce naming conventions, detect orphans).\nImport/export helpers (CSV, JSON).\nDiagram utilities (rename objects on diagrams, layout tweaks).\nAdvanced recipes (generate XMI, bulk stereotype changes).\n\nTogether, these recipes form a library you can draw on again and again.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#why-not-just-copy-from-the-internet",
    "href": "13-System.Object[].html#why-not-just-copy-from-the-internet",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "Why Not Just Copy from the Internet?",
    "text": "Why Not Just Copy from the Internet?\nIt is true that you can find EA script snippets on forums, blogs, or Q&A sites. But they are often incomplete, outdated, or written without safety in mind. Some use direct SQL writes that risk corrupting the repository. Some assume modern JavaScript features that EA’s JScript engine does not support.\nThe difference here is that every recipe in this cookbook is:\n\nFully runnable in EA’s script environment.\nCorrected for ES3 constraints.\nStructured with a standard header, dry-run flag, and logging.\nExplained line by line with comments.\n\nThis makes them safer and more reliable than random fragments you might stumble across online.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#safety-first-in-a-cookbook",
    "href": "13-System.Object[].html#safety-first-in-a-cookbook",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "Safety First in a Cookbook",
    "text": "Safety First in a Cookbook\nEven though these are examples, they still modify repositories. That means the safety principles of Chapter 3 apply even more strongly here.\nEvery modifying recipe includes:\n\nA DRY_RUN flag set to true by default.\nSession.Output logging for feedback.\nClear documentation of purpose, assumptions, and usage.\nWhere relevant, CSV logging so you can review results.\n\nYour responsibility as a user is to:\n\nRun in dry-run mode first.\nReview the logs.\nOnly then set DRY_RUN = false and rerun.\n\nUsed this way, the cookbook is safe and predictable.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#adapting-recipes-to-your-context",
    "href": "13-System.Object[].html#adapting-recipes-to-your-context",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "Adapting Recipes to Your Context",
    "text": "Adapting Recipes to Your Context\nNo recipe is ever perfect out of the box. Just as you might add more spice or substitute an ingredient in cooking, you will adapt these scripts to your organisation’s needs. That might mean:\n\nChanging the stereotype names to match your MDG.\nAdding extra tagged values.\nAdjusting logging paths to your file system.\nExpanding filters to cover additional element types.\n\nThe important thing is that you do not start from zero. You begin with a working, commented script and adapt it.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#the-teaching-role-of-recipes",
    "href": "13-System.Object[].html#the-teaching-role-of-recipes",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "The Teaching Role of Recipes",
    "text": "The Teaching Role of Recipes\nExamples do more than solve immediate problems. They also teach. By comparing two recipes, you begin to notice similarities — the same .Count and .GetAt() loops, the same Update() calls, the same RefreshModelView(). You start to see the skeleton of the EA API underneath. This is how cookbook use deepens understanding: repetition makes the patterns obvious.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#building-a-shared-library",
    "href": "13-System.Object[].html#building-a-shared-library",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "Building a Shared Library",
    "text": "Building a Shared Library\nOne of the most powerful practices is to build a shared library of scripts for your team. Start with this cookbook, adapt recipes, and store them in version control (Git). Over time, your organisation develops its own tailored cookbook, aligned to your MDGs, governance rules, and workflows. This not only saves time but also enforces consistency across projects.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#cookbook-limitations",
    "href": "13-System.Object[].html#cookbook-limitations",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "Cookbook Limitations",
    "text": "Cookbook Limitations\nA cookbook is not a substitute for deeper understanding. If you only ever copy and paste without comprehension, you risk misuse. That is why every recipe is heavily commented — to explain not only what happens but why. The goal is not just to give you fish but to teach you how to fish.",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#ai-and-cookbook-expansion",
    "href": "13-System.Object[].html#ai-and-cookbook-expansion",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "AI and Cookbook Expansion",
    "text": "AI and Cookbook Expansion\nOne interesting modern twist is that AI can generate new recipes on demand. You might start with a cookbook script and then ask an AI to adapt it: “Modify this script to export to JSON instead of CSV.” However, as we saw in earlier chapters, AI often hallucinates. That is why having a solid cookbook matters: you can use AI to vary a reliable base, rather than trusting AI to invent code from scratch.\n\nRename All Elements in a Package\n\n\nExample 12.1 - RenameElements_Prefix.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.1 - RenameElements_Prefix.js – JScript (ES3)\n// Purpose: Add a prefix to all element names in the selected package\n// Assumptions: User selects a package in Project Browser\n// Safety: DRY_RUN = true by default\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var PREFIX = \"ARCH_\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package first.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Name.indexOf(PREFIX) != 0) {\n            var newName = PREFIX + e.Name;\n            Session.Output(\"Would rename: \" + e.Name + \" → \" + newName);\n            if (!DRY_RUN) {\n                e.Name = newName;\n                e.Update();\n            }\n        }\n    }\n    if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);\n}\n\nmain();\n\n\n\nAdd a Tagged Value to All Elements\n\n\nExample 12.2 - AddTag_AllElements.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.2 - AddTag_AllElements.js – JScript (ES3)\n// Purpose: Add or update a tagged value across all elements in a package\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var TAG_NAME = \"Owner\";\n    var TAG_VALUE = \"ArchitectureTeam\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var tags = e.TaggedValues;\n        var found = false;\n\n        for (var j=0; j&lt;tags.Count; j++) {\n            var t = tags.GetAt(j);\n            if (t.Name == TAG_NAME) {\n                found = true;\n                if (t.Value != TAG_VALUE) {\n                    Session.Output(\"Update tag for \" + e.Name);\n                    if (!DRY_RUN) { t.Value = TAG_VALUE; t.Update(); e.Update(); }\n                }\n            }\n        }\n        if (!found) {\n            Session.Output(\"Add tag for \" + e.Name);\n            if (!DRY_RUN) {\n                var nt = tags.AddNew(TAG_NAME, TAG_VALUE);\n                nt.Update(); e.Update();\n            }\n        }\n    }\n    if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);\n}\n\nmain();\n\n\n\nExport All Requirements to CSV\n\n\nExample 12.3 - ExportRequirements_CSV.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.3 - ExportRequirements_CSV.js – JScript (ES3)\n// Purpose: Write requirement names and notes to CSV\n// Output: File written to chosen folder\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var shell = new ActiveXObject(\"Shell.Application\");\n    var folder = shell.BrowseForFolder(0, \"Select output folder\", 0, 0);\n    if (!folder) return;\n    var dir = folder.Self.Path;\n\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var file = fso.CreateTextFile(dir + \"\\\\requirements.csv\", true);\n\n    file.WriteLine(\"ID,Name,Notes\");\n\n    var sql = \"SELECT Object_ID, Name, Note FROM t_object WHERE Object_Type='Requirement'\";\n    var xml = Repository.SQLQuery(sql);\n\n    // Parse simple XML rows\n    var rows = xml.split(\"&lt;Row&gt;\");\n    for (var i=1; i&lt;rows.length; i++) {\n        var row = rows[i];\n        var id = between(row,\"&lt;Object_ID&gt;\",\"&lt;/Object_ID&gt;\");\n        var nm = between(row,\"&lt;Name&gt;\",\"&lt;/Name&gt;\");\n        var nt = between(row,\"&lt;Note&gt;\",\"&lt;/Note&gt;\");\n        file.WriteLine(id + \",\\\"\" + nm + \"\\\",\\\"\" + nt + \"\\\"\");\n    }\n\n    file.Close();\n    Session.Output(\"Requirements exported.\");\n}\n\nfunction between(h,a,b){ var i=h.indexOf(a); if(i&lt;0) return \"\"; var j=h.indexOf(b,i+a.length); return j&lt;0?\"\":h.substring(i+a.length,j); }\n\nmain();\n\n\n\nFind Orphaned Elements\n\n\nExample 12.4 - FindOrphans.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.4 - FindOrphans.js – JScript (ES3)\n// Purpose: Report elements with no connectors\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var orphans=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Connectors.Count == 0) {\n            orphans++;\n            Session.Output(\"Orphan: \" + e.Name);\n        }\n    }\n    Session.Output(\"Total orphans: \" + orphans);\n}\n\nmain();\n\n\n### List Elements by Stereotype\n```{.js filename=\"Example 12.5 - ListByStereotype.js – JScript (ES3)\"}\n// -------------------------------------------------------\n// Example 12.5 - ListByStereotype.js – JScript (ES3)\n// Purpose: Output all elements with a given stereotype\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var STEREOTYPE = \"Capability\";\n\n    var sql = \"SELECT ea_guid, Name FROM t_object WHERE Stereotype='\" + STEREOTYPE + \"'\";\n    var xml = Repository.SQLQuery(sql);\n\n    var rows = xml.split(\"&lt;Row&gt;\");\n    for (var i=1; i&lt;rows.length; i++) {\n        var row = rows[i];\n        var guid = between(row,\"&lt;ea_guid&gt;\",\"&lt;/ea_guid&gt;\");\n        var nm = between(row,\"&lt;Name&gt;\",\"&lt;/Name&gt;\");\n        Session.Output(\"Capability: \" + nm + \" (\" + guid + \")\");\n    }\n}\nfunction between(h,a,b){ var i=h.indexOf(a); if(i&lt;0) return \"\"; var j=h.indexOf(b,i+a.length); return j&lt;0?\"\":h.substring(i+a.length,j); }\n\nmain();\n\n\n\nCreate a Trace Link Between Selected Elements\n\n\nExample 12.6 - CreateTrace.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.6 - CreateTrace.js – JScript (ES3)\n// Purpose: Create a Realisation connector between two elements selected in a diagram\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var dia = Repository.GetCurrentDiagram();\n    if (!dia) { Session.Prompt(\"Open a diagram and select two elements.\", promptOK); return; }\n\n    if (dia.SelectedObjects.Count != 2) {\n        Session.Prompt(\"Select exactly two elements.\", promptOK);\n        return;\n    }\n\n    var el1 = Repository.GetElementByID(dia.SelectedObjects.GetAt(0).ElementID);\n    var el2 = Repository.GetElementByID(dia.SelectedObjects.GetAt(1).ElementID);\n\n    var conn = el1.Connectors.AddNew(\"\", \"Realisation\");\n    conn.SupplierID = el2.ElementID;\n    conn.Update();\n\n    Repository.RefreshModelView(el1.PackageID);\n    Session.Output(\"Trace created: \" + el1.Name + \" → \" + el2.Name);\n}\n\nmain();\n\n\n\nReport Elements Missing Documentation\n\n\nExample 12.7 - FindMissingNotes.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.7 - FindMissingNotes.js – JScript (ES3)\n// Purpose: List elements without notes (documentation)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (trim(e.Notes) == \"\") {\n            Session.Output(\"Missing notes: \" + e.Name);\n        }\n    }\n}\nfunction trim(str){ return str==null?\"\":String(str).replace(/^\\s+|\\s+$/g,\"\"); }\n\nmain();\n\n\n\nExport Class Attributes\n\n\nExample 12.8 - ExportClassAttributes.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.8 - ExportClassAttributes.js – JScript (ES3)\n// Purpose: Export attributes of all classes in a package\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Class\") {\n            var attrs = e.Attributes;\n            for (var j=0; j&lt;attrs.Count; j++) {\n                var a = attrs.GetAt(j);\n                Session.Output(\"Class \" + e.Name + \" attr: \" + a.Name + \":\" + a.Type);\n            }\n        }\n    }\n}\n\nmain();\n\n\n\nBulk Set Status\n\n\nExample 12.9 - BulkSetStatus.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.9 - BulkSetStatus.js – JScript (ES3)\n// Purpose: Set the Status of all elements in a package\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var NEW_STATUS = \"Proposed\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Status != NEW_STATUS) {\n            Session.Output(\"Change status: \" + e.Name + \" → \" + NEW_STATUS);\n            if (!DRY_RUN) { e.Status = NEW_STATUS; e.Update(); }\n        }\n    }\n    if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);\n}\n\nmain();\n\n\n\nDelete Elements Safely\n\n\nExample 12.10 - SafeDelete.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 12.10 - SafeDelete.js – JScript (ES3)\n// Purpose: Delete all elements of a given type in a package\n// Safety: DRY_RUN = true by default\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var TYPE_FILTER = \"UseCase\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    // Iterate backwards when deleting\n    for (var i=els.Count-1; i&gt;=0; i--) {\n        var e = els.GetAt(i);\n        if (e.Type == TYPE_FILTER) {\n            Session.Output(\"Would delete: \" + e.Name);\n            if (!DRY_RUN) {\n                els.DeleteAt(i, false); // false = don't refresh each time\n            }\n        }\n    }\n    if (!DRY_RUN) {\n        pkg.Update();\n        Repository.RefreshModelView(pkg.PackageID);\n    }\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "13-System.Object[].html#summary",
    "href": "13-System.Object[].html#summary",
    "title": "Chapter 12: Cookbook of Examples",
    "section": "Summary",
    "text": "Summary\nThis cookbook chapter delivers ready-to-use recipes:\n\nBulk editing (11.1, 11.2, 11.9, 11.10).\nReporting (11.4, 11.5, 11.7, 11.8).\nTraceability utilities (11.6).\nImport/export utilities (11.3).\n\nEach follows the constraints of EA’s JScript engine (ES3 only, ActiveX for files, .Count/.GetAt() for collections).",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Chapter 12: Cookbook of Examples</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html",
    "href": "14-System.Object[].html",
    "title": "Chapter 13: Why AI Helps",
    "section": "",
    "text": "Benefits\nBy this point, we have explored why scripting Enterprise Architect is essential, how the automation landscape is structured, and how to apply safe, repeatable patterns. We have also seen how practical recipes can turn concepts into working scripts. Yet for many modellers, one barrier remains: the leap from knowing that scripting is possible to actually writing the first line of code.\nThis is where artificial intelligence (AI) comes in. Large language models (LLMs) such as ChatGPT, Claude, or Copilot have introduced a new way of working: you no longer have to start from a blank editor window. Instead, you can describe what you want in natural language and receive a code draft to work with. AI can provide scaffolding, suggest refactors, and generate boilerplate headers. It cannot replace human judgement, but it can dramatically accelerate the scripting process.\nThis chapter examines why AI is such a powerful assistant in the EA scripting context. It explains the barriers AI helps overcome, the risks it introduces, and the ways to use it responsibly. By the end, you will see AI not as a magic solution but as a valuable partner: one that helps you get started, iterate faster, and learn more effectively.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#benefits",
    "href": "14-System.Object[].html#benefits",
    "title": "Chapter 13: Why AI Helps",
    "section": "",
    "text": "The Blank Page Problem\nFor many modellers, the hardest part of scripting is not the logic but the start. Opening EA’s script editor and staring at an empty window can be intimidating. Even if you know what you want to achieve — “rename all requirements with a REQ_ prefix” — translating that into correct JScript syntax feels daunting.\nAI reduces this barrier. By typing a prompt such as “Write an EA script that adds a prefix to all Requirement elements in a selected package”, you receive a draft that includes the right loop structure, .Count and .GetAt() calls, and Update() method. It may not be perfect, but it is far less intimidating than starting from zero.\n\n\nAI as a Pattern Generator\nEarlier chapters emphasised the importance of scripting patterns: Find/Filter/Apply, Tag Propagation, Curate-then-Write. AI is good at recognising these patterns and generating boilerplate loops. Instead of writing the same traversal logic repeatedly, you can ask AI to generate it and then adjust the details.\nFor example, a prompt like “Write a Find/Filter/Apply script that sets the Status to Approved for all Requirements tagged with ‘Owner=Architecture’” can yield a working draft in seconds.\n\n\nAI as a Translator\nOne of the practical challenges in EA scripting is the language choice. Many legacy scripts are in VBScript, while most new ones are in JScript. AI can act as a translator, converting VBScript examples into JScript ES3. It can also help migrate JScript snippets into Python or C# for external automation.\nFor example, you might paste an old VBScript snippet and ask: “Translate this into JScript (ES3 only, no forEach, no JSON methods).” AI can provide a draft translation that saves hours of manual effort.\n\n\nAI as a Refactoring Partner\nAs your script library grows, you may notice duplication: multiple scripts with similar loops, slightly different logic, inconsistent logging. AI can help refactor them into cleaner, more consistent structures.\nFor instance, you might prompt: “Refactor this script to include a DRY_RUN flag and a logging function that writes to CSV.” AI will propose a refactored version, which you can then validate. This makes it easier to standardise your script style and enforce governance principles.\n\n\nAI for Documentation and Training\nAnother way AI adds value is in documentation. Good scripts should always include headers (purpose, usage, assumptions, safety, dependencies). Writing these headers can feel tedious. AI can generate them for you.\nSimilarly, AI can create training material: explainers, walkthroughs, or alternative language examples. For new team members, you can paste a script into AI and ask it to explain what each line does in plain English. This makes onboarding easier.\n\nThe Risks of AI in Scripting\nOf course, AI is not perfect. In fact, it is often confidently wrong. Common risks include:\n\nHallucinations: inventing methods that do not exist (e.g., forEach on EA collections).\nUnsupported syntax: using modern JavaScript features (let, const, arrow functions) that fail in EA’s ES3 engine.\nUnsafe updates: forgetting to include Update() or DRY_RUN, leading to destructive changes.\nPerformance issues: generating scripts that spam Session.Output thousands of times.\n\nThese risks are not minor. If you copy AI output blindly into a production repository, you may corrupt or damage your model. That is why AI must always be used with caution.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#using-ai-safely",
    "href": "14-System.Object[].html#using-ai-safely",
    "title": "Chapter 13: Why AI Helps",
    "section": "Using AI Safely",
    "text": "Using AI Safely\nThe key to using AI effectively is to treat it as a drafting tool, not an authority. You are the architect; AI is your assistant. That means:\n\nCraft precise prompts — specify ES3, mention .Count/.GetAt(), require DRY_RUN.\nAlways dry-run first — never trust AI code without logging and simulation.\nReview carefully — read the script line by line, confirm Update() is included where needed.\nTest on sandboxes — never run AI-generated scripts directly on production repositories.\n\nWith these safeguards, AI becomes a useful accelerator rather than a liability.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#ai-and-learning",
    "href": "14-System.Object[].html#ai-and-learning",
    "title": "Chapter 13: Why AI Helps",
    "section": "AI and Learning",
    "text": "AI and Learning\nInterestingly, using AI to generate scripts can also accelerate your own learning. When you compare AI’s draft to your mental model, you notice differences. Sometimes AI is wrong, and that highlights a gap in your own understanding. Sometimes AI uses a trick you didn’t know, and you learn from it.\nOver time, AI becomes a tutor. You experiment by prompting, you review the results, you test and refine. The process itself builds fluency in the EA API.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#ai-in-daily-workflow",
    "href": "14-System.Object[].html#ai-in-daily-workflow",
    "title": "Chapter 13: Why AI Helps",
    "section": "AI in Daily Workflow",
    "text": "AI in Daily Workflow\nLater in this book (Chapter 15), we will explore AI in daily workflow: prompt libraries, Git integration, and governance checks. For now, the key point is that AI is not just for occasional inspiration; it can be integrated into your routine. Whether you are writing a new script, refactoring an old one, or explaining a script to a colleague, AI can help.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#examples",
    "href": "14-System.Object[].html#examples",
    "title": "Chapter 13: Why AI Helps",
    "section": "Examples",
    "text": "Examples\n\nAI-generated vs Corrected\nSuppose you ask an AI:\n“Write a script that lists all elements in a package.”\nYou might get this wrong version:\n\n// [x] AI output (modern JS not supported in EA)\n\nlet pkg = Repository.GetTreeSelectedPackage();\n\nif (!pkg) { alert(\"Select a package\"); }\n\npkg.Elements.forEach(e =\\&gt; console.log(e.Name));\nThis will fail inside EA because:\n\nlet and arrow functions (=&gt;) are unsupported (JScript is ES3).\nEA Collections are not true arrays; .forEach does not exist.\nEA uses Session.Output, not console.log.\n\nHere’s the corrected version:\n\n\nExample 13.1 - ListElements_Corrected.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 13.1 - ListElements_Corrected.js – JScript (ES3)\n// Purpose: Output element names in the selected package\n// Safe version corrected from AI output\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) {\n        Session.Prompt(\"Select a package.\", promptOK);\n        return;\n    }\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        Session.Output(\"Element: \" + e.Name);\n    }\n}\n\nmain();\n\n\n\nAI-Assisted Refactoring\nYou can ask AI:\n“Refactor this script to add dry-run and logging to CSV.”\nAI may provide scaffolding, but you need to ensure it respects EA’s environment.\nRefactored pattern with dry-run and CSV logging:\n\n\nExample 13.2 - RefactorWithDryRun.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 13.2 - RefactorWithDryRun.js – JScript (ES3)\n// Purpose: Rename all Requirements with prefix, log to CSV\n// Example of AI-assisted refactor (corrected to EA ES3)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var PREFIX = \"REQ_\";\n\n    var shell = new ActiveXObject(\"Shell.Application\");\n    var folder = shell.BrowseForFolder(0, \"Select output folder for log CSV\", 0, 0);\n    if (!folder) return;\n    var dir = folder.Self.Path;\n\n    var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n    var file = fso.CreateTextFile(dir + \"\\\\rename_log.csv\", true);\n    file.WriteLine(\"ElementID,OldName,NewName,Action\");\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Requirement\" && e.Name.indexOf(PREFIX) != 0) {\n            var newName = PREFIX + e.Name;\n            file.WriteLine(e.ElementID + \",\" + e.Name + \",\" + newName + \",\" + (DRY_RUN ? \"DRY_RUN\" : \"RENAME\"));\n            if (!DRY_RUN) { e.Name = newName; e.Update(); }\n        }\n    }\n    if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);\n    file.Close();\n\n    Session.Output(\"Script complete. Dry-run=\" + DRY_RUN);\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#using-ai-for-documentation",
    "href": "14-System.Object[].html#using-ai-for-documentation",
    "title": "Chapter 13: Why AI Helps",
    "section": "Using AI for Documentation",
    "text": "Using AI for Documentation\nAnother practical use of AI is auto-generating headers. For example, you paste in a script and ask:\n“Add a structured header with purpose, usage, assumptions, and update history.”\nAI can reliably produce your desired verbose headers (see Chapter 6’s shared format), saving time and keeping your script library consistent.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#best-practices-for-ai-assisted-scripting",
    "href": "14-System.Object[].html#best-practices-for-ai-assisted-scripting",
    "title": "Chapter 13: Why AI Helps",
    "section": "Best Practices for AI-Assisted Scripting",
    "text": "Best Practices for AI-Assisted Scripting\n\nAlways state the runtime: “EA JScript, ES3 only, no ES6 features.”\nRequest safety patterns: dry-run flag, logging, Update() after changes.\nIterate small: test on a dummy package, then scale up.\nCurate prompts: treat prompt engineering as coding. Be explicit.\nRefactor, don’t trust blindly: AI is a partner, not a replacement.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "14-System.Object[].html#summary",
    "href": "14-System.Object[].html#summary",
    "title": "Chapter 13: Why AI Helps",
    "section": "Summary",
    "text": "Summary\nAI helps Sparx EA users by generating scaffolding, converting languages, and automating repetitive refactors. But the constraints of EA’s JScript runtime mean you must always review, test, and correct AI outputs. Use AI as an assistant, not an autopilot.\nIn the next chapter we’ll move to Chapter 13 – Prompt Engineering for EA Scripting, where we’ll learn how to craft precise prompts that yield safe, useful code for EA.",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Chapter 13: Why AI Helps</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html",
    "href": "15-System.Object[].html",
    "title": "Chapter 14: Prompt Engineering",
    "section": "",
    "text": "Why Prompt Engineering Matters\nIn the previous chapter, we saw how artificial intelligence can reduce the blank-page barrier and accelerate scripting. But to get real value from AI, you must learn how to ask properly. AI is like a very fast but sometimes careless assistant. If you give vague instructions, it will give vague or even dangerous results. If you provide precise, structured prompts, it can generate highly usable code. This practice of crafting inputs deliberately is called prompt engineering.\nPrompt engineering is not about writing long, elaborate instructions. It is about giving AI just enough context, constraints, and examples so that the output is aligned with your needs. For Enterprise Architect scripting, that means telling AI about the limitations of JScript ES3, reminding it to use Update() and RefreshModelView(), and insisting on a DRY_RUN flag.\nThis chapter introduces the art of prompt engineering for EA scripting. It shows why generic prompts fail, what makes EA-specific prompts different, and how to refine AI outputs safely. It also explains how to build a library of reusable prompts, so you don’t have to reinvent the wheel every time you need a script.\nAI models are generalists. They have been trained on vast amounts of code and text, but they do not “know” Enterprise Architect in detail. That means they will often produce code that looks plausible but does not run in EA. For example, they may suggest forEach on a collection, or JSON.parse, or modern JavaScript features that EA’s engine does not support.\nWithout careful prompting, you get output that looks fine but fails immediately. With careful prompting, you get output that respects EA’s constraints and includes safety features. Prompt engineering makes the difference between AI as a gimmick and AI as a practical assistant.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#why-prompt-engineering-matters",
    "href": "15-System.Object[].html#why-prompt-engineering-matters",
    "title": "Chapter 14: Prompt Engineering",
    "section": "",
    "text": "The Anatomy of a Good Prompt\nA good prompt for EA scripting usually contains:\n\nContext: make clear you are scripting inside Enterprise Architect using JScript ES3.\nTask: what you want the script to do (e.g., rename requirements, export tags).\nConstraints: what not to use (no let, no const, no forEach).\nSafety: require DRY_RUN, logging, and comments.\nFormat: ask for a complete runnable script with comments, not just fragments.\n\nFor example:\n\n\n\n\n\n\nNotePrompt\n\n\n\nWrite a JScript ES3 script for Sparx Enterprise Architect that traverses the selected package, finds all Requirement elements, and prefixes their names with “REQ_”. Use .Count and .GetAt(i) loops, not modern JS features. Include a DRY_RUN flag set to true by default, call Update() for changes, and refresh the package at the end. Comment every step.\n\n\nThis is a prompt that sets context, constraints, safety, and format.\n\n\nIterative Prompting\nPrompt engineering is rarely one-and-done. Often the first output will be close but not perfect. That is normal. The trick is to iterate:\n\nRun the script in dry-run mode.\nIf it fails, feed the error message back into AI: “The error says ‘forEach is not a function’. Rewrite using .Count and .GetAt().”\nIf it runs but misbehaves, clarify: “The script renamed packages as well as requirements. Please filter only Elements of type Requirement.”\nKeep refining until the script is safe and correct.\n\nThis iterative loop is part of prompt engineering. You don’t expect perfection in one shot; you treat AI as a partner who improves with feedback.\n\n\nPrompt Templates\nOver time, you will notice you reuse similar prompts. Instead of writing them from scratch each time, build prompt templates. For example:\n\nTraversal template: “Write a JScript ES3 script that traverses all elements in the selected package. Use .Count and .GetAt(). For each element, [do something]. Include DRY_RUN and logging.”\nTagged value template: “Write a JScript ES3 script that checks all elements of stereotype X in the selected package and ensures they have a tagged value Y with value Z. Add if missing. Include DRY_RUN, logging, and RefreshModelView.”\nExport template: “Write a JScript ES3 script that exports all elements in the selected package to CSV. Include ElementID, GUID, Name, Type, and Stereotype. Use FileSystemObject, ANSI safe. Comment every step.”\n\nBy maintaining these prompt templates, you save time and improve consistency.\n\n\nGuardrails in Prompts\nBecause EA is unforgiving (no undo, no rollback), guardrails are essential. Your prompt should explicitly require:\n\nDRY_RUN flag.\nUpdate() on changes.\nRefreshModelView() at the end.\nComments explaining each step.\nBackward deletion loops when deleting.\nLogs to Output or CSV.\n\nThink of these as non-negotiable. If AI fails to include them, ask it to add them.\n\n\nPrompting for Externals\nPrompt engineering also applies when you use AI for external automation. For example, you might ask for a Python script with pywin32 that connects to EA. The same principles apply: specify language, COM, bitness, safety, and logging.\nFor instance:\n\n\n\n\n\n\nNotePrompt\n\n\n\nWrite a Python 3 script using pywin32 to connect to EA. Traverse the selected package and print element names. Ensure it checks bitness (32-bit Python), and include error handling.\n\n\nBy being explicit, you avoid generic Python that won’t attach to EA.\n\n\nCommon Prompting Mistakes\nNew users often make the following mistakes:\n\nBeing vague: “Write a script to rename elements.” (AI invents code with forEach.)\nForgetting context: not mentioning EA or JScript, so AI writes browser JavaScript.\nSkipping safety: AI writes a script that modifies elements without dry-run.\nAccepting first output blindly: running unsafe code in production.\n\nEach of these can be avoided by careful prompting and iteration.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#prompt-engineering-as-team-practice",
    "href": "15-System.Object[].html#prompt-engineering-as-team-practice",
    "title": "Chapter 14: Prompt Engineering",
    "section": "Prompt Engineering as Team Practice",
    "text": "Prompt Engineering as Team Practice\nPrompt engineering is not just an individual skill. Teams can share prompt libraries alongside script libraries. For example, store templates in Git: one folder for prompts, one for scripts. This allows consistency across a team and accelerates onboarding for new members.\nTeams can also develop governance prompts: standard ways of asking AI to generate scripts that align with organisational policies.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#ai-literacy-for-modellers",
    "href": "15-System.Object[].html#ai-literacy-for-modellers",
    "title": "Chapter 14: Prompt Engineering",
    "section": "AI Literacy for Modellers",
    "text": "AI Literacy for Modellers\nNot every modeller will become a script writer. But every modeller can benefit from AI literacy. Even if you don’t run the scripts yourself, being able to ask AI for “the shape” of a script, review the comments, and discuss it with colleagues adds value. Prompt engineering is therefore not only for coders; it is part of the wider skillset of modern architecture teams.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#prompt-template",
    "href": "15-System.Object[].html#prompt-template",
    "title": "Chapter 14: Prompt Engineering",
    "section": "Prompt Template",
    "text": "Prompt Template\nHere’s a reliable template you can use when asking AI to generate an EA script:\n\n\n\n\n\n\nNotePrompt\n\n\n\nWrite a script for Sparx Enterprise Architect using JScript (ES3 only, no ES6 features).\nConstraints:\n- Use var (no let/const)\n- EA collections use .Count and .GetAt(i)\n- Use Session.Output for logging (not console.log)\n- Always call Update() after modifying objects\n- Include a DRY_RUN flag and verbose comments\nTask: [state the specific automation you want]",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#examples",
    "href": "15-System.Object[].html#examples",
    "title": "Chapter 14: Prompt Engineering",
    "section": "Examples",
    "text": "Examples\n\nList All Requirements\n\nPrompt\n\n\n\n\n\n\nNotePrompt\n\n\n\n“Write an EA JScript that lists all requirements in a selected package. ES3 only, no modern JS features. Include DRY_RUN and comments.”\n\n\n\n\nRaw AI Output (often wrong)\n// [x] Incorrect AI output\n\nlet pkg = Repository.GetTreeSelectedPackage();\n\nif (!pkg) { console.log(\"Select a package\"); }\n\npkg.Elements.forEach(e =\\&gt; console.log(e.Name));\nProblems:\n\nlet and arrow functions unsupported (ES3 only).\npkg.Elements is an EA collection, not an array (forEach will fail).\nconsole.log doesn’t exist in EA (use Session.Output).\n\n\n\nCorrected Script\n\n\nExample 14.1 - ListRequirements.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 14.1 - ListRequirements.js – JScript (ES3)\n// Purpose: List all Requirement elements in selected package\n// Safety: DRY_RUN pattern included (though not needed for read-only)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true; // Included for consistency\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) {\n        Session.Prompt(\"Select a package first.\", promptOK);\n        return;\n    }\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Requirement\") {\n            Session.Output(\"Requirement: \" + e.Name + \" (ID=\" + e.ElementID + \")\");\n        }\n    }\n}\n\nmain();\n\n\n\n\nBulk Prefix Naming\n\nPrompt\n\n\n\n\n\n\nNotePrompt\n\n\n\n“Write an EA JScript that renames all elements in a package by adding prefix ‘SYS_’. ES3 only, no modern JS features. Include DRY_RUN, logging, and RefreshModelView.”\n\n\n\n\nCorrected Script\n\n\n14.2 - BulkPrefixRename.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 14.2 - BulkPrefixRename.js – JScript (ES3)\n// Purpose: Add 'SYS_' prefix to element names in a selected package\n// Safety: DRY_RUN prevents accidental renaming\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var PREFIX = \"SYS_\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var changed=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Name.indexOf(PREFIX) != 0) {\n            var newName = PREFIX + e.Name;\n            Session.Output(\"Would rename: \" + e.Name + \" → \" + newName);\n            if (!DRY_RUN) {\n                e.Name = newName;\n                e.Update();\n                changed++;\n            }\n        }\n    }\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    Session.Output(\"Processed \" + els.Count + \" elements, changed \" + changed);\n}\n\nmain();\n\n\n\n\nAdd a Tagged Value with Defaults\n\nPrompt\n\n\n\n\n\n\nNotePrompt\n\n\n\n“Write an EA JScript that ensures all elements in a package have a tagged value ‘Owner=ArchitectureTeam’. ES3 only, no modern JS features. DRY_RUN and comments required.”\n\n\n\n\nCorrected Script\n\n\nExample 14.3 - EnsureTag_Owner.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 14.3 - EnsureTag_Owner.js – JScript (ES3)\n// Purpose: Add/update tagged value 'Owner=ArchitectureTeam' for all elements\n// Safety: DRY_RUN flag enabled\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var TAG_NAME = \"Owner\";\n    var TAG_VALUE = \"ArchitectureTeam\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var tags = e.TaggedValues;\n        var found = false;\n\n        for (var j=0; j&lt;tags.Count; j++) {\n            var t = tags.GetAt(j);\n            if (t.Name == TAG_NAME) {\n                found = true;\n                if (t.Value != TAG_VALUE) {\n                    Session.Output(\"Would update tag for \" + e.Name);\n                    if (!DRY_RUN) { t.Value = TAG_VALUE; t.Update(); e.Update(); }\n                }\n            }\n        }\n\n        if (!found) {\n            Session.Output(\"Would add tag for \" + e.Name);\n            if (!DRY_RUN) {\n                var nt = tags.AddNew(TAG_NAME, TAG_VALUE);\n                nt.Update(); e.Update();\n            }\n        }\n    }\n    if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);\n}\n\nmain();\n\n\n\n\nSafe Delete\n\nPrompt\n\n\n\n\n\n\nNotePrompt\n\n\n\n“Write an EA JScript that deletes all UseCase elements in a package. ES3 only, DRY_RUN by default, with logging.”\n\n\nCorrected Script\n\n\nExample 14.4 - SafeDelete_UseCases.js – JScript (ES3)\n\n“Write an EA JScript that deletes all UseCase elements in a package. ES3 only, DRY_RUN by default, with logging.”\nCorrected Script\n// -------------------------------------------------------\n// Example 14.4 - SafeDelete_UseCases.js – JScript (ES3)\n// Purpose: Delete all UseCase elements in a package\n// Safety: DRY_RUN by default; logs each candidate\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var TYPE_FILTER = \"UseCase\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    var deleted=0;\n    for (var i=els.Count-1; i&gt;=0; i--) { // iterate backwards\n        var e = els.GetAt(i);\n        if (e.Type == TYPE_FILTER) {\n            Session.Output(\"Would delete: \" + e.Name);\n            if (!DRY_RUN) {\n                els.DeleteAt(i, false); // false = don’t refresh each time\n                deleted++;\n            }\n        }\n    }\n    if (!DRY_RUN && deleted&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    Session.Output(\"Candidates: \" + els.Count + \" Deleted: \" + deleted + \" Dry-run=\" + DRY_RUN);\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#best-practices-for-prompts",
    "href": "15-System.Object[].html#best-practices-for-prompts",
    "title": "Chapter 14: Prompt Engineering",
    "section": "Best Practices for Prompts",
    "text": "Best Practices for Prompts\n\nAlways say: “EA JScript (ES3 only, no modern JS features)”.\nAlways request: DRY_RUN flag, verbose comments, and RefreshModelView.\nIf you want imports/exports: say “use ActiveX FileSystemObject”, not fs or modern Node.js.\nIf you need CSV/Excel: say “use COM automation for Excel”, not external modules.\nKeep prompts specific: “list all Requirements in a package” vs “list elements”.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "15-System.Object[].html#summary",
    "href": "15-System.Object[].html#summary",
    "title": "Chapter 14: Prompt Engineering",
    "section": "Summary",
    "text": "Summary\nPrompt engineering is about teaching the AI your constraints. By making your requests precise (JScript ES3, DRY_RUN, .Count/.GetAt(i)), you ensure the generated scripts run correctly in EA. AI will often hallucinate modern JS features; your job is to correct them systematically using the patterns in this chapter.\nIn the next chapter, we’ll explore Chapter 14 – AI as a Refactoring Partner: using AI to improve existing scripts by converting between languages, adding documentation headers, or reorganising code for readability and maintainability.",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Chapter 14: Prompt Engineering</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html",
    "href": "16-System.Object[].html",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "",
    "text": "Why Refactoring Matters in EA Scripting\nWriting new scripts from scratch is only part of the automation journey. In practice, most of the scripts you will encounter in Enterprise Architect are not greenfield creations. They are legacy fragments copied from colleagues, utilities downloaded from forums, or quick fixes you wrote six months ago and barely remember. Over time, these fragments accumulate into a patchwork library that works but is inconsistent, risky, and hard to maintain.\nRefactoring is the process of improving code without changing its intended behaviour. It is about making scripts more readable, more consistent, safer, and easier to share. For EA scripting, refactoring often means adding missing headers, introducing dry-run flags, standardising logging, or converting old VBScript into JScript.\nThis is where artificial intelligence comes into its own as a refactoring partner. While AI can generate new scripts, it is especially powerful at taking existing ones and restructuring them. Given clear instructions, it can modernise syntax, add comments, and apply safety patterns. Of course, AI cannot be trusted blindly, but with human oversight it becomes a force multiplier for improving script quality.\nThere are several reasons refactoring is essential:\nRefactoring turns a messy script into a clean, well-documented artefact that you can safely run and confidently share.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#why-refactoring-matters-in-ea-scripting",
    "href": "16-System.Object[].html#why-refactoring-matters-in-ea-scripting",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "",
    "text": "Consistency: a mixed library of VBScript and JScript makes it hard for teams to share and reuse.\nSafety: older scripts may lack dry-run flags or logging, making them risky.\nClarity: many scripts lack headers or comments, leaving future readers confused.\nMaintainability: scripts with inconsistent style are harder to debug or adapt.\nGovernance: in regulated environments, scripts must demonstrate safety and traceability.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#the-ai-advantage-in-refactoring",
    "href": "16-System.Object[].html#the-ai-advantage-in-refactoring",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "The AI Advantage in Refactoring",
    "text": "The AI Advantage in Refactoring\nTraditional refactoring is manual: you read old code, spot issues, and rewrite. AI can accelerate this by doing the heavy lifting:\n\nTranslate VBScript into JScript ES3.\nInsert a standard header block with purpose, usage, safety, and update history.\nReplace unsupported features (forEach, let, const) with EA-compatible constructs.\nAdd dry-run wrappers around destructive operations.\nInsert comments explaining each step.\n\nYou still need to review the output, but AI removes much of the tedium. Instead of spending hours rewriting loops, you can focus on reviewing safety and correctness.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#common-refactoring-needs",
    "href": "16-System.Object[].html#common-refactoring-needs",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "Common Refactoring Needs",
    "text": "Common Refactoring Needs\nIn EA scripting, the most frequent refactoring needs include:\n\nVBScript to JScript migration\nMany legacy scripts were written in VBScript. Translating them by hand is slow; AI can do it in seconds.\nAdding safety scaffolding\nScripts without dry-run or logging are dangerous. AI can wrap actions in if (!DRY_RUN) and add log statements.\nCommenting and documentation\nMany scripts are just raw code. AI can add structured comments that explain purpose and usage.\nStandardising patterns\nReplace ad-hoc loops with a Find/Filter/Apply structure. Replace forward deletion with backward deletion.\nSplitting monoliths\nSome scripts try to do too much at once. AI can help break them into smaller functions with clear responsibilities.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#risks-of-ai-refactoring",
    "href": "16-System.Object[].html#risks-of-ai-refactoring",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "Risks of AI Refactoring",
    "text": "Risks of AI Refactoring\nWhile AI is powerful, it is not infallible. Risks include:\n\nHallucinated methods: inserting functions that don’t exist in EA (e.g., .forEach).\nOver-modernisation: using ES6 syntax not supported in EA’s JScript ES3 runtime.\nSilent changes: accidentally altering behaviour while “refactoring.”\nOver-commenting: adding comments that explain the obvious but miss the critical.\n\nThat is why human review is non-negotiable. AI can propose changes, but you must check every line.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#a-humanai-workflow-for-refactoring",
    "href": "16-System.Object[].html#a-humanai-workflow-for-refactoring",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "A Human–AI Workflow for Refactoring",
    "text": "A Human–AI Workflow for Refactoring\nA safe refactoring workflow looks like this:\n\nSelect a script — choose one that needs improvement (e.g., lacks dry-run, VBScript only).\nPrompt AI clearly — specify: “Refactor this into JScript ES3, add DRY_RUN, add comments, keep functionality the same.”\nReview output — check loops, updates, stereotypes, and API calls.\nTest in sandbox — run dry-run mode on a small package.\nIterate — adjust prompt or script until correct.\nAdopt as standard — store the refactored script in Git with version history.\n\nThis workflow ensures that AI accelerates without undermining trust.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#ai-for-documentation-retrofitting",
    "href": "16-System.Object[].html#ai-for-documentation-retrofitting",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "AI for Documentation Retrofitting",
    "text": "AI for Documentation Retrofitting\nOne of the least glamorous but most valuable uses of AI is adding documentation headers. You can paste a bare script into AI and ask: “Add a standard EA script header with purpose, usage, assumptions, safety, dependencies, and update history.” AI will generate a block that matches the conventions established earlier in this book.\nOver time, this makes your library far more navigable. Anyone can open a script and know immediately what it does and how to use it.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#refactoring-for-governance",
    "href": "16-System.Object[].html#refactoring-for-governance",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "Refactoring for Governance",
    "text": "Refactoring for Governance\nRefactoring is not just a technical hygiene exercise; it supports governance. In many organisations, scripts themselves are part of the audit trail. Regulators may ask: how do you ensure automation is safe? Refactored scripts with dry-run, logs, and headers are evidence of governance in action.\nAI can help align scripts with these governance requirements, ensuring safety features are never omitted.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#beyond-ea-refactoring-across-languages",
    "href": "16-System.Object[].html#beyond-ea-refactoring-across-languages",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "Beyond EA: Refactoring Across Languages",
    "text": "Beyond EA: Refactoring Across Languages\nAlthough this chapter focuses on EA’s internal scripting, the same principles apply to external automation. AI can refactor Python scripts to improve logging, or C# scripts to adopt better patterns. The value of AI as a refactoring partner extends across the entire EA automation ecosystem.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#the-cultural-impact-of-refactoring-with-ai",
    "href": "16-System.Object[].html#the-cultural-impact-of-refactoring-with-ai",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "The Cultural Impact of Refactoring with AI",
    "text": "The Cultural Impact of Refactoring with AI\nWhen teams see that AI can quickly improve old scripts, they become more willing to use and share automation. Instead of hoarding fragile snippets, they submit them for refactoring. Over time, this raises the baseline quality of the entire script library.\nAI thus plays a cultural role: it makes refactoring less of a chore, more of a routine practice.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#examples",
    "href": "16-System.Object[].html#examples",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "Examples",
    "text": "Examples\n\nConverting VBScript to JScript\nMany older EA repositories contain VBScript snippets. These work, but are verbose and unfamiliar to modern developers. AI can help you convert them to JScript.\n\nOriginal VBScript\n' List all element names in selected package (VBScript)\n!INC Local Scripts.EAConstants-VBScript\n\nsub main()\n    dim pkg\n    set pkg = Repository.GetTreeSelectedPackage()\n    if pkg is nothing then\n        Session.Prompt \"Select a package.\", promptOK\n        exit sub\n    end if\n\n    dim els, i\n    set els = pkg.Elements\n    for i = 0 to els.Count - 1\n        Session.Output \"Element: \" & els.GetAt(i).Name\n    next\nend sub\n\nmain\n\n\nAI-Assisted Conversion (Corrected JScript)\n\n\nExample 15.1 - ListElements_JS.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 15.1 - ListElements_JS.js – JScript (ES3)\n// Purpose: Converted from VBScript using AI refactoring\n// Notes: ES3 only, no modern JS features\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) {\n        Session.Prompt(\"Select a package.\", promptOK);\n        return;\n    }\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        Session.Output(\"Element: \" + e.Name);\n    }\n}\n\nmain();\n\n\n\n\nAdding a Structured Header\nScripts often start life as quick hacks. Over time, they become hard to reuse because they lack documentation. AI can automatically generate a structured header in your house style.\n\nBefore (minimal)\nfunction main() {\n\nvar pkg = Repository.GetTreeSelectedPackage();\n\nif (!pkg) return;\n\nSession.Output(\"Selected package: \" + pkg.Name);\n\n}\n\nmain();\n\n\nAfter (AI-generated header + corrections)\n\n\nExample 15.2 - ShowSelectedPackage.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 15.2 - ShowSelectedPackage.js – JScript (ES3)\n// Purpose: Output the name of the selected package\n// Usage: Select a package in the Project Browser → run script\n// Assumptions: User selects a package; ES3 runtime only\n// Safety: Read-only, no modifications\n// Dependencies: none\n// Update history: 1.0 initial\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) {\n        Session.Prompt(\"Please select a package.\", promptOK);\n        return;\n    }\n    Session.Output(\"Selected package: \" + pkg.Name);\n}\n\nmain();\n\n\n\n\nRefactoring for Safety (Add DRY_RUN)\nAI can retrofit your script with dry-run and logging.\n\nOriginal Script (unsafe)\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        els.GetAt(i).Name = \"Test_\" + els.GetAt(i).Name;\n        els.GetAt(i).Update();\n    }\n    Repository.RefreshModelView(pkg.PackageID);\n}\nmain();\n\n\nRefactored with DRY_RUN\n\n\nExample 15.3 - SafeRename.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 15.3 - SafeRename.js – JScript (ES3)\n// Purpose: Prefix all element names with \"Test_\"\n// Safety: DRY_RUN enabled by default; logs actions\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var DRY_RUN = true;\n    var PREFIX = \"Test_\";\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var changed=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        var newName = PREFIX + e.Name;\n        Session.Output(\"Would rename: \" + e.Name + \" → \" + newName);\n        if (!DRY_RUN) {\n            e.Name = newName;\n            e.Update();\n            changed++;\n        }\n    }\n    if (!DRY_RUN && changed&gt;0) Repository.RefreshModelView(pkg.PackageID);\n    Session.Output(\"Total processed: \" + els.Count + \", Changed: \" + changed + \", Dry-run=\" + DRY_RUN);\n}\n\nmain();\n\n\n\n\nBreaking Down Monoliths\nAI can also split a long monolithic script into functions, making it easier to maintain.\n\nBefore (all inline)\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Requirement\" && e.Notes == \"\") {\n            Session.Output(\"Requirement missing notes: \" + e.Name);\n        }\n    }\n}\nmain();\n\n\nAfter (refactored into functions)\n\n\nExample 15.4 - CheckMissingNotes.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 15.4 - CheckMissingNotes.js – JScript (ES3)\n// Purpose: Report Requirements without notes\n// Refactored to improve maintainability\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = getSelectedPackage();\n    if (!pkg) return;\n\n    var els = pkg.Elements;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (isRequirementMissingNotes(e)) {\n            Session.Output(\"Requirement missing notes: \" + e.Name);\n        }\n    }\n}\n// Get the currently selected package, with safety check\nfunction getSelectedPackage() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) {\n        Session.Prompt(\"Select a package.\", promptOK);\n        return null;\n    }\n    return pkg;\n}\n// Check if element is a Requirement with empty notes\nfunction isRequirementMissingNotes(e) {\n    return e.Type == \"Requirement\" && trim(e.Notes) == \"\";\n}\nfunction trim(str) {\n    if (str == null) return \"\";\n    return String(str).replace(/^\\s+|\\s+$/g, \"\");\n}\n\nmain();",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "16-System.Object[].html#summary",
    "href": "16-System.Object[].html#summary",
    "title": "Chapter 15: AI Refactoring Partner",
    "section": "Summary",
    "text": "Summary\nAI is a powerful refactoring partner:\n\nLanguage conversion: VBScript → JScript → Python.\nDocumentation: auto-generate structured headers.\nSafety: add DRY_RUN, logs, and RefreshModelView.\nMaintainability: break monolithic scripts into functions.\n\nYou remain in control: AI does the heavy lifting, but you apply corrections to keep everything valid for EA’s JScript ES3 runtime.\nIn the next chapter, we’ll explore Chapter 15 – AI in Daily Workflow, showing how to build a prompt library and integrate AI-assisted scripting into your modelling practice.",
    "crumbs": [
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Chapter 15: AI Refactoring Partner</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html",
    "href": "17-System.Object[].html",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "",
    "text": "From Occasional Help to Daily Companion\nBy now we have seen how AI can help overcome the blank page problem, generate patterns, translate between languages, and refactor old scripts into safer, clearer versions. All of these uses are valuable, but they still treat AI as something you consult occasionally — a tool you dip into when you need help. The next step is to make AI part of your daily scripting workflow.\nThis means integrating AI into how you plan, write, document, and share scripts. It means building a personal or team “prompt library” that captures successful ways of asking for code. It means using AI to generate standard headers or loggers automatically. It means involving AI in version control, commit messages, and governance checks. When AI becomes part of your routine, it stops being an add-on and starts being a multiplier.\nThis chapter explains what it looks like to work with AI every day as a script writer or modelling architect. It shows how to build habits and structures that make AI useful without making you dependent. It also highlights the risks of over-reliance and the safeguards needed to maintain trust.\nFor most people, the first time they use AI for scripting is when they are stuck. They don’t know how to write a loop, or they have an old VBScript to translate, or they need a header quickly. That is a good start, but it is still reactive: AI is only consulted when there is a problem.\nDaily workflow means turning this reactive use into proactive integration. Instead of waiting until you are stuck, you design your process around AI from the start. For example:\nThe point is not that AI replaces your work, but that it saves you from repetitive effort and keeps you moving forward.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#from-occasional-help-to-daily-companion",
    "href": "17-System.Object[].html#from-occasional-help-to-daily-companion",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "",
    "text": "Every new script begins with an AI-generated header template.\nEvery new task begins with a search of your prompt library.\nEvery commit is accompanied by an AI-suggested message.\nEvery governance run is explained by an AI-drafted summary.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#the-role-of-a-prompt-library",
    "href": "17-System.Object[].html#the-role-of-a-prompt-library",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "The Role of a Prompt Library",
    "text": "The Role of a Prompt Library\nOne of the simplest but most effective habits is to maintain a prompt library. This is a set of carefully worded instructions you know produce reliable code. For example:\n\n“Write a JScript ES3 script for EA that traverses the selected package, loops with .Count/.GetAt(), and logs each element name to the Output tab. Include DRY_RUN.”\n“Translate this VBScript into JScript, preserving behaviour, adding DRY_RUN and logging.”\n“Refactor this script to use backward deletion loops.”\n\nBy reusing these prompts, you reduce the chance of errors and improve consistency. You also save time: instead of re-explaining EA’s quirks to AI each time, you paste a standard prompt and focus on the task.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#automating-boilerplate",
    "href": "17-System.Object[].html#automating-boilerplate",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "Automating Boilerplate",
    "text": "Automating Boilerplate\nA surprising amount of scripting effort goes into boilerplate: headers, loggers, dry-run wrappers, refresh calls. These are necessary for safety but repetitive to write. AI is very good at generating boilerplate.\nFor example, you might ask: “Generate a standard EA script header with fields for Purpose, Usage, Assumptions, Safety, Dependencies, and Update history.” AI will output a block you can paste at the top of every script. You can then refine it once and reuse it many times.\nSimilarly, you can ask AI to insert a standard logging helper or dry-run guard into existing scripts. Over time, this ensures all your scripts share a consistent structure.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#ai-as-a-debugging-partner",
    "href": "17-System.Object[].html#ai-as-a-debugging-partner",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "AI as a Debugging Partner",
    "text": "AI as a Debugging Partner\nAlthough EA’s scripting environment lacks a debugger, AI can serve as a debugging partner. When you get an error, you can paste the message and the relevant code into AI and ask: “Why does this fail in EA JScript?”\nAI will often spot issues like:\n\nUsing .forEach instead of .GetAt().\nForgetting .Update().\nUsing let or const instead of var.\n\nThis is not fool-proof, but it gives you quick feedback, reducing trial-and-error.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#integration-with-version-control",
    "href": "17-System.Object[].html#integration-with-version-control",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "Integration with Version Control",
    "text": "Integration with Version Control\nMany teams now keep their scripts in Git repositories. AI can support this workflow in several ways:\n\nCommit messages: generate clear, descriptive commit messages summarising what changed.\nCode reviews: provide first-pass feedback on whether a script follows safety conventions.\nRefactoring suggestions: highlight duplication across scripts.\n\nFor example, you might paste a diff into AI and ask: “Summarise these changes in a Git commit message.” It will return a concise summary you can tweak.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#governance-and-reporting",
    "href": "17-System.Object[].html#governance-and-reporting",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "Governance and Reporting",
    "text": "Governance and Reporting\nAI can also help with governance reporting. After running a governance script that logs issues to CSV, you can feed the results into AI and ask for a plain-English summary: “Explain the key issues found in this log and suggest actions.”\nThis does not replace human judgement, but it makes governance outputs easier to digest. Stakeholders see not just a list of IDs but an interpretation.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#risks-of-daily-ai-use",
    "href": "17-System.Object[].html#risks-of-daily-ai-use",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "Risks of Daily AI Use",
    "text": "Risks of Daily AI Use\nDaily use of AI brings its own risks:\n\nComplacency: relying on AI to generate boilerplate without understanding it.\nOver-reliance: forgetting how to write basic loops yourself.\nFalse trust: assuming AI output is always safe.\nData exposure: pasting sensitive content into AI without considering confidentiality.\n\nTo mitigate these risks, you should:\n\nContinue practising core scripting skills.\nReview AI output critically.\nUse internal AI deployments where data sensitivity is an issue.\nKeep your own library of trusted patterns.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#ai-as-a-team-enabler",
    "href": "17-System.Object[].html#ai-as-a-team-enabler",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "AI as a Team Enabler",
    "text": "AI as a Team Enabler\nAI is not only useful for individuals. Teams can adopt it as a shared resource. For example:\n\nStore prompt templates in the same Git repo as scripts.\nAgree on standard AI guardrails (always include DRY_RUN, never use direct SQL writes).\nUse AI to explain scripts to non-technical colleagues.\n\nThis makes scripting more inclusive. Analysts who cannot code fluently can still understand and contribute by using AI as an interpreter.\n\nBuilding Habits\nThe key to making AI part of your daily workflow is to build habits:\n\nStart every new script with an AI-generated header.\nAlways run prompts through your standard templates.\nUse AI for documentation and commit messages.\nReview output in dry-run mode before trusting it.\n\nHabits ensure consistency and reduce the cognitive load. You don’t have to remember every detail — the process takes care of it.\n\n\nBuild a Prompt Library\nWhen you find a prompt that works, don’t rely on memory — save it. Treat prompts like reusable code snippets. Keep them in a text file, Git repository, or even within EA as a script comment block.\n\nPrompt snippet saved for reuse\n\n\n\n\n\n\nNotePrompt\n\n\n\nPrompt: Write a script for Sparx Enterprise Architect using JScript (ES3 only).\nConstraints:\n- Use var (no let/const)\n- EA collections require .Count and .GetAt(i)\n- Use Session.Output (not console.log)\n- Always call Update() after changes\n- Include DRY_RUN flag and verbose comments\nTask: List all Requirement names in a selected package.\n\n\n\n\n\nUse AI for Boilerplate\nInstead of re-typing headers or dry-run scaffolding, ask AI to insert the standard structure for you.\n\n\nExample 16.1 - ListRequirements.js\n\n// -------------------------------------------------------\n// Example 16.1 - ListRequirements.js\n// Purpose: Output names of Requirement elements in a package\n// Usage: Select a package in Project Browser → run\n// Assumptions: JScript ES3 runtime\n// Safety: Read-only\n// Dependencies: none\n// Update history: 1.0 initial\n// -------------------------------------------------------\n\nThis header can be generated by AI in seconds and keeps your scripts consistent.\n\n\nUse AI for Daily Queries\nYou don’t need to remember every API call. Ask AI things like:\n\n“How do I get all connectors from an element in EA JScript?”\n“Show me how to create a new attribute on a class.”\n“How do I output the selected diagram’s objects?”\n\nAI can provide scaffolding, but you must correct it for EA’s environment.\n\n\nDaily Script with AI Template\nSuppose you often need to list tagged values of selected elements. Save a reusable script pattern, which AI can adapt for other tasks.\n\n\nExample 16.2 - ListTaggedValues.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 16.2 - ListTaggedValues.js – JScript (ES3)\n// Purpose: Show all tagged values for the selected element\n// Usage: Select element in Project Browser → run script\n// Safety: Read-only\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var el = Repository.GetTreeSelectedObject();\n    if (!el || el.ObjectType != otElement) {\n        Session.Prompt(\"Select an element first.\", promptOK);\n        return;\n    }\n\n    var tags = el.TaggedValues;\n    if (tags.Count == 0) {\n        Session.Output(\"No tagged values on \" + el.Name);\n        return;\n    }\n\n    for (var i=0; i&lt;tags.Count; i++) {\n        var tv = tags.GetAt(i);\n        Session.Output(\"Tag: \" + tv.Name + \" = \" + tv.Value);\n    }\n}\n\nmain();\n\nWhen you need a variation (e.g. export tags to CSV, update missing tags), prompt AI with “adapt ListTaggedValues.js to write tags to a CSV file, ES3 only”.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#git-ai-workflow",
    "href": "17-System.Object[].html#git-ai-workflow",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "Git + AI Workflow",
    "text": "Git + AI Workflow\nVersion-control your scripts with Git (or even OneDrive). AI can:\n\nGenerate commit messages (“Add dry-run safety to SafeRename script”).\nSuggest code reviews (“Highlight where Update() is missing”).\nPropose refactors across multiple scripts.\n\n\nCommit message prompt\n\n\n\n\n\n\nNotePrompt\n\n\n\nPrompt: Write a Git commit message for adding DRY_RUN safety and CSV logging to BulkPrefixRename.js",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#ai-assisted-governance-check",
    "href": "17-System.Object[].html#ai-assisted-governance-check",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "AI-Assisted Governance Check",
    "text": "AI-Assisted Governance Check\nDaily workflows often involve governance (naming rules, tags, traceability). Here’s a pattern you can copy, extend, and ask AI to adapt.\n\n\nExample 16.3 - DailyGovernanceCheck.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 16.3 - DailyGovernanceCheck.js – JScript (ES3)\n// Purpose: Report Requirements missing 'Owner' tag\n// Safety: Read-only; logs only\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main() {\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var els = pkg.Elements;\n    var missing=0;\n    for (var i=0; i&lt;els.Count; i++) {\n        var e = els.GetAt(i);\n        if (e.Type == \"Requirement\" && !hasTag(e,\"Owner\")) {\n            missing++;\n            Session.Output(\"Requirement missing Owner tag: \" + e.Name);\n        }\n    }\n    Session.Output(\"Governance check: \" + missing + \" missing tags.\");\n}\n\nfunction hasTag(e, tagName) {\n    var tags = e.TaggedValues;\n    for (var i=0; i&lt;tags.Count; i++) {\n        var t = tags.GetAt(i);\n        if (t.Name == tagName) return true;\n    }\n    return false;\n}\n\nTomorrow, you might ask AI:\n“Extend DailyGovernanceCheck.js to add the tag if missing, with default value ‘ArchitectureTeam’. Keep DRY_RUN enabled.”\nAI can refactor this for you, but you must validate the code against EA’s constraints.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "17-System.Object[].html#summary",
    "href": "17-System.Object[].html#summary",
    "title": "Chapter 16: AI in Daily Workflow",
    "section": "Summary",
    "text": "Summary\nAI becomes part of your daily workflow when you:\n\nSave prompt libraries for reuse.\nUse AI to generate boilerplate headers and scaffolding.\nAsk natural-language API queries instead of memorising details.\nMaintain scripts in Git, with AI suggesting commit messages and refactors.\nStart from a daily pattern script (like tagged value checks), and let AI adapt it to new use cases.\n\nThe key is consistency: you are the architect, AI is your assistant. By building repeatable workflows around AI, you gain speed and safety without losing control.",
    "crumbs": [
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Chapter 16: AI in Daily Workflow</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html",
    "href": "18-System.Object[].html",
    "title": "Chapter 17: Performance & Scaling",
    "section": "",
    "text": "Why Performance Matters\nEnterprise Architect is used in contexts that range from small projects to national architectures. In small repositories with a few hundred elements, scripting feels instant and forgiving. But as repositories grow to tens of thousands or even hundreds of thousands of elements, performance becomes a real concern. A script that works perfectly in a sandbox may take hours, or even crash EA, when run against an enterprise-scale repository.\nThis chapter explores the principles of performance and scaling in EA scripting. It explains why large repositories behave differently, why naive loops and excessive logging cause problems, and how to design scripts that handle scale safely. The goal is not to turn you into a performance engineer, but to provide practical strategies that let your scripts run efficiently on real-world repositories.\nAt first glance, performance might seem secondary. After all, scripts are automation — even if they take a few minutes, they still save hours of manual effort. But in practice, performance is about more than speed. Poorly written scripts can:\nPerformance is therefore about reliability as well as speed. Scripts that scale are scripts that can be trusted.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#why-performance-matters",
    "href": "18-System.Object[].html#why-performance-matters",
    "title": "Chapter 17: Performance & Scaling",
    "section": "",
    "text": "Lock up EA’s UI, frustrating other users.\nGenerate incomplete results, skipping elements when loops break.\nProduce overwhelming logs, flooding the Output tab and crashing EA.\nTime out in enterprise workflows, failing integration pipelines.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#sources-of-slowness",
    "href": "18-System.Object[].html#sources-of-slowness",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Sources of Slowness",
    "text": "Sources of Slowness\nThere are a few common culprits for slow scripts:\n\nUI logging: Session.Output is surprisingly expensive when called thousands of times.\nInefficient traversal: deep recursion or redundant queries slow scripts down.\nExcessive updates: calling .Update() unnecessarily adds overhead.\nUnfiltered loops: traversing everything when only a subset is needed.\nSQL misuse: failing to use SQL for large reads, or misusing SQL for writes.\n\nUnderstanding these bottlenecks is the first step to avoiding them.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#measure-first",
    "href": "18-System.Object[].html#measure-first",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Measure First",
    "text": "Measure First\nThe golden rule of performance is: measure before you optimise. In scripting, this means timing your loops and logging throughput. For example, processing 10,000 elements in 5 seconds is healthy; in 50 minutes, it is not. By measuring, you can identify where the script spends most of its time.\nIn practice, you can use simple timers (Date().getTime() in JScript) to record how long operations take. Always include performance metrics in your logs.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#tips",
    "href": "18-System.Object[].html#tips",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Tips",
    "text": "Tips\n\nSQL for Find, API for Write\nOne of the most effective performance strategies is:\n\nFind with SQL: use Repository.SQLQuery to locate candidates quickly.\nWrite with API: use EA’s object model for updates, ensuring integrity.\n\nSQL queries are far faster than traversing the entire package tree with .Count/.GetAt(). But writing directly via SQL risks corruption. The combination of SQL reads and API writes gives the best of both worlds.\n\n\nChunking Updates\nLarge updates should be chunked. Updating thousands of elements in one continuous loop can overwhelm EA’s UI and lock it up. Instead, process in batches — for example, 250 elements at a time — and refresh the model view between batches.\nThis chunking approach improves responsiveness and reduces the risk of EA appearing frozen. It also makes logs easier to review.\n\n\nIterative Traversal\nRecursion is elegant but risky in large models. Deep package trees can hit recursion limits or create excessive stack usage. Iterative traversal using a queue (breadth-first) is safer and more scalable. It avoids call-stack overflows and makes the traversal logic clearer.\n\n\nIdempotence and Skipping\nPerformance is not only about speed but also about avoiding unnecessary work. If an element already has the correct stereotype or tag, there is no need to update it. Idempotent scripts — those that skip items already in the correct state — run faster and reduce risk.\n\n\nLogging Without Flooding\nLogging is vital for safety, but excessive logging kills performance. Writing 50,000 lines to EA’s Output tab can freeze the tool. The safe practice is to log summary to Output and details to CSV. This gives you transparency without choking the UI.\n\n\nExternal Automation for Heavy Jobs\nSometimes the best way to scale is to move heavy jobs outside EA. External automation in Python or C# can handle large CSVs, JSON, or analytics, leaving EA to focus on updates. Splitting work this way makes scripts leaner and safer.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#principles",
    "href": "18-System.Object[].html#principles",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Principles",
    "text": "Principles\n\nMeasure: time the script and log throughput (items/sec).\nReduce UI overhead: write to a file (CSV) instead of spamming Output; refresh UI only once at the end or per large batch.\nFind with SQL, write with API: SQL is fast for locating candidates; API is safe for updates.\nChunk: commit changes in batches (e.g., 250); between batches, give EA a chance to breathe (optional UI refresh).\nIterative traversal: avoid deep recursion; use a queue/stack to walk package trees.\nBe idempotent: skip items already in the desired state.\nNo parallelism: EA’s COM server is single-threaded STA—concurrency won’t help.\n\nAll examples below are ES3 and assume no shared helper file; each script includes its own minimal helpers.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#examples",
    "href": "18-System.Object[].html#examples",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Examples",
    "text": "Examples\n\nMicro-helpers (copy/paste as needed)\n\n\nExample 17.1 - perf_helpers.js (inline for each example)\n\n// -------------------------------------------------------\n// Example 17.1 - perf_helpers.js (inline for each example)\n// -------------------------------------------------------\nfunction nowMs(){ return (new Date()).getTime(); }\nfunction trim(s){ return s==null?\"\":String(s).replace(/^\\s+|\\s+$/g,\"\"); }\nfunction equalsIgnoreCase(a,b){ return String(a||\"\").toLowerCase()==String(b||\"\").toLowerCase(); }\nfunction startsWith(s,p){ return String(s||\"\").indexOf(p)===0; }\n\n// Directory chooser (directory only; no filenames)\nfunction pickFolder(promptText){\n  var sh = new ActiveXObject(\"Shell.Application\");\n  var f = sh.BrowseForFolder(0, promptText, 0, 0);\n  return f ? f.Self.Path : null;\n}\n\n// CSV writer (lightweight)\nfunction Csv(path){\n  var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n  var file = fso.OpenTextFile(path, 8 /*Append*/, true /*Create*/);\n  this.w = function(line){ file.WriteLine(line); };\n  this.close = function(){ file.Close(); };\n}\n\n\n### Pattern A —Timing Harness & Low-noise Logging\n\n**Goal:** measure total time, throughput, and avoid slow Session.Output\nloops.\n```{.js filename=\"Example 17.2 - Perf_TimingHarness.js – JScript (ES3)\"}\n// Example 17.2 - Perf_TimingHarness.js – JScript (ES3)\n// Purpose: Run any loop with minimal UI logging + CSV metrics\n// Usage: Select any package (context not required for the demo)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction nowMs(){ return (new Date()).getTime(); }\nfunction pickFolder(t){ var sh=new ActiveXObject(\"Shell.Application\"); var f=sh.BrowseForFolder(0,t,0,0); return f?f.Self.Path:null; }\nfunction Csv(path){ var fso=new ActiveXObject(\"Scripting.FileSystemObject\"); var f=fso.OpenTextFile(path,8,true); this.w=function(l){f.WriteLine(l);}; this.close=function(){f.Close();}; }\n\nfunction main(){\n  var outDir = pickFolder(\"Select output folder for perf log\");\n  if(!outDir){ Session.Prompt(\"Cancelled.\", promptOK); return; }\n\n  var stamp = (new Date()).getTime();\n  var csv = new Csv(outDir+\"\\\\perf_metrics_\"+stamp+\".csv\");\n  csv.w(\"Metric,Value\");\n\n  var T0 = nowMs();\n  var N  = 20000; // simulate 20k lightweight ops (replace with real loop)\n  var i;\n  for(i=0;i&lt;N;i++){\n    // do nothing (placeholder for your per-item work)\n    // avoid Session.Output inside hot loops\n  }\n  var dt = nowMs()-T0;\n  var perSec = (N&gt;0)? Math.round((N*1000.0)/dt) : 0;\n\n  csv.w(\"Items,\"+N);\n  csv.w(\"Millis,\"+dt);\n  csv.w(\"Throughput_items_per_sec,\"+perSec);\n  csv.close();\n\n  Session.Output(\"Done. Items=\"+N+\" Time(ms)=\"+dt+\" Throughput=\"+perSec+\"/s\");\n}\nmain();\n\n\nAdapt: wrap your actual processing loop and keep Output to a few lines.\nFor detailed logs, write to CSV instead.\n\n### Pattern B — SQL-Accelerated Find, API-Safe Write (with chunking)\n\n**Use case:** set a stereotype on all **Class** elements missing one,\nacross the repository.  \n**Approach:**\n\n1.  **SQLQuery** all candidate IDs (fast).\n\n2.  Process in **chunks of 250**; call Update() per element, refresh UI\n    only per chunk or once at the end.\n\n3.  **DRY_RUN** for safety.\n```{.js filename=\"Example 17.3 - Perf_SqlFind_ApiWrite_Chunked.js – JScript (ES3)\"}\n// -------------------------------------------------------\n// Example 17.3 - Perf_SqlFind_ApiWrite_Chunked.js – JScript (ES3)\n// Purpose: Fast find via SQL, chunked updates via API\n// Safety: DRY_RUN = true by default\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction nowMs(){ return (new Date()).getTime(); }\nfunction pickFolder(t){ var sh=new ActiveXObject(\"Shell.Application\"); var f=sh.BrowseForFolder(0,t,0,0); return f?f.Self.Path:null; }\nfunction Csv(path){ var fso=new ActiveXObject(\"Scripting.FileSystemObject\"); var f=fso.OpenTextFile(path,8,true); this.w=function(l){f.WriteLine(l);}; this.close=function(){f.Close();}; }\n\nfunction extractAll(h,openTag,closeTag){\n  var res=[], start=0;\n  while(true){\n    var i=h.indexOf(openTag,start); if(i&lt;0) break;\n    var j=h.indexOf(closeTag,i+openTag.length); if(j&lt;0) break;\n    res.push(h.substring(i+openTag.length,j));\n    start=j+closeTag.length;\n  }\n  return res;\n}\n\nfunction main(){\n  var DRY_RUN = true;\n  var TYPE_FILTER = \"Class\";\n  var TARGET_STEREO = \"DomainObject\";\n  var CHUNK = 250;\n\n  var outDir = pickFolder(\"Select output folder for change log\");\n  if(!outDir){ Session.Prompt(\"Cancelled.\", promptOK); return; }\n  var stamp=(new Date()).getTime();\n  var csv=new Csv(outDir+\"\\\\chunked_changes_\"+stamp+\".csv\");\n  csv.w(\"Action,ElementID,Name,OldStereo,NewStereo\");\n\n  var t0=nowMs();\n  // 1) fast find: candidates with empty stereotype (rough pre-filter)\n  var sql=\"SELECT Object_ID, Name, Stereotype FROM t_object WHERE Object_Type='\"+TYPE_FILTER+\"' AND (Stereotype IS NULL OR Stereotype='')\";\n  var xml=Repository.SQLQuery(sql);\n  var ids=extractAll(xml,\"&lt;Object_ID&gt;\",\"&lt;/Object_ID&gt;\");\n  var count=ids.length;\n  Session.Output(\"Candidates: \"+count);\n\n  var applied=0, batch=0, processed=0;\n  var i;\n  for(i=0;i&lt;count;i++){\n    var id=parseInt(ids[i],10);\n    var e=Repository.GetElementByID(id);\n    if(!e) continue;\n\n    // double-check to avoid redundant writes\n    var oldStereo=String(e.Stereotype||\"\");\n    if(oldStereo===\"\"){\n      csv.w((DRY_RUN?\"DRY_RUN\":\"SET\") + \",\" + e.ElementID + \",\" + e.Name + \",\" + oldStereo + \",\" + TARGET_STEREO);\n      if(!DRY_RUN){ e.Stereotype = TARGET_STEREO; e.Update(); applied++; }\n      batch++;\n    }\n\n    processed++;\n\n    // chunk boundary\n    if(batch&gt;=CHUNK){\n      // optional: rare refresh so the UI doesn't feel stale\n      if(!DRY_RUN && applied&gt;0) Repository.RefreshModelView(0);\n      batch=0;\n    }\n  }\n\n  if(!DRY_RUN && applied&gt;0) Repository.RefreshModelView(0);\n  csv.close();\n\n  var dt=nowMs()-t0;\n  var rps = processed&gt;0 ? Math.round(1000.0*processed/dt) : 0;\n  Session.Output(\"Processed=\"+processed+\" Applied=\"+applied+\" Time(ms)=\"+dt+\" Throughput=\"+rps+\"/s DRY_RUN=\"+DRY_RUN);\n}\nmain();\n\nWhy it’s fast: the find phase is one SQL call. The write phase avoids extra lookups and refreshes only in large intervals.\n\n\nPattern C — Iterative Package Traversal (no recursion)\nRecursive tree walks can hit call-stack limits and are slower than a simple queue. This breadth-first traversal scales better.\n\n\nExample 17.4 - Perf_PackageWalk_Iterative.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 17.4 - Perf_PackageWalk_Iterative.js – JScript (ES3)\n// Purpose: Walk an entire package tree without recursion\n// Action: Count elements by type (as an example)\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction main(){\n  var pkg = Repository.GetTreeSelectedPackage();\n  if(!pkg){ Session.Prompt(\"Select a root package.\", promptOK); return; }\n\n  var queue=[pkg];\n  var typeCount = {}; // map type -&gt; number\n\n  while(queue.length&gt;0){\n    var p = queue.shift();\n\n    // enqueue children\n    var kids = p.Packages;\n    for(var i=0;i&lt;kids.Count;i++){ queue.push(kids.GetAt(i)); }\n\n    // tally elements\n    var els = p.Elements;\n    for(var j=0;j&lt;els.Count;j++){\n      var e = els.GetAt(j);\n      var t = e.Type;\n      typeCount[t] = (typeCount[t]||0)+1;\n    }\n  }\n\n  // low-noise summary output\n  Session.Output(\"Element counts by Type:\");\n  var k; for(k in typeCount){ if(typeCount.hasOwnProperty(k)){ Session.Output(\"  \"+k+\": \"+typeCount[k]); } }\n}\nmain();\n\nWhy it’s scalable: avoids deep call stacks and allocates a tiny queue instead of many temporary stacks frames.\n\n\nPattern D — Large CSV Apply (streaming + batching)\nReading a giant CSV and applying changes? Keep parsing simple, skip unchanged rows, and batch writes.\n\n\nExample 17.5 - Perf_CsvApply_Batched.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 17.5 - Perf_CsvApply_Batched.js – JScript (ES3)\n// Purpose: Apply safe updates from a curated CSV with batching\n// CSV columns (example): Apply,ElementID,NewStatus\n// Safety: Only Apply=YES rows execute; chunk writes; minimal UI refresh\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction trim(s){ return s==null?\"\":String(s).replace(/^\\s+|\\s+$/g,\"\"); }\nfunction pickFolder(t){ var sh=new ActiveXObject(\"Shell.Application\"); var f=sh.BrowseForFolder(0,t,0,0); return f?f.Self.Path:null; }\nfunction endsWith(s,suf){ s=String(s||\"\"); var i=s.lastIndexOf(suf); return i&gt;=0 && i+suf.length==s.length; }\n\nfunction main(){\n  var DRY_RUN = true;\n  var CHUNK = 250;\n\n  var dir = pickFolder(\"Select folder containing curated CSV\");\n  if(!dir){ Session.Prompt(\"Cancelled.\", promptOK); return; }\n\n  // Pick the newest CSV in the folder by a known prefix (customize if needed)\n  var fso=new ActiveXObject(\"Scripting.FileSystemObject\");\n  var folder=fso.GetFolder(dir);\n  var en=new Enumerator(folder.Files);\n  var newest=null, t=0;\n  for(;!en.atEnd(); en.moveNext()){\n    var f=en.item();\n    if(endsWith(f.Name.toLowerCase(), \".csv\")){\n      var m=f.DateLastModified.getTime();\n      if(m&gt;t){ newest=f; t=m; }\n    }\n  }\n  if(!newest){ Session.Prompt(\"No CSV found.\", promptOK); return; }\n\n  var ts=fso.OpenTextFile(newest.Path,1); // ForReading\n  // header\n  if(!ts.AtEndOfStream) ts.ReadLine();\n\n  var applied=0, considered=0, batch=0;\n  while(!ts.AtEndOfStream){\n    var line=ts.ReadLine();\n    if(trim(line)===\"\") continue;\n    // naive split (keep curation fields simple—avoid commas in cells)\n    var cells=line.split(\",\");\n    if(cells.length&lt;3) continue;\n\n    var apply=trim(cells[0]);\n    var eid = parseInt(cells[1],10);\n    var newStatus = trim(cells[2]);\n\n    considered++;\n\n    if(equalsIgnoreCase(apply,\"YES\") && eid&gt;0){\n      var e = Repository.GetElementByID(eid);\n      if(e && String(e.Status||\"\") != newStatus){\n        if(!DRY_RUN){ e.Status=newStatus; e.Update(); applied++; }\n        batch++;\n      }\n    }\n\n    if(batch&gt;=CHUNK){\n      if(!DRY_RUN && applied&gt;0) Repository.RefreshModelView(0);\n      batch=0;\n    }\n  }\n  ts.Close();\n\n  if(!DRY_RUN && applied&gt;0) Repository.RefreshModelView(0);\n  Session.Output(\"CSV apply complete. Considered=\"+considered+\" Applied=\"+applied+\" DRY_RUN=\"+DRY_RUN);\n}\nmain();\n\nWhy it scales: minimal parsing, batched writes, rare refreshes, and no per-row UI logs.\n\n\nPattern E — Repository-wide “Exists?” checks via SQL\nBefore creating a new element (or relationship), prove it doesn’t already exist—using a quick SQL existence test.\n\n\nExample 17.6 - Perf_ExistsCheck_SQL.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 17.6 - Perf_ExistsCheck_SQL.js – JScript (ES3)\n// Purpose: Quick existence test for (Name,Type)\n// Note: Adjust SQL for your DB if needed; this is generic enough for most back-ends\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction esc(s){ return String(s||\"\").replace(/'/g, \"''\"); }\nfunction between(h,a,b){ var i=h.indexOf(a); if(i&lt;0)return\"\"; var j=h.indexOf(b,i+a.length); return j&lt;0?\"\":h.substring(i+a.length,j); }\n\nfunction existsByNameType(name, type){\n  var sql=\"SELECT TOP 1 Object_ID FROM t_object WHERE Name='\"+esc(name)+\"' AND Object_Type='\"+esc(type)+\"'\";\n  var xml=Repository.SQLQuery(sql);\n  var id=between(xml,\"&lt;Object_ID&gt;\",\"&lt;/Object_ID&gt;\");\n  return id!==\"\";\n}\n\nfunction main(){\n  var found = existsByNameType(\"Customer\",\"Class\");\n  Session.Output(\"Customer/Class exists? \"+(found?\"YES\":\"NO\"));\n}\nmain();\n\nPerformance tip: do this before expensive creation logic, especially inside large importers.\n\n\nPattern F — External Python for Heavy Lifting\nWhen processing very large updates with lots of text/CSV/JSON parsing, use Python for the parsing, then EA’s API for the write boundary. (Bitness note from earlier chapters: use 32-bit Python to match EA.)\n\n\nExample 17.6 - Perf_ExistsCheck_SQL.js – JScript (ES3)\n\n# -------------------------------------------------------\n# Example 17.7 - perf_apply_large_external.py – Python 3 (pywin32)\n# Purpose: Chunked status updates from a big CSV, with guards\n# Usage: python perf_apply_large_external.py input.csv\n# -------------------------------------------------------\nimport sys, csv, win32com.client\n\nCHUNK = 500\n\ndef main(path):\n    ea = win32com.client.Dispatch(\"EA.App\")\n    repo = ea.Repository\n\n    applied = 0\n    batch = 0\n\n    with open(path, newline=\"\", encoding=\"utf-8\") as f:\n        rdr = csv.DictReader(f)\n        for row in rdr:\n            if str(row.get(\"Apply\",\"\")).strip().lower() != \"yes\":\n                continue\n            eid = int(row[\"ElementID\"])\n            status = row.get(\"NewStatus\",\"\").strip()\n            if not status:\n                continue\n\n            e = repo.GetElementByID(eid)\n            if e and str(e.Status or \"\") != status:\n                e.Status = status\n                e.Update()\n                applied += 1\n                batch  += 1\n\n            if batch &gt;= CHUNK:\n                repo.RefreshModelView(0)\n                batch = 0\n\n    if applied:\n        repo.RefreshModelView(0)\n    print(f\"Applied={applied}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv)&lt;2:\n        print(\"Usage: perf_apply_large_external.py &lt;input.csv&gt;\")\n    else:\n        main(sys.argv[1])\n\nWhy it’s fast: Python’s CSV is robust; you perform only the necessary EA updates, chunked with rare refreshes.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#dos-donts-cheat-sheet",
    "href": "18-System.Object[].html#dos-donts-cheat-sheet",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Dos & Don’ts (cheat-sheet)",
    "text": "Dos & Don’ts (cheat-sheet)\n\nDo: SQL for find, API for write.\nDo: Log to file instead of spamming Output.\nDo: Refresh UI once (or per big batch).\nDo: Short-circuit when the target state is already correct.\nDon’t: Recursively walk deep trees—prefer an iterative queue.\nDon’t: Multi-thread COM calls to EA—stick to single-threaded.\nDon’t: Write via SQL unless you fully understand EA’s schema (read-only SQL is fine; writes are risky).",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "18-System.Object[].html#putting-it-together",
    "href": "18-System.Object[].html#putting-it-together",
    "title": "Chapter 17: Performance & Scaling",
    "section": "Putting It Together",
    "text": "Putting It Together\nFor a large governance fix (e.g., add missing stereotype on 40k classes):\n\nTiming Harness: wrap the whole run and log metrics.\nSQL Find: one query for candidate IDs.\nChunked Apply: update in batches of ~250–500.\nLow-noise logging: a single CSV with “what changed.”\nOne refresh at the end (or per batch).\n\nFollowing these steps keeps your scripts fast enough for enterprise-scale repositories and safe enough for governance.",
    "crumbs": [
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Chapter 17: Performance & Scaling</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html",
    "href": "19-System.Object[].html",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "",
    "text": "Why Integration Matters\nEnterprise Architect is a powerful modelling tool, but if kept in isolation it risks becoming a silo. Models are valuable only when they connect to the wider enterprise environment — to planning tools, collaboration platforms, version control systems, registries, and analytics pipelines. Architects may capture brilliant structures in EA, but if those structures cannot be accessed by colleagues in Jira, shared in Confluence, tracked in Git, or exported to analytics platforms, then their impact is limited.\nThis chapter explores the role of scripting and automation in integrating EA with enterprise workflows. It explains why integration matters, what types of systems are typically involved, and how automation bridges the gap. It also discusses the cultural implications: how integration makes models more visible, improves collaboration, and embeds architecture more deeply into organisational processes.\nIn most organisations, EA is not the system of record for requirements, issues, or tasks. Those live in Jira, Azure DevOps, or ServiceNow. Nor is EA the publishing platform for architecture views — that role is filled by Confluence, SharePoint, or custom portals. Nor is EA the analytics engine — data warehouses and BI tools play that part.\nIf EA is to have influence, it must connect. Integration ensures that architecture does not sit in a closed repository but flows into the daily tools of developers, analysts, managers, and executives. It turns EA from a specialist tool into part of the wider enterprise nervous system.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#the-role-of-automation-in-integration",
    "href": "19-System.Object[].html#the-role-of-automation-in-integration",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "The Role of Automation in Integration",
    "text": "The Role of Automation in Integration\nManual integration is possible but unsustainable. You could export CSVs by hand, paste diagrams into Confluence, or retype requirements into Jira. But these manual steps are slow, error-prone, and quickly abandoned.\nAutomation transforms integration into a repeatable, reliable process. Scripts can pull requirements from Jira nightly, export model summaries to Confluence weekly, or commit EA script libraries into Git with every change. Automation eliminates the friction that often prevents integration from sticking.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#common-integration-targets",
    "href": "19-System.Object[].html#common-integration-targets",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Common Integration Targets",
    "text": "Common Integration Targets\nThe most frequent systems EA needs to connect with are:\n\nJira / Azure DevOps — for requirements, user stories, and tasks.\nConfluence / SharePoint — for publishing models, governance reports, and guidance.\nGit / Version Control — for managing scripts, MDGs, and sometimes even model fragments.\nRegistries / Catalogs — for synchronising metadata (applications, datasets, services).\nAnalytics Platforms — for reporting, dashboards, and quality metrics.\n\nEach of these integrations has different requirements, but the principle is the same: use scripts to extract, transform, and push or pull data.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#integration-approaches",
    "href": "19-System.Object[].html#integration-approaches",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Integration Approaches",
    "text": "Integration Approaches\n\nIntegration via Exports\nThe simplest form of integration is export. Scripts can export EA content to CSV, JSON, or XML, which is then consumed by another system. For example:\n\nExporting all Applications and their Owners to CSV for import into a CMDB.\nExporting requirements to JSON for loading into Jira.\nExporting governance reports to HTML for Confluence publishing.\n\nExport-based integration is one-way but powerful. It is often the first step towards tighter two-way sync.\n\n\nIntegration via APIs\nMore advanced integration uses APIs. Many enterprise systems (Jira, Confluence, ServiceNow) expose REST APIs. External EA scripts in Python or C# can call these APIs to push or pull data in real time. For example:\n\nA Python script reads new Jira issues and creates EA Requirements.\nA C# utility pushes EA diagrams as images into Confluence pages.\nA script updates ServiceNow CMDB records based on EA application data.\n\nAPI integration requires authentication, error handling, and careful mapping between EA objects and external entities, but it enables true synchronisation.\n\n\nIntegration with Git\nAlthough EA itself is not a code repository, scripts and MDG definitions benefit from version control. Git provides traceability, collaboration, and rollback. By storing scripts and MDG XML in Git, teams can manage them like any other software artefact.\nAutomation helps here too:\n\nScripts can export to a file system where Git commits are triggered.\nAI can generate commit messages explaining changes.\nGovernance scripts can check that repositories are up to date.\n\nGit integration makes EA scripting part of the DevOps toolchain.\n\n\nIntegration with Analytics\nAnother important integration is with analytics platforms. EA contains rich metadata: numbers of requirements, traceability ratios, coverage metrics. But EA’s own reporting is limited. Exporting to CSV, JSON, or direct database queries allows BI tools like Power BI or Tableau to visualise architecture quality.\nScripting plays a key role here:\n\nAutomating exports to CSV nightly.\nGenerating JSON snapshots for ingestion.\nCurating data (e.g., counting orphaned requirements).\n\nThis turns architecture from a static document into a measurable process.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#the-cultural-dimension-of-integration",
    "href": "19-System.Object[].html#the-cultural-dimension-of-integration",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "The Cultural Dimension of Integration",
    "text": "The Cultural Dimension of Integration\nIntegration is not only technical; it changes how people perceive architecture. When requirements flow from Jira into EA automatically, architects are seen as part of the delivery pipeline, not an afterthought. When governance reports appear in Confluence every week, stakeholders see architecture as transparent and accountable. When scripts push metadata into analytics dashboards, leaders see architecture as measurable.\nIn this way, integration changes culture: it makes architecture visible, relevant, and trusted.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#risks-of-integration",
    "href": "19-System.Object[].html#risks-of-integration",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Risks of Integration",
    "text": "Risks of Integration\nIntegration is powerful but risky. Poorly designed integrations can:\n\nFlood EA with duplicates.\nOverwrite authoritative data incorrectly.\nExpose sensitive data via exports.\nCreate brittle dependencies on API versions.\n\nThat is why governance principles still apply: dry-run modes, logging, backups, and version control. Integration scripts should be treated with the same rigour as any enterprise software.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#examples",
    "href": "19-System.Object[].html#examples",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Examples",
    "text": "Examples\n\nHTTP from JScript (webhooks & simple POSTs)\nEA’s JScript can call HTTP endpoints via WinHTTP. That’s enough to send messages to ChatOps (Teams/Slack) or any webhook.\n⚠️ JScript has no JSON parser. Prefer “write JSON out; parse/apply externally.” For push-only notifications, build a small JSON string by hand.\n\n\nExample 18.1 - WebhookNotify.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 18.1 - WebhookNotify.js – JScript (ES3)\n// Purpose: Send a simple JSON message to a webhook (e.g. Teams/Slack/custom)\n// Usage: Set WEBHOOK_URL; run to notify about the selected package\n// Notes: No JSON.parse; we only build a tiny JSON string\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\nfunction main() {\n    var WEBHOOK_URL = \"https://example.webhook/your-token\"; // &lt;-- put your webhook here\n\n    var pkg = Repository.GetTreeSelectedPackage();\n    if (!pkg) { Session.Prompt(\"Select a package to announce.\", promptOK); return; }\n\n    // Build a tiny JSON body (escape quotes and backslashes)\n    var body = \"{\"\n             + \"\\\"title\\\":\\\"EA Notification\\\",\"\n             + \"\\\"text\\\":\\\"Package '\" + jsonEscape(pkg.Name) + \"' (ID \" + pkg.PackageID + \") was processed.\\\"\"\n             + \"}\";\n\n    var ok = httpPostJson(WEBHOOK_URL, body, 15000);\n    Session.Output(ok ? \"Webhook sent.\" : \"Webhook failed.\");\n}\n\nfunction httpPostJson(url, body, timeoutMs) {\n    try {\n        var http = new ActiveXObject(\"WinHttp.WinHttpRequest.5.1\");\n        http.Open(\"POST\", url, false);\n        http.SetTimeouts(5000, 5000, timeoutMs||15000, timeoutMs||15000); // DNS/connect/send/receive\n        http.SetRequestHeader(\"Content-Type\", \"application/json\");\n        http.Send(body);\n        var status = http.Status;\n        return status &gt;= 200 && status &lt; 300;\n    } catch(e) {\n        Session.Output(\"HTTP error: \" + e.message);\n        return false;\n    }\n}\n\nfunction jsonEscape(s){ s=String(s||\"\"); return s.replace(/\\\\/g,\"\\\\\\\\\").replace(/\"/g,'\\\\\"'); }\n\nmain();\n\nWhen to use: status pings (“curation ready,” “governance run finished”), small alerts, pipeline handoffs.\n\n\nJira ⇄ EA (keys as tagged values)\nBest practice: store the Jira issue key on the EA element (e.g., JiraKey tag). Use external Python to pull from Jira (robust JSON), then create/update EA Requirements. This keeps identity stable and avoids duplicates.\n\nImport Jira issues → EA Requirements (external Python)\n\n\nExample 18.2 - jira_to_ea_import.py – Python 3 (pywin32, requests)\n\n# -------------------------------------------------------\n# Example 18.2 - jira_to_ea_import.py – Python 3 (pywin32, requests)\n# Purpose: Query Jira and sync to EA Requirements (store JiraKey as a tag)\n# Safety: Idempotent by key; only updates when values differ\n# Usage: python jira_to_ea_import.py \"https://your-jira\" \"JQL here\" 1234\n#   where 1234 is the target PackageID in EA\n# -------------------------------------------------------\nimport sys, requests, win32com.client\n\n# --- Config & secrets ---\nJIRA_BASE   = sys.argv[1]              # e.g., \"https://yourcompany.atlassian.net\"\nJQL         = sys.argv[2]              # e.g., 'project=ARCH AND issuetype=Requirement'\nTARGET_PKG  = int(sys.argv[3])\nAUTH_USER   = \"&lt;jira_user_email&gt;\"      # store securely in env/secret store in real use\nAUTH_TOKEN  = \"&lt;jira_api_token&gt;\"       # never hardcode in production\n\ndef ea_get_tag(el, name):\n    tvs = el.TaggedValues\n    for i in range(tvs.Count):\n        tv = tvs.GetAt(i)\n        if tv.Name == name:\n            return tv.Value or \"\"\n    return \"\"\n\ndef ea_set_tag(el, name, value):\n    tvs = el.TaggedValues\n    for i in range(tvs.Count):\n        tv = tvs.GetAt(i)\n        if tv.Name == name:\n            tv.Value = value; tv.Update(); el.Update(); return\n    nt = tvs.AddNew(name, value)\n    nt.Update(); el.Update()\n\ndef find_by_name(pkg, name):\n    els = pkg.Elements\n    for i in range(els.Count):\n        e = els.GetAt(i)\n        if e.Name == name and e.Type == \"Requirement\":\n            return e\n    return None\n\ndef main():\n    # --- Jira query ---\n    s = requests.Session()\n    s.auth = (AUTH_USER, AUTH_TOKEN)\n    s.headers.update({\"Accept\": \"application/json\"})\n\n    r = s.get(f\"{JIRA_BASE}/rest/api/3/search\", params={\"jql\": JQL, \"maxResults\": 100})\n    r.raise_for_status()\n    issues = r.json()[\"issues\"]\n\n    # --- EA attach ---\n    ea  = win32com.client.Dispatch(\"EA.App\")\n    repo= ea.Repository\n    pkg = repo.GetPackageByID(TARGET_PKG)\n\n    created, updated = 0, 0\n    for it in issues:\n        key   = it[\"key\"]\n        fields= it[\"fields\"]\n        name  = fields.get(\"summary\", key)\n        notes = fields.get(\"description\") or \"\"\n\n        # Try match by JiraKey tag first\n        match = None\n        els = pkg.Elements\n        for i in range(els.Count):\n            e = els.GetAt(i)\n            if ea_get_tag(e, \"JiraKey\") == key:\n                match = e; break\n\n        if not match:\n            # fallback: by name\n            match = find_by_name(pkg, name)\n\n        if not match:\n            # create new\n            e = pkg.Elements.AddNew(name, \"Requirement\")\n            e.Notes = notes\n            e.Update()\n            ea_set_tag(e, \"JiraKey\", key)\n            created += 1\n        else:\n            # update if changed\n            dirty = False\n            if (match.Notes or \"\") != (notes or \"\"):\n                match.Notes = notes; dirty = True\n            if ea_get_tag(match, \"JiraKey\") != key:\n                ea_set_tag(match, \"JiraKey\", key); dirty = False  # tag helper already updated\n            if dirty:\n                match.Update(); updated += 1\n\n    if created or updated:\n        repo.RefreshModelView(pkg.PackageID)\n\n    print(f\"Done. Created={created}, Updated={updated}\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) &lt; 4:\n        print(\"Usage: python jira_to_ea_import.py &lt;base&gt; &lt;jql&gt; &lt;package_id&gt;\")\n    else:\n        main()",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#notes",
    "href": "19-System.Object[].html#notes",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Notes",
    "text": "Notes\n\nUse API tokens (don’t embed secrets in scripts; prefer env vars/secret stores).\nMaintain a JiraKey tag on each synced element.\nExtend mapping easily (priority → Status, components → tagged values, etc.).\n\n\nPublish to Confluence (page with a live table)\nTypical flow: generate HTML/CSV inside EA, then external Python updates a Confluence page with the content. Confluence Cloud expects REST + JSON.\n\nExport an HTML table from EA (in-EA)\n\n\nExample 18.3 - ExportHTML_Table.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 18.3 - ExportHTML_Table.js – JScript (ES3)\n// Purpose: Export selected package elements as a simple HTML table (for Confluence)\n// Output: Writes .html to chosen folder\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction pickFolder(msg){ var sh=new ActiveXObject(\"Shell.Application\"); var f=sh.BrowseForFolder(0,msg,0,0); return f?f.Self.Path:null; }\n\nfunction main(){\n    var pkg = Repository.GetTreeSelectedPackage();\n    if(!pkg){ Session.Prompt(\"Select a package.\", promptOK); return; }\n\n    var dir = pickFolder(\"Select output folder for HTML\");\n    if(!dir) return;\n\n    var fso=new ActiveXObject(\"Scripting.FileSystemObject\");\n    var stamp=(new Date()).getTime();\n    var path = dir+\"\\\\ea_table_\"+stamp+\".html\";\n    var file = fso.CreateTextFile(path, true);\n\n    file.WriteLine(\"&lt;table&gt;\");\n    file.WriteLine(\"&lt;tr&gt;&lt;th&gt;ID&lt;/th&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Type&lt;/th&gt;&lt;th&gt;Status&lt;/th&gt;&lt;/tr&gt;\");\n\n    var els=pkg.Elements;\n    for (var i=0;i&lt;els.Count;i++){\n        var e=els.GetAt(i);\n        file.WriteLine(\"&lt;tr&gt;&lt;td&gt;\"+e.ElementID+\"&lt;/td&gt;&lt;td&gt;\"+html(e.Name)+\"&lt;/td&gt;&lt;td&gt;\"+e.Type+\"&lt;/td&gt;&lt;td&gt;\"+(e.Status||\"\")+\"&lt;/td&gt;&lt;/tr&gt;\");\n    }\n    file.WriteLine(\"&lt;/table&gt;\");\n    file.Close();\n\n    Session.Output(\"HTML written → \"+path);\n}\nfunction html(s){ s=String(s||\"\"); return s.replace(/&/g,\"&amp;\").replace(/&lt;/g,\"&lt;\").replace(/&gt;/g,\"&gt;\"); }\n\nmain();\n\n\n\nUpdate or create a Confluence page (external Python)\n\n\nExample 18.4 - confluence_publish.py – Python 3 (requests)\n\n# -------------------------------------------------------\n# Example 18.4 - confluence_publish.py – Python 3 (requests)\n# Purpose: Create/update a Confluence page with HTML body\n# Usage: python confluence_publish.py SPACE PAGE_TITLE path\\to\\ea_table.html\n# Notes: Uses \"storage\" format; increments version when updating\n# -------------------------------------------------------\nimport sys, requests, json\n\nBASE   = \"https://your-domain.atlassian.net/wiki\"\nUSER   = \"&lt;confluence_user_email&gt;\"\nTOKEN  = \"&lt;confluence_api_token&gt;\"\n\ndef find_page(space, title, sess):\n    r = sess.get(f\"{BASE}/rest/api/content\", params={\"spaceKey\": space, \"title\": title})\n    r.raise_for_status()\n    results = r.json().get(\"results\", [])\n    return results[0] if results else None\n\ndef main():\n    if len(sys.argv) &lt; 4:\n        print(\"Usage: confluence_publish.py &lt;SPACE&gt; &lt;TITLE&gt; &lt;HTML_PATH&gt;\")\n        return\n\n    space, title, html_path = sys.argv[1], sys.argv[2], sys.argv[3]\n    html = open(html_path, \"r\", encoding=\"utf-8\").read()\n\n    s = requests.Session()\n    s.auth = (USER, TOKEN)\n    s.headers.update({\"Content-Type\": \"application/json\"})\n\n    existing = find_page(space, title, s)\n    if existing:\n        page_id = existing[\"id\"]\n        ver = existing[\"version\"][\"number\"] + 1\n        payload = {\n            \"id\": page_id,\n            \"type\": \"page\",\n            \"title\": title,\n            \"version\": {\"number\": ver},\n            \"body\": {\"storage\": {\"value\": html, \"representation\": \"storage\"}}\n        }\n        r = s.put(f\"{BASE}/rest/api/content/{page_id}\", data=json.dumps(payload))\n        r.raise_for_status()\n        print(f\"Updated page {title} (id={page_id}) to version {ver}\")\n    else:\n        payload = {\n            \"type\":\"page\",\"title\":title,\"space\":{\"key\":space},\n            \"body\":{\"storage\":{\"value\":html,\"representation\":\"storage\"}}\n        }\n        r = s.post(f\"{BASE}/rest/api/content\", data=json.dumps(payload))\n        r.raise_for_status()\n        print(f\"Created page {title}\")\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\nGit: version control your exports (and script library)\nA simple pattern: export CSV/JSON from EA, then commit with Git using the system’s git CLI.\n\nRun git add/commit from EA (JScript)\n\n\nExample 18.5 - GitCommit_ExportFolder.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 18.5 - GitCommit_ExportFolder.js – JScript (ES3)\n// Purpose: Run 'git add' and 'git commit' for a chosen folder\n// Usage: Prepare your folder as a git repo; run after exports\n// Notes: Captures stdout/stderr; commit message is timestamped\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction pickFolder(m){ var sh=new ActiveXObject(\"Shell.Application\"); var f=sh.BrowseForFolder(0,m,0,0); return f?f.Self.Path:null; }\n\nfunction main(){\n    var dir = pickFolder(\"Select folder to commit (must be a git repo)\");\n    if(!dir) return;\n\n    var shell = new ActiveXObject(\"WScript.Shell\");\n    var cmdAdd = 'cmd /c cd /d \"' + dir + '\" && git add -A';\n    var cmdCommit = 'cmd /c cd /d \"' + dir + '\" && git commit -m \"EA export '+(new Date()).toISOString()+'\"';\n\n    execAndLog(shell, cmdAdd);\n    execAndLog(shell, cmdCommit);\n\n    Session.Output(\"Git commit attempted. Review output above for success/errors.\");\n}\n\nfunction execAndLog(shell, cmd){\n    try{\n        var exec = shell.Exec(cmd);\n        while(!exec.StdOut.AtEndOfStream){ Session.Output(exec.StdOut.ReadLine()); }\n        while(!exec.StdErr.AtEndOfStream){ Session.Output(\"[ERR] \"+exec.StdErr.ReadLine()); }\n    }catch(e){\n        Session.Output(\"Exec error: \" + e.message);\n    }\n}\n\nmain();\n\nTip: Pair this with the export scripts from Chapter 8 to automate a nightly “export → commit” job.\n\n\n\nRegistry/Analytics: push EA metadata downstream\nA common requirement is to feed a registry (e.g., a catalog or data platform). Pattern:\n\nExport tidy JSON/CSV from EA (in-EA).\nPush to your API or storage (external Python with requests).\n\n\nExport NDJSON (one JSON per line) inside EA\n\n\nExample 18.6 - Export_NDJSON.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 18.6 - Export_NDJSON.js – JScript (ES3)\n// Purpose: Write NDJSON (line-delimited JSON) for easy ingestion\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction pickFolder(m){ var sh=new ActiveXObject(\"Shell.Application\"); var f=sh.BrowseForFolder(0,m,0,0); return f?f.Self.Path:null; }\n\nfunction main(){\n    var pkg = Repository.GetTreeSelectedPackage();\n    if(!pkg){ Session.Prompt(\"Select a package.\", promptOK); return; }\n    var dir = pickFolder(\"Select output folder for NDJSON\");\n    if(!dir) return;\n\n    var fso=new ActiveXObject(\"Scripting.FileSystemObject\");\n    var path=dir+\"\\\\ea_export_\"+(new Date()).getTime()+\".ndjson\";\n    var file=fso.CreateTextFile(path, true);\n\n    var els=pkg.Elements;\n    for (var i=0;i&lt;els.Count;i++){\n        var e=els.GetAt(i);\n        var json = \"{\"\n                 + \"\\\"id\\\":\" + e.ElementID + \",\"\n                 + \"\\\"guid\\\":\\\"\" + esc(e.ElementGUID) + \"\\\",\"\n                 + \"\\\"name\\\":\\\"\" + esc(e.Name) + \"\\\",\"\n                 + \"\\\"type\\\":\\\"\" + esc(e.Type) + \"\\\",\"\n                 + \"\\\"status\\\":\\\"\" + esc(String(e.Status||\"\")) + \"\\\"\"\n                 + \"}\";\n        file.WriteLine(json);\n    }\n    file.Close();\n    Session.Output(\"NDJSON written → \" + path);\n}\nfunction esc(s){ s=String(s||\"\"); return s.replace(/\\\\/g,\"\\\\\\\\\").replace(/\"/g,'\\\\\"'); }\n\nmain();\n\n\n\nPush NDJSON to your registry (external Python)\n\n\nExample 18.7 - push_ndjson.py – Python 3 (requests)\n\n# -------------------------------------------------------\n# Example 18.7 - push_ndjson.py – Python 3 (requests)\n# Purpose: Stream NDJSON lines to a registry endpoint\n# Usage: python push_ndjson.py https://registry.example/api/bulk path\\to\\file.ndjson\n# -------------------------------------------------------\nimport sys, requests\n\ndef main():\n    if len(sys.argv) &lt; 3:\n        print(\"Usage: push_ndjson.py &lt;endpoint&gt; &lt;ndjson_path&gt;\")\n        return\n\n    endpoint, path = sys.argv[1], sys.argv[2]\n    with open(path, \"rb\") as f:\n        r = requests.post(endpoint, data=f, headers={\"Content-Type\":\"application/x-ndjson\"}, timeout=60)\n    r.raise_for_status()\n    print(\"Pushed NDJSON. Server:\", r.status_code)\n\nif __name__ == \"__main__\":\n    main()",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#secrets-auth-bitness-read-this",
    "href": "19-System.Object[].html#secrets-auth-bitness-read-this",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Secrets, auth & bitness (read this!)",
    "text": "Secrets, auth & bitness (read this!)\n\nNever hardcode secrets in EA scripts. Use environment variables (via WScript.Shell.Environment(“PROCESS”)) or external secret stores.\nUse API tokens (Jira/Confluence) rather than passwords.\nBitness must match: EA is typically 32-bit; external Python should be 32-bit to attach via COM.\nNetwork constraints: Corporate proxies/firewalls may require proxy settings; WinHTTP and requests both support proxies (configure in environment or code).",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#putting-it-together-one-realistic-flow",
    "href": "19-System.Object[].html#putting-it-together-one-realistic-flow",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Putting it together (one realistic flow)",
    "text": "Putting it together (one realistic flow)\n\nNightly job (Task Scheduler/CI) runs Python:\n\n\nQuery Jira (JQL) → update EA Requirements (store JiraKey).\nExport HTML table from EA.\nUpdate Confluence page with the new table.\nExport NDJSON and push to registry.\ngit add/commit the export folder for traceability.\n\n\nEA users see fresh data in Confluence; governance can trace elements back to Jira; downstream teams ingest NDJSON.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#troubleshooting-quick-wins",
    "href": "19-System.Object[].html#troubleshooting-quick-wins",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Troubleshooting quick wins",
    "text": "Troubleshooting quick wins\n\n401/403: bad token or wrong endpoint path/version (/api/2 vs /api/3).\nSSL errors: corporate MITM certs—install trust chain or use verify= with org CA (Python).\nTimeouts: increase receive timeout; batch large payloads.\nUnicode: prefer UTF-8 in Python; JScript file I/O defaults to ANSI—keep payloads simple or generate externally.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "19-System.Object[].html#checklist-cheat-sheet",
    "href": "19-System.Object[].html#checklist-cheat-sheet",
    "title": "Chapter 18: Integrating with Workflows",
    "section": "Checklist (cheat-sheet)",
    "text": "Checklist (cheat-sheet)\n\nKeep identities in EA via tagged values (JiraKey, ExternalID).\nWrite in EA; parse outside (JSON).\nDry-run first; log to CSV/HTML for review.\nUse git for exported artifacts (history, diffs).\nMake small, composable scripts; orchestrate with Python/CI.",
    "crumbs": [
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Chapter 18: Integrating with Workflows</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html",
    "href": "20-System.Object[].html",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "",
    "text": "Scripts as the First Line of Automation\nUp to this point, we have focused mainly on scripts that live inside Enterprise Architect or run against it externally through the automation interface. These approaches are flexible, fast to develop, and ideal for governance checks, imports and exports, and targeted utilities. But there comes a point when scripts start to feel limited. You may want permanent menus, event handlers that react when users create elements, or deeper integration with EA’s user interface. At this stage, you move beyond scripts and begin thinking in terms of Add-ins.\nThis chapter explores the boundary between scripts and add-ins. It explains what each approach is best suited for, why organisations sometimes make the leap to add-ins, and what the trade-offs are in terms of power, safety, and maintainability. The aim is not to suggest that every script should become an add-in, but to show you the decision space clearly so you can choose the right tool for the job.\nScripts are the natural starting point for automation in EA. They are:\nFor governance, imports/exports, and small utilities, scripts are ideal. They reduce friction, allow experimentation, and empower modellers who are not professional developers.\nHowever, scripts also have limitations:\nWhen you hit these walls, it is time to consider add-ins.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#scripts-as-the-first-line-of-automation",
    "href": "20-System.Object[].html#scripts-as-the-first-line-of-automation",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "",
    "text": "Easy to create: no extra tools beyond EA itself.\nPortable: stored in the repository, available to all users.\nQuick to test: you can write a script in the morning and run it that afternoon.\n\n\n\n\nThey cannot add permanent menus or toolbars.\nThey cannot hook into events (e.g. “element created”).\nThey are tied to a specific repository rather than installed globally.\nThey are confined to JScript or VBScript, with limited libraries.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#add-ins-as-compiled-extensions",
    "href": "20-System.Object[].html#add-ins-as-compiled-extensions",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Add-ins as Compiled Extensions",
    "text": "Add-ins as Compiled Extensions\nAn Add-in is a compiled .NET assembly (usually in C#) that EA loads at startup. It is registered in the Windows Registry under the EAAddins key, marked COM-visible, and referenced by EA as if it were part of the application.\nAdd-ins can:\n\nAdd menus and toolbars to EA’s UI.\nRespond to events like element creation, diagram opening, or project closing.\nUse the full power of .NET libraries, from JSON parsing to REST APIs.\nProvide custom docked windows and richer user interfaces.\n\nIn short, add-ins let you extend EA itself, turning one-off utilities into permanent, user-friendly tools.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#why-move-from-script-to-add-in",
    "href": "20-System.Object[].html#why-move-from-script-to-add-in",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Why Move from Script to Add-in?",
    "text": "Why Move from Script to Add-in?\nOrganisations usually move from script to add-in for one or more of these reasons:\n\nDistribution: a script stored in one repository is not visible in another; an add-in installed on all workstations is.\nConsistency: add-ins provide the same menus for everyone, ensuring a common experience.\nEvents: only add-ins can react to events (e.g. auto-tag new elements).\nProfessionalisation: mature utilities become part of a toolset rather than ad hoc snippets.\nIntegration: add-ins can use advanced libraries and UI frameworks.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#trade-offs",
    "href": "20-System.Object[].html#trade-offs",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Trade-offs",
    "text": "Trade-offs\nThe move to add-ins brings benefits, but also costs.\nAdvantages of Add-ins:\n\nRicher features (menus, events, UI).\nStrong typing (C#, VB.NET).\nAccess to modern libraries.\nProfessional distribution and versioning.\n\nDisadvantages of Add-ins:\n\nMore setup (Visual Studio, COM registration).\nDistribution overhead (must be installed on each machine).\nDebugging complexity (requires attaching to EA process).\nHigher governance burden (DLLs need version control and change management).\n\nIn other words, add-ins are heavier. They make sense when a solution is stable and widely used, but they are overkill for experimental or repository-specific tasks.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#add-ins-and-governance",
    "href": "20-System.Object[].html#add-ins-and-governance",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Add-ins and Governance",
    "text": "Add-ins and Governance\nOne of the subtle reasons to move to add-ins is governance. Scripts are flexible but ephemeral; anyone can change them in the repository. Add-ins, by contrast, are compiled, versioned, and distributed. This makes them better suited to regulated environments where tools must be controlled.\nFor example, a bank may insist that only signed add-ins are used, ensuring all automation has passed security checks. Scripts may still exist for local use, but official tooling is delivered as add-ins.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#the-learning-curve",
    "href": "20-System.Object[].html#the-learning-curve",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "The Learning Curve",
    "text": "The Learning Curve\nWriting add-ins requires more development skill than writing scripts. You need to:\n\nSet up a Class Library project in Visual Studio.\nAdd a reference to Interop.EA.dll.\nMark the assembly COM-visible.\nRegister it with regasm or an installer.\nImplement required methods like EA_Connect, EA_Disconnect, EA_GetMenuItems, and EA_MenuClick.\n\nThis is more demanding than writing JScript in EA’s built-in editor. But it opens far greater possibilities.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#a-progressive-path",
    "href": "20-System.Object[].html#a-progressive-path",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "A Progressive Path",
    "text": "A Progressive Path\nA useful way to think about the script/add-in distinction is as a path:\n\nScripts — fast, flexible, repository-bound.\nExternal Automation — Python or C# utilities that integrate EA into enterprise workflows.\nAdd-ins — compiled, distributed, integrated extensions.\n\nTeams often move along this path naturally. A script solves a local problem. Later it becomes an external utility. Finally, it matures into an add-in for permanent use. Understanding this path helps you decide when to invest in the extra effort of an add-in.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#cultural-impact",
    "href": "20-System.Object[].html#cultural-impact",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Cultural Impact",
    "text": "Cultural Impact\nThe choice between scripts and add-ins also shapes team culture. Scripts empower modellers; add-ins formalise tools. Too much reliance on add-ins can discourage experimentation. Too much reliance on scripts can create chaos. The healthiest culture balances the two: scripts for flexibility, add-ins for stability.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#risks-of-add-ins",
    "href": "20-System.Object[].html#risks-of-add-ins",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Risks of Add-ins",
    "text": "Risks of Add-ins\nBecause add-ins load at EA startup, errors in add-ins can be disruptive. A badly written add-in may prevent menus from loading, slow down EA, or crash the application. This risk means testing and version control are even more critical than for scripts.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#example",
    "href": "20-System.Object[].html#example",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Example",
    "text": "Example\n\nMinimal C# Add-in\nHere’s a minimal C# Add-in. It adds a menu under Specialize → MyAddin → Hello. When clicked, it shows a message box.\n\n\nExample 19.1 - MyAddin.cs – Minimal EA Add-in\n\n// -------------------------------------------------------\n// Example 19.1 - MyAddin.cs – Minimal EA Add-in\n// Purpose: Demonstrate how to build a COM-visible add-in\n// Notes:\n//   - Build as Class Library (.NET Framework, not .NET Core).\n//   - Mark assembly COM-visible.\n//   - Register DLL with regasm or installer.\n// -------------------------------------------------------\nusing System;\nusing System.Runtime.InteropServices;\nusing EA; // Reference to Interop.EA.dll (from EA install folder)\nusing System.Windows.Forms;\n\nnamespace MyAddin\n{\n    [ComVisible(true)]                 // Required for COM\n    [ClassInterface(ClassInterfaceType.None)]\n    public class MyAddinClass\n    {\n        // EA calls this at connection\n        public string EA_Connect(Repository Repository)\n        {\n            return \"a string\";         // Reserved, can be anything\n        }\n\n        public void EA_Disconnect()\n        {\n            // Cleanup if needed\n        }\n\n        // ---- Menu Integration ----\n\n        // Tell EA which menu root to show\n        public object EA_GetMenuItems(Repository Repository, string Location, string MenuName)\n        {\n            if (MenuName == \"\")\n                return \"MyAddin\";      // Root menu\n            else if (MenuName == \"MyAddin\")\n                return \"Hello\";        // Submenu item\n            return \"\";\n        }\n\n        // Control enabled/disabled state\n        public bool EA_GetMenuState(Repository Repository, string Location, string MenuName, string ItemName, ref bool IsEnabled, ref bool IsChecked)\n        {\n            IsEnabled = true;          // Always enabled\n            return true;\n        }\n\n        // Handle click events\n        public void EA_MenuClick(Repository Repository, string Location, string MenuName, string ItemName)\n        {\n            if (MenuName == \"MyAddin\" && ItemName == \"Hello\")\n            {\n                MessageBox.Show(\"Hello from MyAddin!\", \"EA Add-in\");\n            }\n        }\n    }\n}\n\n\n\nBuild & Register the Add-in\n\nIn Visual Studio:\n\n\nCreate a Class Library (.NET Framework) project (e.g., .NET Framework 4.7.2).\nAdd reference to Interop.EA.dll (found in EA’s install folder).\nEnsure AssemblyInfo.cs has [assembly: ComVisible(true)].\n\n\nBuild the DLL.\nRegister it for COM (run as admin):\nregasm MyAddin.dll /codebase\nAdd registry entry for EA (HKCU or HKLM):\n\\[HKEY_CURRENT_USER\\Software\\Sparx Systems\\EAAddins\\MyAddin\\]\n@=“MyAddin.MyAddinClass”\nRestart EA → check Specialize → Manage Add-ins. Enable MyAddin.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#when-to-migrate-script-add-in",
    "href": "20-System.Object[].html#when-to-migrate-script-add-in",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "When to Migrate Script → Add-in",
    "text": "When to Migrate Script → Add-in\nStick with Scripts when:\n\nOne-off bulk edits or imports.\nRepository-specific governance checks.\nYou don’t need UI menus.\n\nMove to Add-ins when:\n\nYou want consistent menu items for all users.\nYou need .NET libraries (e.g., JSON.NET, REST SDK).\nYou want event handling (e.g., auto-tag new elements).\nDistribution is across many repositories.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#migration-example",
    "href": "20-System.Object[].html#migration-example",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Migration Example",
    "text": "Migration Example\nGovernance Script (inside EA) → “Enforce Owner tag on all Requirements.”\nWhen matured into an Add-in:\n\nProvide a permanent menu item “Governance → Enforce Tags”.\nUse events: EA_OnElementCreated → auto-add Owner tag.\nAdd reporting form with filtering, progress bar, export button.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "20-System.Object[].html#summary",
    "href": "20-System.Object[].html#summary",
    "title": "Chapter 19: Add-ins vs Scripts",
    "section": "Summary",
    "text": "Summary\n\nScripts are lightweight, repository-local, and quick.\nAdd-ins are heavy-duty, system-wide, and extensible.\nMigration path: prove with scripts → formalise as Add-in when stable.\nMinimal Add-in = COM-visible C# class, a registry key, and menu methods.",
    "crumbs": [
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Chapter 19: Add-ins vs Scripts</span>"
    ]
  },
  {
    "objectID": "21-System.Object[].html",
    "href": "21-System.Object[].html",
    "title": "Chapter 20: Troubleshooting",
    "section": "",
    "text": "Why Troubleshooting Matters\nEvery scripting environment has its quirks, and Enterprise Architect is no exception. By now, you’ve learned how to navigate the API, use patterns, enforce governance, and even integrate EA into wider workflows. Yet no matter how careful you are, you will encounter frustrating moments where “nothing happens” or “it worked yesterday but not today.” These issues are not signs of failure — they are a normal part of scripting EA.\nThis chapter collects the most common errors and pitfalls you will run into, explains why they occur, and shows how to recognise them quickly. It is less about teaching new capabilities and more about providing a troubleshooting handbook. By knowing the usual suspects, you can save hours of debugging.\nWhen a script fails silently, it undermines trust. Users may stop running governance checks if they think the results are unreliable. Architects may give up on automation if every export requires trial and error. Building confidence in scripting requires not only writing good scripts but also being able to diagnose problems fast.\nTroubleshooting is also essential for team knowledge transfer. If one person understands the quirks but others do not, automation becomes fragile. A shared troubleshooting guide empowers everyone to fix common issues.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Chapter 20: Troubleshooting</span>"
    ]
  },
  {
    "objectID": "21-System.Object[].html#the-nature-of-eas-quirks",
    "href": "21-System.Object[].html#the-nature-of-eas-quirks",
    "title": "Chapter 20: Troubleshooting",
    "section": "The Nature of EA’s Quirks",
    "text": "The Nature of EA’s Quirks\nWhy does EA feel quirky to script against? A few reasons:\n\nCOM-based API: EA exposes its object model through COM, an old but powerful technology with idiosyncrasies.\nLegacy scripting engine: JScript is stuck at ES3, which means modern constructs are missing.\nUI lag: EA’s interface does not always refresh automatically when the repository changes.\nDatabase underpinnings: EA stores content in relational tables, and API calls must keep schema integrity.\n\nThese constraints create subtle traps that new script writers fall into again and again.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Chapter 20: Troubleshooting</span>"
    ]
  },
  {
    "objectID": "21-System.Object[].html#the-usual-suspects",
    "href": "21-System.Object[].html#the-usual-suspects",
    "title": "Chapter 20: Troubleshooting",
    "section": "The Usual Suspects",
    "text": "The Usual Suspects\nFrom years of practice and community wisdom, a handful of issues account for the majority of problems:\n\nForgetting Update() after setting a property.\nForgetting RefreshModelView() after a bulk change.\nConfusing Stereotype with StereotypeEx.\nTreating EA collections as arrays (forEach instead of .GetAt()).\nForward-deleting instead of backward-deleting.\nMisusing SQL (writing instead of reading).\nEncoding errors when exporting text.\nFailing to check ObjectType before casting.\n\nThese “usual suspects” are the core of this chapter.\n\nSilent Failures\nOne of the most frustrating experiences in EA scripting is the silent failure: your script runs, no errors are thrown, but nothing changes. In almost all cases, the culprit is forgetting Update(). EA only persists changes when you explicitly call Update(). Without it, modifications stay in memory and are discarded.\nAnother form of silent failure is forgetting to refresh the UI. Changes exist in the database but are invisible until you call Repository.RefreshModelView(). Recognising these two patterns will resolve half your troubleshooting cases.\n\n\nCollection Confusion\nAnother common cause of errors is treating EA collections like standard arrays. They are not. They only support .Count and .GetAt(). Any attempt to use forEach, map, or array indexing will fail. Scripts that AI generates often stumble here, which is why human review is essential.\n\n\nDeletion Pitfalls\nDeleting items is particularly risky. Forward loops that delete as they go will skip elements because the index shifts. The safe pattern is always to delete backwards: from the last index down to zero. Forgetting this leads to half-deleted collections or inconsistent states.\n\n\nSQL Misuse\nEA allows direct SQL queries via Repository.SQLQuery() and Repository.Execute(). The former is safe (read-only), the latter dangerous (write). Beginners sometimes attempt to UPDATE directly via SQL, bypassing the API. This risks corrupting the repository because the API enforces consistency.\nThe safe rule is: SQL for find, API for write. Never write to the database directly unless you absolutely understand the schema and consequences.\n\n\nEncoding Problems\nBecause JScript’s FileSystemObject writes files in ANSI encoding, exports often lose special characters (e.g. accented letters, non-Latin scripts). This leads to CSVs with “???” instead of correct text. The fix is to use external automation (Python, C#) for UTF-8 output. Inside EA, the workaround is to stick to ASCII.\n\n\nObjectType Confusion\nScripts often fail because the developer assumes a selected object is a package or element, but the user actually selected a diagram or attribute. The solution is always to check ObjectType before acting. This prevents runtime errors and makes scripts more robust.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Chapter 20: Troubleshooting</span>"
    ]
  },
  {
    "objectID": "21-System.Object[].html#the-value-of-defensive-patterns",
    "href": "21-System.Object[].html#the-value-of-defensive-patterns",
    "title": "Chapter 20: Troubleshooting",
    "section": "The Value of Defensive Patterns",
    "text": "The Value of Defensive Patterns\nThe best way to avoid troubleshooting later is to adopt defensive coding patterns now:\n\nWrap every modification in if (!DRY_RUN).\nAlways check ObjectType.\nUse backward deletion.\nAlways Update() and RefreshModelView().\nValidate stereotypes with StereotypeEx.\n\nBy embedding these patterns, you avoid the majority of common errors.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Chapter 20: Troubleshooting</span>"
    ]
  },
  {
    "objectID": "21-System.Object[].html#troubleshooting-as-a-team-resource",
    "href": "21-System.Object[].html#troubleshooting-as-a-team-resource",
    "title": "Chapter 20: Troubleshooting",
    "section": "Troubleshooting as a Team Resource",
    "text": "Troubleshooting as a Team Resource\nTroubleshooting knowledge should be shared, not hoarded. Teams benefit from keeping a living “troubleshooting wiki” that documents issues encountered and solutions. AI can also play a role: paste an error into AI and ask for explanations. But the foundation is a shared understanding of EA’s quirks, documented and available to all.\n\nUpdate() Forgotten\nSymptom: You change an element property, run the script, and nothing changes in EA.\nCause: EA requires Update() on nearly every object after modification. Without it, changes stay in memory only.\n\nWrong\n// [x] Forgets Update()\n\nvar e = Repository.GetTreeSelectedObject();\n\ne.Name = \"NewName\"; // appears to succeed, but won’t persist\n\n// no e.Update()\n\n\nFixed\n// [✓] Always call Update()\n\nvar e = Repository.GetTreeSelectedObject();\n\ne.Name = \"NewName\";\n\ne.Update(); // persist to repository\n\n\n\nRefreshModelView() Missing\nSymptom: The change did persist (e.g., new name), but you don’t see it in the Project Browser until you close/reopen EA.\nCause: EA’s UI cache isn’t automatically updated. Call Repository.RefreshModelView() to refresh.\n\nFixed\nvar pkg = Repository.GetTreeSelectedPackage();\n\nvar e = pkg.Elements.AddNew(\"TempClass\", \"Class\");\n\ne.Update();\n\n// Refresh the package tree so the user sees the new class\n\nRepository.RefreshModelView(pkg.PackageID);\n\n\nWrong Method Name\nSymptom: AI-generated code crashes with “function not defined.”\nCause: Different EA versions expose slightly different casing (GetElementByGuid vs GetElementByGUID).\n\n\n\nFix with wrapper\n// [✓] Compatibility wrapper\n\nfunction getElementByGuidSafe(guid) {\n\ntry { return Repository.GetElementByGuid(guid); }\n\ncatch(e) {\n\ntry { return Repository.GetElementByGUID(guid); }\n\ncatch(e2) { return null; }\n\n}\n\n}\n\n\nCollections Misused\nSymptom: “Object doesn’t support property or method ‘forEach’” or “undefined.”\nCause: EA collections are COM objects, not JS arrays. You must use .Count and .GetAt(i).\n\nWrong\n// [x] This will fail\n\npkg.Elements.forEach(function(e){ Session.Output(e.Name); });\n\n\nFixed\n// [✓] Correct\n\nvar els = pkg.Elements;\n\nfor (var i=0; i\\&lt;els.Count; i++) {\n\nvar e = els.GetAt(i);\n\nSession.Output(e.Name);\n\n}\n\n\n\nDelete Without Backwards Iteration\nSymptom: Some elements are skipped when deleting in loops.\nCause: Deleting while looping forward shifts indices.\n\nWrong\n// [x] Deletes only half\n\nfor (var i=0; i\\&lt;pkg.Elements.Count; i++) {\n\npkg.Elements.DeleteAt(i, false);\n\n}\n\n\nFixed\n// [✓] Loop backwards\n\nfor (var i=pkg.Elements.Count-1; i\\&gt;=0; i--) {\n\npkg.Elements.DeleteAt(i, false);\n\n}\n\nRepository.RefreshModelView(pkg.PackageID);\n\n\n\nUnicode / Encoding Headaches\nSymptom: Exported CSV shows “???” instead of accented characters.\nCause: EA’s JScript FileSystemObject writes in ANSI by default.\nWorkaround:\n\nKeep exports simple (ASCII where possible).\nIf you need UTF-8: use external automation (Python/C#).\n\n\n\nExternal Python for UTF-8 CSV\n\\# utf8_export.py\n\nimport win32com.client, csv\n\nea = win32com.client.Dispatch(\"EA.App\")\n\nrepo = ea.Repository\n\npkg = repo.GetTreeSelectedPackage()\n\nwith open(\"export.csv\",\"w\",newline=\"\",encoding=\"utf-8\") as f:\n\nwr = csv.writer(f)\n\nwr.writerow(\\[\"ID\",\"Name\"\\])\n\nfor i in range(pkg.Elements.Count):\n\ne = pkg.Elements.GetAt(i)\n\nwr.writerow(\\[e.ElementID, e.Name\\])\n\n\nMisusing Session.Output (too much logging)\nSymptom: Script becomes slow or EA hangs.\nCause: Printing thousands of lines to EA’s Output tab is slow.\nFix:\n\nUse CSV/file logging for detail.\nUse Session.Output only for summary.\n\n\n\nAPI vs Direct SQL Write\nSymptom: Repository corrupted or constraints broken.\nCause: Direct Repository.Execute(“UPDATE…”) writes to EA tables skip API integrity.\nRule:\n\nUse Repository.SQLQuery() for read-only.\nUse object API (.Update()) for writes.\nOnly use direct SQL writes if you fully understand EA’s schema (rare).\n\n\n\nObjectType Confusion\nSymptom: Code assumes everything from GetTreeSelectedObject() is an element, but sometimes it’s a package or diagram.\nFix: Always check ObjectType.\n\nExample\nvar obj = Repository.GetTreeSelectedObject();\n\nif (obj.ObjectType == otPackage) {\n\nSession.Output(\"Selected a package: \" + obj.Name);\n\n} else if (obj.ObjectType == otElement) {\n\nSession.Output(\"Selected element: \" + obj.Name);\n\n} else {\n\nSession.Output(\"Unsupported object type.\");\n\n}",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Chapter 20: Troubleshooting</span>"
    ]
  },
  {
    "objectID": "21-System.Object[].html#safe-patterns-recap",
    "href": "21-System.Object[].html#safe-patterns-recap",
    "title": "Chapter 20: Troubleshooting",
    "section": "Safe Patterns Recap",
    "text": "Safe Patterns Recap\n\nAlways Update() after modifying objects.\nAlways RefreshModelView() after changes if you want UI sync.\nLoop with .Count / .GetAt(i), not forEach.\nDelete backwards.\nDon’t rely on names alone: use GUIDs or IDs.\nPrefer API writes over SQL.\nMinimise Session.Output inside large loops.\nCheck ObjectType before casting.\nExpect case differences in API (GUID vs Guid).\nExport UTF-8 externally if needed.",
    "crumbs": [
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Chapter 20: Troubleshooting</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html",
    "href": "22-System.Object[].html",
    "title": "Chapter 21: Reference",
    "section": "",
    "text": "EA Object Model Map (Condensed)\nThis section is your desk-side companion. It gathers the essentials you’ll need regularly: the EA object hierarchy, quick SQL snippets, a reusable script header template, and a logging helper you can drop into any script.\nEA’s Automation API is huge, but most scripts use a handful of objects.\nKey points",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#ea-object-model-map-condensed",
    "href": "22-System.Object[].html#ea-object-model-map-condensed",
    "title": "Chapter 21: Reference",
    "section": "",
    "text": "EA Repository object model\n\nRepository\n├─ Models (Collection of Package)\n│ └─ Package\n│ ├─ Packages (child packages)\n│ ├─ Elements\n│ │ └─ Element\n│ │ ├─ Attributes\n│ │ ├─ Methods\n│ │ ├─ Connectors\n│ │ └─ TaggedValues\n│ └─ Diagrams\n│ └─ Diagram\n│ └─ DiagramObjects\n└─ Methods\n├─ GetTreeSelectedPackage()\n├─ GetTreeSelectedObject()\n├─ GetElementByID(id)\n├─ GetElementByGUID(guid)\n├─ SQLQuery(sql)\n└─ RefreshModelView(id)\n\n\n\nEverything starts with Repository.\nPackage.Elements gives semantic content.\nElement.Connectors gives relationships.\nDiagram.DiagramObjects gives visual instances, not the element itself.\nAlways Update() after modification.\nUse RefreshModelView() for UI sync.",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#sql-cheat-sheet-read-only",
    "href": "22-System.Object[].html#sql-cheat-sheet-read-only",
    "title": "Chapter 21: Reference",
    "section": "SQL Cheat-Sheet (Read-only)",
    "text": "SQL Cheat-Sheet (Read-only)\nEA stores models in tables. Use Repository.SQLQuery() (safe, read-only) to fetch information quickly. It returns XML you parse with string functions.\n\n\nExample 21.1 - SQLQuery_Classes.js – JScript (ES3)\n\n// -------------------------------------------------------\n// Example 21.1 - SQLQuery_Classes.js – JScript (ES3)\n// Purpose: Query DB for all Class names\n// -------------------------------------------------------\n!INC Local Scripts.EAConstants-JScript\n\nfunction between(h,a,b){\n  var i=h.indexOf(a); if(i&lt;0)return\"\";\n  var j=h.indexOf(b,i+a.length); if(j&lt;0)return\"\";\n  return h.substring(i+a.length,j);\n}\n\nfunction main(){\n  var sql = \"SELECT Name FROM t_object WHERE Object_Type='Class'\";\n  var xml = Repository.SQLQuery(sql);\n  var rows = xml.split(\"&lt;Row&gt;\");\n  for (var i=1;i&lt;rows.length;i++){\n    var nm = between(rows[i],\"&lt;Name&gt;\",\"&lt;/Name&gt;\");\n    Session.Output(\"Class: \"+nm);\n  }\n}\nmain();\n\n\nCount Requirements\nvar sql = \"SELECT COUNT(\\*) AS CNT FROM t_object WHERE Object_Type='Requirement'\";\nvar xml = Repository.SQLQuery(sql);\nSession.Output(\"Requirement count = \"+between(xml,\"\\&lt;CNT\\&gt;\",\"\\&lt;/CNT\\&gt;\"));\nTips\n\nTable t_object → elements.\nTable t_package → packages.\nTable t_connector → relationships.\nUse Repository.SQLQuery only; avoid Repository.Execute for writes (unsafe).",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#standard-script-header-template",
    "href": "22-System.Object[].html#standard-script-header-template",
    "title": "Chapter 21: Reference",
    "section": "Standard Script Header Template",
    "text": "Standard Script Header Template\nConsistency makes scripts maintainable. Always include a header like this:\n// -------------------------------------------------------\n// Script Name: [NameHere]\n// Purpose: [What the script does in plain language]\n// Usage: [How to run it; context required]\n// Assumptions: [What must be selected; ES3 runtime only]\n// Safety: [Read-only / DRY_RUN / destructive with caution]\n// Dependencies: [Shared helpers, external tools]\n// Update history:\n//   v1.0 (2025-08-26) – Initial\n//   v1.1 (2025-09-01) – Added dry-run flag\n// -------------------------------------------------------",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#logging-helper-snippet",
    "href": "22-System.Object[].html#logging-helper-snippet",
    "title": "Chapter 21: Reference",
    "section": "Logging Helper Snippet",
    "text": "Logging Helper Snippet\nLogging is essential for dry-run, auditing, and governance. Use a helper that writes both to Output and CSV.\n// -------------------------------------------------------\n// Logger.js – reusable helper\n// Purpose: Write logs both to Output tab and CSV\n// -------------------------------------------------------\nfunction Logger(tabName, filePath){\n  this.tab = tabName;\n  Repository.CreateOutputTab(tabName);\n  Repository.ClearOutput(tabName);\n\n  var fso = new ActiveXObject(\"Scripting.FileSystemObject\");\n  var file = fso.OpenTextFile(filePath, 8 /*append*/, true /*create*/);\n\n  this.log = function(msg){\n    Session.Output(msg);\n    file.WriteLine(msg);\n  };\n\n  this.close = function(){ file.Close(); };\n}\n\n// Usage example:\nfunction main(){\n  var log = new Logger(\"MyScript\",\"C:\\\\temp\\\\myscript.log\");\n  log.log(\"Script started.\");\n  // ... your logic ...\n  log.close();\n}",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#common-objecttype-values",
    "href": "22-System.Object[].html#common-objecttype-values",
    "title": "Chapter 21: Reference",
    "section": "Common ObjectType Values",
    "text": "Common ObjectType Values\nWhen checking what the user has selected:\n\notElement (4) — an element (Class, Requirement, etc.).\notPackage (5) — a package.\notDiagram (8) — a diagram.\notAttribute (9) — a class attribute.\notMethod (10) — a method.\n\nPattern\nvar obj = Repository.GetTreeSelectedObject();\nif (obj.ObjectType == otPackage) {\n  Session.Output(\"Package: \" + obj.Name);\n} else if (obj.ObjectType == otElement) {\n  Session.Output(\"Element: \" + obj.Name);\n}",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#common-errors-quick-table",
    "href": "22-System.Object[].html#common-errors-quick-table",
    "title": "Chapter 21: Reference",
    "section": "Common Errors Quick Table",
    "text": "Common Errors Quick Table\n\n\n\n\n\n\n\n\nSymptom\nLikely Cause\nFix\n\n\n\n\nChange not saved\nForgot .Update()\nAlways call Update()\n\n\nChange saved but not visible\nForgot RefreshModelView()\nRefresh at end of script\n\n\n“Object doesn’t support forEach”\nTried JS array methods on collections\nUse .Count / .GetAt(i)\n\n\nDeletes skip items\nLooping forward while deleting\nLoop backwards\n\n\nCharacters “???” in export\nANSI encoding in JScript FSO\nUse Python/C# for UTF-8",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#quick-reuse-snippets",
    "href": "22-System.Object[].html#quick-reuse-snippets",
    "title": "Chapter 21: Reference",
    "section": "Quick Reuse Snippets",
    "text": "Quick Reuse Snippets\n\nSafe delete loop\nfor (var i=col.Count-1; i\\&gt;=0; i--) col.DeleteAt(i,false);\n\n\nDRY_RUN guard\nif (!DRY_RUN) { e.Update(); }\n\n\nString trim\nfunction trim(s){return\ns==null?\"\":String(s).replace(/^\\s+\\|\\s+\\$/g,\"\");}",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "22-System.Object[].html#summary",
    "href": "22-System.Object[].html#summary",
    "title": "Chapter 21: Reference",
    "section": "Summary",
    "text": "Summary\nThis reference chapter gives you the essentials at a glance:\n\nThe object model map.\nSQL query patterns.\nStandard headers.\nLogging helper.\nCommon ObjectTypes and errors.\n\nKeep it open as your daily cheat-sheet: it saves time, avoids mistakes, and makes your scripts consistent.** **\nAppendices",
    "crumbs": [
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Chapter 21: Reference</span>"
    ]
  },
  {
    "objectID": "23-System.Object[].html",
    "href": "23-System.Object[].html",
    "title": "Appendix A: Scripting Constraints",
    "section": "",
    "text": "A.1 Language Constraints\nThese are the house rules for safe scripting in Sparx EA, based on your Sparx scripting constraints.txt and reinforced by experience.",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Appendix A: Scripting Constraints</span>"
    ]
  },
  {
    "objectID": "23-System.Object[].html#a.1-language-constraints",
    "href": "23-System.Object[].html#a.1-language-constraints",
    "title": "Appendix A: Scripting Constraints",
    "section": "",
    "text": "EA’s internal scripting engine supports VBScript, JScript (Microsoft JScript, ES3), and JavaScript (recent builds).\nAlways assume ES3:\n\nUse var (no let/const).\nNo arrow functions (()=&gt;).\nNo forEach/map (EA collections are COM, not arrays).\nNo JSON.parse/stringify (manual or external only).",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Appendix A: Scripting Constraints</span>"
    ]
  },
  {
    "objectID": "23-System.Object[].html#a.2-object-handling",
    "href": "23-System.Object[].html#a.2-object-handling",
    "title": "Appendix A: Scripting Constraints",
    "section": "A.2 Object Handling",
    "text": "A.2 Object Handling\n\nEA collections → .Count and .GetAt(i).\nAlways .Update() after modifying an object.\nAlways Repository.RefreshModelView() to sync UI.\nDelete loops → iterate backwards.\nCheck ObjectType before assuming Package/Element.",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Appendix A: Scripting Constraints</span>"
    ]
  },
  {
    "objectID": "23-System.Object[].html#a.3-file-io",
    "href": "23-System.Object[].html#a.3-file-io",
    "title": "Appendix A: Scripting Constraints",
    "section": "A.3 File I/O",
    "text": "A.3 File I/O\n\nJScript’s FileSystemObject writes ANSI only.\nFor UTF-8, use external automation (Python/C#).\nAlways select an output directory, not a filename; filenames must be auto-derived by script.",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Appendix A: Scripting Constraints</span>"
    ]
  },
  {
    "objectID": "23-System.Object[].html#a.4-safety-rules",
    "href": "23-System.Object[].html#a.4-safety-rules",
    "title": "Appendix A: Scripting Constraints",
    "section": "A.4 Safety Rules",
    "text": "A.4 Safety Rules\n\nEvery modifying script must include a DRY_RUN flag, default true.\nEvery modifying script must log actions (at least to Output tab; ideally to CSV).\nAll scripts must start with a verbose header (purpose, usage, assumptions, safety, dependencies, update history).",
    "crumbs": [
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>Appendix A: Scripting Constraints</span>"
    ]
  },
  {
    "objectID": "24-System.Object[].html",
    "href": "24-System.Object[].html",
    "title": "Appendix B: External Automation",
    "section": "",
    "text": "B.1 Attaching Externally\nSometimes EA’s internal scripting isn’t enough. That’s when you use COM automation from languages like Python, C#, Java.",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Appendix B: External Automation</span>"
    ]
  },
  {
    "objectID": "24-System.Object[].html#b.1-attaching-externally",
    "href": "24-System.Object[].html#b.1-attaching-externally",
    "title": "Appendix B: External Automation",
    "section": "",
    "text": "Launch EA first, or start via COM.\nUse the EA.App ProgID:\n\n\nimport win32com.client\nea = win32com.client.Dispatch(“EA.App”)\nrepo = ea.Repository\n\n\nIn C#, add reference to Interop.EA.dll (from EA install folder).",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Appendix B: External Automation</span>"
    ]
  },
  {
    "objectID": "24-System.Object[].html#b.2-when-to-go-external",
    "href": "24-System.Object[].html#b.2-when-to-go-external",
    "title": "Appendix B: External Automation",
    "section": "B.2 When to Go External",
    "text": "B.2 When to Go External\n\nYou need UTF-8 I/O (CSV/JSON).\nYou need HTTP/REST APIs (Jira, Confluence, registries).\nYou need better libraries (Python csv, json; C# Newtonsoft.Json).\nYou want CI/CD automation or Git integration.",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Appendix B: External Automation</span>"
    ]
  },
  {
    "objectID": "24-System.Object[].html#b.3-bitness",
    "href": "24-System.Object[].html#b.3-bitness",
    "title": "Appendix B: External Automation",
    "section": "B.3 Bitness",
    "text": "B.3 Bitness\n\nEA is typically 32-bit.\nPython/C# must match bitness (32-bit Python to attach via COM).\nCheck Interop.EA.dll reference matches installed EA.",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Appendix B: External Automation</span>"
    ]
  },
  {
    "objectID": "24-System.Object[].html#b.4-add-ins",
    "href": "24-System.Object[].html#b.4-add-ins",
    "title": "Appendix B: External Automation",
    "section": "B.4 Add-ins",
    "text": "B.4 Add-ins\n\nC# Class Library DLL, COM-visible, registry entry under EAAddins.\nEA calls known methods: EA_Connect, EA_GetMenuItems, EA_MenuClick, etc.\nUse Add-ins when you need: permanent menus, event handling, richer UI.",
    "crumbs": [
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Appendix B: External Automation</span>"
    ]
  },
  {
    "objectID": "25-System.Object[].html",
    "href": "25-System.Object[].html",
    "title": "Appendix C: Glossary of Terms",
    "section": "",
    "text": "Add-in — A COM-visible DLL (C# or VB.NET) that EA loads at startup, adding menus, toolbars, and event handlers.\nAPI (Automation Interface) — The COM object model exposed by EA (Repository, Package, Element, Connector, etc.).\nAttribute — A property of a Class element; accessed via Element.Attributes.\nConnector — A relationship between elements (e.g., Association, Realisation). Access via Element.Connectors.\nDiagramObject — A visual instance of an element on a diagram; stores coordinates and style, not semantics.\nDry Run (DRY_RUN) — A safety flag in scripts: simulate changes and log, but don’t commit updates.\nElement — A modelled item (Class, Requirement, UseCase, Component, etc.).\nGUID — Global Unique Identifier string assigned to every element, connector, and package. Prefer GUIDs for stable identification.\nMDG Technology — A profile/extension package for EA (stereotypes, tagged values, toolboxes, etc.). Scripts must use StereotypeEx for full qualified stereotypes (profile::stereo).\nObjectType — Integer enum identifying what an object is (otElement, otPackage, otDiagram, etc.).\nPackage — Container for elements, diagrams, and child packages.\nRepository — Root of the automation API; represents the current EA model (QEA/EAP file or DB connection).\nSQLQuery — Repository.SQLQuery(sql) executes a SQL SELECT against EA’s database and returns XML. Use only for reads.\nUpdate() — Method to persist changes to database; required after modifying any object.\nWinHTTP — Windows COM object (WinHttp.WinHttpRequest.5.1) usable from JScript for basic HTTP requests.",
    "crumbs": [
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Appendix C: Glossary of Terms</span>"
    ]
  },
  {
    "objectID": "26-System.Object[].html",
    "href": "26-System.Object[].html",
    "title": "Appendix D: Quick Reference",
    "section": "",
    "text": "Error Symptom\nLikely Cause\nFix\n\n\n\n\nChange not saved\nForgot .Update()\nAlways update objects\n\n\nChange not visible until restart\nForgot Repository.RefreshModelView()\nRefresh after updates\n\n\n“forEach is not a function”\nUsed JS array method on EA collection\nUse .Count/.GetAt(i)\n\n\nDeletes skip items\nForward loop while deleting\nLoop backwards\n\n\nUTF-8 characters become “???”\nFSO writes ANSI only\nUse external Python/C#\n\n\n“Method not found: GetElementByGUID”\nAPI casing differences\nUse safe wrapper (Guid/GUID)\n\n\nObject type mismatch\nAssumed element, got package/diagram\nAlways check ObjectType",
    "crumbs": [
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Appendix D: Quick Reference</span>"
    ]
  },
  {
    "objectID": "27-System.Object[].html",
    "href": "27-System.Object[].html",
    "title": "Appendix E: External Automation Setup",
    "section": "",
    "text": "E.1 Purpose\nThis appendix provides the reusable EAConnect helper class plus the configuration details required to build external automation tools against Enterprise Architect (EA). It is intended as the “plumbing” layer behind the example in Chapter 6 – External Automation.\nThe EAConnect helper abstracts the complexities of EA’s COM interface and standardises safety practices:\nWith this helper, your utilities focus on intent rather than boilerplate.",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Appendix E: External Automation Setup</span>"
    ]
  },
  {
    "objectID": "27-System.Object[].html#e.1-purpose",
    "href": "27-System.Object[].html#e.1-purpose",
    "title": "Appendix E: External Automation Setup",
    "section": "",
    "text": "Attaching to or launching EA consistently\nWaiting for the Repository to become available\nOpening models automatically if needed\nHandling bitness and Interop.EA.dll\nProviding safe wrappers for common tasks (find package, add element, add tagged value)\nEnforcing dry-run by default\nWriting CSV audit logs with auto-derived filenames\nRefreshing EA’s UI at sensible points",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Appendix E: External Automation Setup</span>"
    ]
  },
  {
    "objectID": "27-System.Object[].html#e.2-usage",
    "href": "27-System.Object[].html#e.2-usage",
    "title": "Appendix E: External Automation Setup",
    "section": "E.2 Usage",
    "text": "E.2 Usage\nA minimal program using the helper:\n\nusing System;\n\nusing EA;\n\nusing EA.Automation; // the helper namespace\n\nclass Program\n\n{\n\n\\[STAThread\\]\n\nstatic void Main(string\\[\\] args)\n\n{\n\nusing var ea = EAConnect.AttachOrLaunch(new EAConnect.Options { ShowUI =\ntrue });\n\nPackage pkg = ea.GetSelectedPackageOrRoot();\n\nvar result = EAConnect.AddElement(ea.Repo, pkg, \"DemoClass\", \"Class\",\n\n\"Created by EAConnect.\", dryRun: true);\n\nConsole.WriteLine(result.Summary);\n\n}\n\n}\nThis pattern keeps the Program.cs short and declarative. All detailed logic resides in the helper.",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Appendix E: External Automation Setup</span>"
    ]
  },
  {
    "objectID": "27-System.Object[].html#e.3-the-eaconnect-helper-class",
    "href": "27-System.Object[].html#e.3-the-eaconnect-helper-class",
    "title": "Appendix E: External Automation Setup",
    "section": "E.3 The EAConnect Helper Class",
    "text": "E.3 The EAConnect Helper Class\n’’’csharp // =======================================================================\n// File: EAConnect.cs\n// Project: EA Automation Helper\n// Author: &lt;Your Name&gt;\n// Created: 2025-08-31\n// Last Update: 2025-08-31\n//\n// PURPOSE\n// ——-\n// Provides a safe, reusable abstraction over EA’s COM automation API.\n// Handles: attach/launch, repository polling, model open, package\n// resolution,\n// element creation, tagged value creation, CSV logging, and UI refresh.\n//\n// USAGE\n// —–\n// using var ea = EAConnect.AttachOrLaunch(new EAConnect.Options {\n// ShowUI = true });\n// var pkg = ea.GetSelectedPackageOrRoot();\n// var result = EAConnect.AddElement(ea.Repo, pkg, “NewClass”, “Class”,\n// “Notes”, true);\n// Console.WriteLine(result.Summary);\n//\n// ASSUMPTIONS\n// ———–\n// - EA is installed and COM-registered (ProgID = “EA.App”).\n// - Interop.EA.dll referenced (from EA install folder).\n// - Bitness of project matches EA (x64 for EA 64-bit; x86 for 32-bit).\n// - .NET project marked [STAThread] on entry point.\n//\n// SAFETY\n// ——\n// - Dry-run enabled by default in sample programs.\n// - CSV audit logging for all writes.\n// - UI refresh at batch boundaries only.\n//\n// DEPENDENCIES\n// ————\n// - System.Runtime.InteropServices (Marshal.GetActiveObject).\n// - Interop.EA.dll.\n//\n// UPDATE HISTORY\n// ————–\n// - 2025-08-31: Initial helper version.",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Appendix E: External Automation Setup</span>"
    ]
  },
  {
    "objectID": "27-System.Object[].html#e.3-the-eaconnect-helper-class-1",
    "href": "27-System.Object[].html#e.3-the-eaconnect-helper-class-1",
    "title": "Appendix E: External Automation Setup",
    "section": "E.3 The EAConnect Helper Class",
    "text": "E.3 The EAConnect Helper Class\n’’’csharp // =======================================================================\n// File: EAConnect.cs\n// Project: EA Automation Helper\n// Author: &lt;Your Name&gt;\n// Created: 2025-08-31\n// Last Update: 2025-08-31\n//\n// PURPOSE\n// ——-\n// Provides a safe, reusable abstraction over EA’s COM automation API.\n// Handles: attach/launch, repository polling, model open, package\n// resolution,\n// element creation, tagged value creation, CSV logging, and UI refresh.\n//\n// USAGE\n// —–\n// using var ea = EAConnect.AttachOrLaunch(new EAConnect.Options {\n// ShowUI = true });\n// var pkg = ea.GetSelectedPackageOrRoot();\n// var result = EAConnect.AddElement(ea.Repo, pkg, “NewClass”, “Class”,\n// “Notes”, true);\n// Console.WriteLine(result.Summary);\n//\n// ASSUMPTIONS\n// ———–\n// - EA is installed and COM-registered (ProgID = “EA.App”).\n// - Interop.EA.dll referenced (from EA install folder).\n// - Bitness of project matches EA (x64 for EA 64-bit; x86 for 32-bit).\n// - .NET project marked [STAThread] on entry point.\n//\n// SAFETY\n// ——\n// - Dry-run enabled by default in sample programs.\n// - CSV audit logging for all writes.\n// - UI refresh at batch boundaries only.\n//\n// DEPENDENCIES\n// ————\n// - System.Runtime.InteropServices (Marshal.GetActiveObject).\n// - Interop.EA.dll.\n//\n// UPDATE HISTORY\n// ————–\n// - 2025-08-31: Initial helper version.",
    "crumbs": [
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>Appendix E: External Automation Setup</span>"
    ]
  },
  {
    "objectID": "00-System.Object[].html",
    "href": "00-System.Object[].html",
    "title": "Preface",
    "section": "",
    "text": "Scripting in Sparx Enterprise Architect (EA) has always been both an art and a science.\nMost modellers discover the scripting window by accident, write a few lines of JScript or VBScript, and quickly realise that the possibilities extend far beyond simple automation.\nA well-structured script can transform EA from a drawing tool into a complete modelling environment—one that enforces standards, generates documentation, and maintains semantic consistency across large repositories.\nThis handbook was written for practitioners who have reached that moment of discovery and want to go further. It assumes you already understand EA’s modelling concepts but want to learn how to harness its automation interface responsibly and effectively. Each chapter builds practical skills through worked examples, annotated listings, and clear explanations of what is happening behind the scenes.\nThe code examples use a deliberately verbose commenting style. This reflects the author’s conviction that scripts in EA are not disposable experiments but integral parts of the architectural record. A script that can explain itself is a script that can be maintained, audited, and reused.\nYou will encounter snippets written in JScript, VBScript, and Python, each chosen for a particular purpose. JScript remains the most widely used within EA because of its direct integration and immediate execution. VBScript appears in legacy environments and in examples where readability or COM automation syntax is clearer. Python is included to illustrate how EA can be automated externally through its COM interface, opening the door to advanced analytics, testing, and integration pipelines.\nBeyond code, this book emphasises discipline. Automation without discipline quickly becomes chaos. By treating scripts as first-class architectural artefacts—version-controlled, documented, and tested—you build confidence not only in your tools but in the models that depend on them.\nThe examples that follow have been developed and refined through real-world use across government, healthcare, and defence projects. They are designed to be copied, adapted, and improved. Each one begins with a clear purpose, a short description of assumptions, and a structured header that records when and why it was written. Together they form a working library that you can evolve to suit your own organisation.\nMy hope is that this book helps you move from drawing diagrams to engineering models—from manipulating shapes on a screen to crafting automated reasoning tools that truly represent the systems you design. If it inspires you to share your own scripts, extend these techniques, or simply think differently about what EA can become, it will have achieved its purpose.\nTito Castillo\nLondon, 2025",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "01-System.Object[].html",
    "href": "01-System.Object[].html",
    "title": "Contents",
    "section": "",
    "text": "Chapter 1: Why Script EA? [1](#chapter-1-why-script-ea)\nBenefits of Automation in Modelling [1](#benefits-of-automation-in-modelling)\nTypical Use Cases [1](#typical-use-cases)\nWhen Not to Script [2](#when-not-to-script)\nWhy Scripting Matters for Governance [2](#why-scripting-matters-for-governance)\nYour First “Hello EA” Script [3](#your-first-hello-ea-script)\nSafe Practice: The Dry Run Principle [4](#safe-practice-the-dry-run-principle)\nA Different Way of Modelling [4](#a-different-way-of-modelling)\nPreparing for the Examples [4](#preparing-for-the-examples)\nLooking Ahead [5](#looking-ahead)\nChapter 2: Automation Landscape [6](#chapter-2-automation-landscape)\nBuilt-In Script Engine [6](#built-in-script-engine)\nScripting options [6](#scripting-options)\nExternal Automation [7](#external-automation)\n“Hello EA” Examples [7](#hello-ea-examples)\nComparing the Three [9](#comparing-the-three)\nThe Role of COM [9](#the-role-of-com)\nChoosing the Right Tool [10](#choosing-the-right-tool)\nSafety in Each Layer [10](#safety-in-each-layer)\nShaping Automation Practice [10](#shaping-automation-practice)\nLooking Ahead [11](#looking-ahead-1)\nChapter 3: Getting Started [12](#chapter-3-getting-started)\nThe Importance of Backups [12](#the-importance-of-backups)\nThe Dry-Run Principle [13](#the-dry-run-principle)\nLogging and Transparency [13](#logging-and-transparency)\nUnderstanding the Repository Structure [13](#understanding-the-repository-structure)\nUpdate and Refresh [14](#update-and-refresh)\nAvoiding Dangerous Patterns [15](#avoiding-dangerous-patterns)\nTesting on Small Sets [15](#testing-on-small-sets)\nCultural Safety [15](#cultural-safety)\nBuilding the Right Habits [16](#building-the-right-habits)\nChapter 4: API Essentials [17](#chapter-4-api-essentials)\nWhy Understand the API? [17](#why-understand-the-api)\nThe Object Model [18](#the-object-model)\nRepository [19](#repository)\nPackages [20](#packages)\nElements [21](#elements)\nConnectors [22](#connectors)\nAttribute and Method: Details of Elements [22](#attribute-and-method-details-of-elements)\nTagged Values [24](#tagged-values)\nSQL vs API [24](#sql-vs-api)\nUpdate and RefreshModelView [26](#update-and-refreshmodelview)\nThe 80/20 Principle in Practice [26](#the-8020-principle-in-practice)\nLearning Through Patterns [26](#learning-through-patterns)\nCommon Pitfalls [26](#common-pitfalls)\nLooking Ahead [27](#looking-ahead-2)\nChapter 5: Inside EA with JScript [28](#chapter-5-inside-ea-with-jscript)\nThe Language Landscape [28](#the-language-landscape)\nJavaScript or JScript? [29](#javascript-or-jscript)\nThe Constraints of JScript ES3 [29](#the-constraints-of-jscript-es3)\nScripting Tips [30](#scripting-tips)\nA Progressive Learning Curve [31](#a-progressive-learning-curve)\nPreparing for the Examples [32](#preparing-for-the-examples-1)\nLooking Ahead [38](#looking-ahead-3)\nChapter 6: External Automation [39](#chapter-6-external-automation)\nWhy external automation? [39](#why-external-automation)\nHow it works (at a glance) [39](#how-it-works-at-a-glance)\nTrade-offs [42](#trade-offs)\nWhere this goes next [43](#where-this-goes-next)\nChapter 7: Script Design Patterns [44](#chapter-7-script-design-patterns)\nWhy Patterns Matter [44](#why-patterns-matter)\nExamples [46](#examples)\nPattern Handling [57](#pattern-handling)\nPerformance & Safety Notes [59](#performance-safety-notes)\nBonus: Python “Curate → Apply” Pipeline [60](#bonus-python-curate-apply-pipeline)\nWhat to Use When (cheat-sheet) [60](#what-to-use-when-cheat-sheet)\nChapter 8: Object Details [61](#chapter-8-object-details)\nSparx EA Objects [61](#sparx-ea-objects)\nSummary [67](#summary)\nChapter 9: Imports & Exports [68](#chapter-9-imports-exports)\nWhy Imports Matter [68](#why-imports-matter)\nWhy Exports Matter [69](#why-exports-matter)\nThe Round-Trip Challenge [69](#the-round-trip-challenge)\nCommon Pitfalls [69](#common-pitfalls-1)\nChoosing a Format [70](#choosing-a-format)\nGUIDs, Keys, and Identity [70](#guids-keys-and-identity)\nCurated Imports [71](#curated-imports)\nSafety in Exports [71](#safety-in-exports)\nIntegrating Imports/Exports into Workflows [71](#integrating-importsexports-into-workflows)\nWhat you’ll use [72](#what-youll-use)\nManaging GUIDs & Avoiding Duplicates [80](#managing-guids-avoiding-duplicates)\nScaling Up (Performance) [80](#scaling-up-performance)\nSafety Checklist [81](#safety-checklist)\nWhat to use when [81](#what-to-use-when)\nChapter 10: MDG-Aware Scripting [82](#chapter-10-mdg-aware-scripting)\nWhat Are MDGs? [82](#what-are-mdgs)\nWhy MDGs Matter for Scripting [83](#why-mdgs-matter-for-scripting)\nImportant Tips [83](#important-tips)\nMDGs in External Automation [85](#mdgs-in-external-automation)\nSafety and Governance [85](#safety-and-governance)\nExamples [86](#examples-1)\nSafety & governance notes [94](#safety-governance-notes)\nWhat to use when (cheat-sheet) [94](#what-to-use-when-cheat-sheet-1)\nChapter 11: Governance Scripts [95](#chapter-11-governance-scripts)\nWhy Governance Matters [95](#why-governance-matters)\nThe Pain of Manual Governance [96](#the-pain-of-manual-governance)\nGovernance and MDGs [98](#governance-and-mdgs)\nExamples [99](#examples-2)\nSummary [104](#summary-1)\nChapter 12: Cookbook of Examples [105](#chapter-12-cookbook-of-examples)\nThe Value of Worked Examples [105](#the-value-of-worked-examples)\nThe Scope of the Cookbook [105](#the-scope-of-the-cookbook)\nWhy Not Just Copy from the Internet? [106](#why-not-just-copy-from-the-internet)\nSafety First in a Cookbook [106](#safety-first-in-a-cookbook)\nAdapting Recipes to Your Context [107](#adapting-recipes-to-your-context)\nThe Teaching Role of Recipes [107](#the-teaching-role-of-recipes)\nBuilding a Shared Library [107](#building-a-shared-library)\nCookbook Limitations [107](#cookbook-limitations)\nAI and Cookbook Expansion [108](#ai-and-cookbook-expansion)\nSummary [116](#summary-2)\nChapter 13: Why AI Helps [117](#chapter-13-why-ai-helps)\nBenefits [117](#benefits)\nUsing AI Safely [119](#using-ai-safely)\nAI and Learning [120](#ai-and-learning)\nAI in Daily Workflow [120](#ai-in-daily-workflow)\nExamples [121](#examples-3)\nUsing AI for Documentation [122](#using-ai-for-documentation)\nBest Practices for AI-Assisted Scripting [123](#best-practices-for-ai-assisted-scripting)\nSummary [123](#summary-3)\nChapter 14: Prompt Engineering [124](#chapter-14-prompt-engineering)\nWhy Prompt Engineering Matters [124](#why-prompt-engineering-matters)\nPrompt Engineering as Team Practice [127](#prompt-engineering-as-team-practice)\nAI Literacy for Modellers [127](#ai-literacy-for-modellers)\nPrompt Template [127](#prompt-template)\nExamples [129](#examples-4)\nBest Practices for Prompts [133](#best-practices-for-prompts)\nSummary [133](#summary-4)\nChapter 15: AI Refactoring Partner [134](#chapter-15-ai-refactoring-partner)\nWhy Refactoring Matters in EA Scripting [134](#why-refactoring-matters-in-ea-scripting)\nThe AI Advantage in Refactoring [135](#the-ai-advantage-in-refactoring)\nCommon Refactoring Needs [135](#common-refactoring-needs)\nRisks of AI Refactoring [136](#risks-of-ai-refactoring)\nA Human–AI Workflow for Refactoring [136](#a-humanai-workflow-for-refactoring)\nAI for Documentation Retrofitting [136](#ai-for-documentation-retrofitting)\nRefactoring for Governance [137](#refactoring-for-governance)\nBeyond EA: Refactoring Across Languages [137](#beyond-ea-refactoring-across-languages)\nThe Cultural Impact of Refactoring with AI [137](#the-cultural-impact-of-refactoring-with-ai)\nExamples [138](#examples-5)\nSummary [141](#summary-5)\nChapter 16: AI in Daily Workflow [143](#chapter-16-ai-in-daily-workflow)\nFrom Occasional Help to Daily Companion [143](#from-occasional-help-to-daily-companion)\nThe Role of a Prompt Library [144](#the-role-of-a-prompt-library)\nAutomating Boilerplate [144](#automating-boilerplate)\nAI as a Debugging Partner [144](#ai-as-a-debugging-partner)\nIntegration with Version Control [145](#integration-with-version-control)\nGovernance and Reporting [145](#governance-and-reporting)\nRisks of Daily AI Use [145](#risks-of-daily-ai-use)\nAI as a Team Enabler [146](#ai-as-a-team-enabler)\nGit + AI Workflow [148](#git-ai-workflow)\nAI-Assisted Governance Check [148](#ai-assisted-governance-check)\nSummary [149](#summary-6)\nChapter 17: Performance & Scaling [150](#chapter-17-performance-scaling)\nWhy Performance Matters [150](#why-performance-matters)\nSources of Slowness [150](#sources-of-slowness)\nMeasure First [151](#measure-first)\nTips [151](#tips)\nPrinciples [152](#principles)\nExamples [154](#examples-6)\nDos & Don’ts (cheat-sheet) [161](#dos-donts-cheat-sheet)\nPutting It Together [162](#putting-it-together)\nChapter 18: Integrating with Workflows [163](#chapter-18-integrating-with-workflows)\nWhy Integration Matters [163](#why-integration-matters)\nThe Role of Automation in Integration [163](#the-role-of-automation-in-integration)\nCommon Integration Targets [164](#common-integration-targets)\nIntegration Approaches [164](#integration-approaches)\nThe Cultural Dimension of Integration [166](#the-cultural-dimension-of-integration)\nRisks of Integration [166](#risks-of-integration)\nExamples [167](#examples-7)\nNotes [169](#notes)\nSecrets, auth & bitness (read this!) [174](#secrets-auth-bitness-read-this)\nPutting it together (one realistic flow) [174](#putting-it-together-one-realistic-flow)\nTroubleshooting quick wins [175](#troubleshooting-quick-wins)\nChecklist (cheat-sheet) [175](#checklist-cheat-sheet)\nChapter 19: Add-ins vs Scripts [176](#chapter-19-add-ins-vs-scripts)\nScripts as the First Line of Automation [176](#scripts-as-the-first-line-of-automation)\nAdd-ins as Compiled Extensions [177](#add-ins-as-compiled-extensions)\nWhy Move from Script to Add-in? [177](#why-move-from-script-to-add-in)\nTrade-offs [177](#trade-offs-1)\nAdd-ins and Governance [178](#add-ins-and-governance)\nThe Learning Curve [178](#the-learning-curve)\nA Progressive Path [179](#a-progressive-path)\nCultural Impact [179](#cultural-impact)\nRisks of Add-ins [179](#risks-of-add-ins)\nExample [179](#example)\nWhen to Migrate Script → Add-in [181](#when-to-migrate-script-add-in)\nMigration Example [181](#migration-example)\nSummary [181](#summary-7)\nChapter 20: Troubleshooting [183](#chapter-20-troubleshooting)\nWhy Troubleshooting Matters [183](#why-troubleshooting-matters)\nThe Nature of EA’s Quirks [183](#the-nature-of-eas-quirks)\nThe Usual Suspects [184](#the-usual-suspects)\nThe Value of Defensive Patterns [185](#the-value-of-defensive-patterns)\nTroubleshooting as a Team Resource [186](#troubleshooting-as-a-team-resource)\nSafe Patterns Recap [189](#safe-patterns-recap)\nChapter 21: Reference [191](#chapter-21-reference)\nEA Object Model Map (Condensed) [191](#ea-object-model-map-condensed)\nSQL Cheat-Sheet (Read-only) [192](#sql-cheat-sheet-read-only)\nStandard Script Header Template [193](#standard-script-header-template)\nLogging Helper Snippet [193](#logging-helper-snippet)\nCommon ObjectType Values [194](#common-objecttype-values)\nCommon Errors Quick Table [194](#common-errors-quick-table)\nQuick Reuse Snippets [196](#quick-reuse-snippets)\nSummary [196](#summary-8)\nAppendix A: Scripting Constraints [198](#appendix-a-scripting-constraints)\nA.1 Language Constraints [198](#a.1-language-constraints)\nA.2 Object Handling [198](#a.2-object-handling)\nA.3 File I/O [198](#a.3-file-io)\nA.4 Safety Rules [198](#a.4-safety-rules)\nAppendix B: External Automation [199](#appendix-b-external-automation)\nB.1 Attaching Externally [199](#b.1-attaching-externally)\nB.2 When to Go External [199](#b.2-when-to-go-external)\nB.3 Bitness [199](#b.3-bitness)\nB.4 Add-ins [199](#b.4-add-ins)\nAppendix C: Glossary of Terms [200](#appendix-c-glossary-of-terms)\nAppendix D: Quick Reference [202](#appendix-d-quick-reference)\nAppendix E: External Automation Setup [203](#appendix-e-external-automation-setup)\nE.1 Purpose [203](#e.1-purpose)\nE.2 Usage [203](#e.2-usage)\nE.3 The EAConnect Helper Class [204](#e.3-the-eaconnect-helper-class)\nE.4 Configuration & Setup [208](#e.4-configuration-setup)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>**Contents**</span>"
    ]
  }
]
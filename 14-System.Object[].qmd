# Chapter 13: Why AI Helps 

By this point, we have explored why scripting Enterprise Architect is
essential, how the automation landscape is structured, and how to apply
safe, repeatable patterns. We have also seen how practical recipes can
turn concepts into working scripts. Yet for many modellers, one barrier
remains: the leap from knowing *that* scripting is possible to actually
writing the first line of code.

This is where **artificial intelligence (AI)** comes in. Large language
models (LLMs) such as ChatGPT, Claude, or Copilot have introduced a new
way of working: you no longer have to start from a blank editor window.
Instead, you can describe what you want in natural language and receive
a code draft to work with. AI can provide scaffolding, suggest
refactors, and generate boilerplate headers. It cannot replace human
judgement, but it can dramatically accelerate the scripting process.

This chapter examines why AI is such a powerful assistant in the EA
scripting context. It explains the barriers AI helps overcome, the risks
it introduces, and the ways to use it responsibly. By the end, you will
see AI not as a magic solution but as a valuable partner: one that helps
you get started, iterate faster, and learn more effectively.

## Benefits

### The Blank Page Problem

For many modellers, the hardest part of scripting is not the logic but
the start. Opening EA’s script editor and staring at an empty window can
be intimidating. Even if you know what you want to achieve — “rename all
requirements with a REQ\_ prefix” — translating that into correct
JScript syntax feels daunting.

AI reduces this barrier. By typing a prompt such as *“Write an EA script
that adds a prefix to all Requirement elements in a selected package”*,
you receive a draft that includes the right loop structure, .Count and
.GetAt() calls, and Update() method. It may not be perfect, but it is
far less intimidating than starting from zero.

### AI as a Pattern Generator

Earlier chapters emphasised the importance of scripting patterns:
Find/Filter/Apply, Tag Propagation, Curate-then-Write. AI is good at
recognising these patterns and generating boilerplate loops. Instead of
writing the same traversal logic repeatedly, you can ask AI to generate
it and then adjust the details.

For example, a prompt like *“Write a Find/Filter/Apply script that sets
the Status to Approved for all Requirements tagged with
‘Owner=Architecture’”* can yield a working draft in seconds.

### AI as a Translator

One of the practical challenges in EA scripting is the language choice.
Many legacy scripts are in VBScript, while most new ones are in JScript.
AI can act as a **translator**, converting VBScript examples into
JScript ES3. It can also help migrate JScript snippets into Python or C#
for external automation.

For example, you might paste an old VBScript snippet and ask:
*“Translate this into JScript (ES3 only, no forEach, no JSON methods).”*
AI can provide a draft translation that saves hours of manual effort.

### AI as a Refactoring Partner

As your script library grows, you may notice duplication: multiple
scripts with similar loops, slightly different logic, inconsistent
logging. AI can help refactor them into cleaner, more consistent
structures.

For instance, you might prompt: *“Refactor this script to include a
DRY_RUN flag and a logging function that writes to CSV.”* AI will
propose a refactored version, which you can then validate. This makes it
easier to standardise your script style and enforce governance
principles.

### AI for Documentation and Training

Another way AI adds value is in **documentation**. Good scripts should
always include headers (purpose, usage, assumptions, safety,
dependencies). Writing these headers can feel tedious. AI can generate
them for you.

Similarly, AI can create training material: explainers, walkthroughs, or
alternative language examples. For new team members, you can paste a
script into AI and ask it to explain what each line does in plain
English. This makes onboarding easier.

#### The Risks of AI in Scripting

Of course, AI is not perfect. In fact, it is often confidently wrong.
Common risks include:

- **Hallucinations**: inventing methods that do not exist (e.g., forEach
  on EA collections).

- **Unsupported syntax**: using modern JavaScript features (let, const,
  arrow functions) that fail in EA’s ES3 engine.

- **Unsafe updates**: forgetting to include Update() or DRY_RUN, leading
  to destructive changes.

- **Performance issues**: generating scripts that spam Session.Output
  thousands of times.

These risks are not minor. If you copy AI output blindly into a
production repository, you may corrupt or damage your model. That is why
AI must always be used with caution.

## Using AI Safely

The key to using AI effectively is to treat it as a **drafting tool**,
not an authority. You are the architect; AI is your assistant. That
means:

1.  **Craft precise prompts** — specify ES3, mention .Count/.GetAt(),
    require DRY_RUN.

2.  **Always dry-run first** — never trust AI code without logging and
    simulation.

3.  **Review carefully** — read the script line by line, confirm
    Update() is included where needed.

4.  **Test on sandboxes** — never run AI-generated scripts directly on
    production repositories.

With these safeguards, AI becomes a useful accelerator rather than a
liability.

## AI and Learning

Interestingly, using AI to generate scripts can also accelerate your own
learning. When you compare AI’s draft to your mental model, you notice
differences. Sometimes AI is wrong, and that highlights a gap in your
own understanding. Sometimes AI uses a trick you didn’t know, and you
learn from it.

Over time, AI becomes a tutor. You experiment by prompting, you review
the results, you test and refine. The process itself builds fluency in
the EA API.

## AI in Daily Workflow

Later in this book (Chapter 15), we will explore AI in daily workflow:
prompt libraries, Git integration, and governance checks. For now, the
key point is that AI is not just for occasional inspiration; it can be
integrated into your routine. Whether you are writing a new script,
refactoring an old one, or explaining a script to a colleague, AI can
help.

## Examples

### AI-generated vs Corrected

Suppose you ask an AI:

*“Write a script that lists all elements in a package.”*

You might get this **wrong version**:
```.js

// [x] AI output (modern JS not supported in EA)

let pkg = Repository.GetTreeSelectedPackage();

if (!pkg) { alert("Select a package"); }

pkg.Elements.forEach(e =\> console.log(e.Name));
```

This will fail inside EA because:

- let and arrow functions (=\>) are unsupported (JScript is ES3).

- EA Collections are not true arrays; .forEach does not exist.

- EA uses Session.Output, not console.log.

Here’s the corrected version:

```{.js filename="Example 13.1 - ListElements_Corrected.js – JScript (ES3)"}
// -------------------------------------------------------
// Example 13.1 - ListElements_Corrected.js – JScript (ES3)
// Purpose: Output element names in the selected package
// Safe version corrected from AI output
// -------------------------------------------------------
!INC Local Scripts.EAConstants-JScript

function main() {
    var pkg = Repository.GetTreeSelectedPackage();
    if (!pkg) {
        Session.Prompt("Select a package.", promptOK);
        return;
    }

    var els = pkg.Elements;
    for (var i=0; i<els.Count; i++) {
        var e = els.GetAt(i);
        Session.Output("Element: " + e.Name);
    }
}

main();
```

### AI-Assisted Refactoring

You can ask AI:

*“Refactor this script to add dry-run and logging to CSV.”*

AI may provide scaffolding, but you need to ensure it respects EA’s
environment.

Refactored pattern with dry-run and CSV logging:
```{.js filename="Example 13.2 - RefactorWithDryRun.js – JScript (ES3)"}
// -------------------------------------------------------
// Example 13.2 - RefactorWithDryRun.js – JScript (ES3)
// Purpose: Rename all Requirements with prefix, log to CSV
// Example of AI-assisted refactor (corrected to EA ES3)
// -------------------------------------------------------
!INC Local Scripts.EAConstants-JScript

function main() {
    var DRY_RUN = true;
    var PREFIX = "REQ_";

    var shell = new ActiveXObject("Shell.Application");
    var folder = shell.BrowseForFolder(0, "Select output folder for log CSV", 0, 0);
    if (!folder) return;
    var dir = folder.Self.Path;

    var fso = new ActiveXObject("Scripting.FileSystemObject");
    var file = fso.CreateTextFile(dir + "\\rename_log.csv", true);
    file.WriteLine("ElementID,OldName,NewName,Action");

    var pkg = Repository.GetTreeSelectedPackage();
    if (!pkg) { Session.Prompt("Select a package.", promptOK); return; }

    var els = pkg.Elements;
    for (var i=0; i<els.Count; i++) {
        var e = els.GetAt(i);
        if (e.Type == "Requirement" && e.Name.indexOf(PREFIX) != 0) {
            var newName = PREFIX + e.Name;
            file.WriteLine(e.ElementID + "," + e.Name + "," + newName + "," + (DRY_RUN ? "DRY_RUN" : "RENAME"));
            if (!DRY_RUN) { e.Name = newName; e.Update(); }
        }
    }
    if (!DRY_RUN) Repository.RefreshModelView(pkg.PackageID);
    file.Close();

    Session.Output("Script complete. Dry-run=" + DRY_RUN);
}

main();
```

## Using AI for Documentation

Another practical use of AI is **auto-generating headers**. For example,
you paste in a script and ask:

*“Add a structured header with purpose, usage, assumptions, and update
history.”*

AI can reliably produce your desired verbose headers (see Chapter 6’s
shared format), saving time and keeping your script library consistent.

## Best Practices for AI-Assisted Scripting

1.  **Always state the runtime**: “EA JScript, ES3 only, no ES6
    features.”

2.  **Request safety patterns**: dry-run flag, logging, Update() after
    changes.

3.  **Iterate small**: test on a dummy package, then scale up.

4.  **Curate prompts**: treat prompt engineering as coding. Be explicit.

5.  **Refactor, don’t trust blindly**: AI is a partner, not a
    replacement.

## Summary

AI helps Sparx EA users by generating scaffolding, converting languages,
and automating repetitive refactors. But the constraints of EA’s JScript
runtime mean you must always **review, test, and correct** AI outputs.
Use AI as an assistant, not an autopilot.

In the next chapter we’ll move to **Chapter 13 – Prompt Engineering for
EA Scripting**, where we’ll learn how to craft precise prompts that
yield safe, useful code for EA.
